<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법 | Jun Kang's Blog</title>
<meta name=keywords content="spring,TDD,JUnit,단위테스트,assertj"><meta name=description content="

1. 단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.

Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable -  어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다."><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/posts/45/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/45/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/45/"><meta property="og:title" content="[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법 | Jun Kang's Blog"><meta property="og:description" content="

1. 단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.

Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable -  어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다."><meta property="og:image" content="http://localhost:1313/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="http://localhost:1313/posts/45/"><meta property="twitter:title" content="[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법 | Jun Kang's Blog"><meta property="twitter:description" content="

1. 단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.

Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable -  어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다."><meta property="twitter:image" content="http://localhost:1313/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="http://localhost:1313/posts/45/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법"><meta property="og:description" content=" 1. 단위 테스트 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.
Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable - 어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-14T15:36:35+00:00"><meta property="article:modified_time" content="2023-11-14T15:36:35+00:00"><meta property="article:tag" content="Spring"><meta property="article:tag" content="TDD"><meta property="article:tag" content="JUnit"><meta property="article:tag" content="단위테스트"><meta property="article:tag" content="Assertj"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법"><meta name=twitter:description content="

1. 단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.

Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable -  어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법","item":"http://localhost:1313/posts/45/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법","name":"[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법","description":" 1. 단위 테스트 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.\nFast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.\nIndependent - 테스트는 독립적이며 서로 의존해서는 안된다.\nRepeatable - 어느 환경에서도 반복이 가능해야 한다.\nSelf-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.\nTimely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다.\n","keywords":["spring","TDD","JUnit","단위테스트","assertj"],"articleBody":" 1. 단위 테스트 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.\nFast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.\nIndependent - 테스트는 독립적이며 서로 의존해서는 안된다.\nRepeatable - 어느 환경에서도 반복이 가능해야 한다.\nSelf-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.\nTimely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다.\n2. Junit Junit은 단위 테스트를 지원하는 오픈소스 프레임워크로 다음과 같은 특징을 가진다.\n문자 혹은 GUI 기반으로 실행 @Test 메서드를 호출할 때마다 새 인스턴스 생성 예상결과를 검증하는 assertion 제공 자동실행, 자체결과 확인 및 즉각적인 피드백 제공 테스트 방식을 구분할 수 있는 어노테이션을 제공하며, 어노테이션만으로 간결하게 실행이 가능 ▶ 2-1. 어노테이션 종류 @DisplayName - 테스트 이름 명시\n@Test - 테스트를 수행할 메서드, Junit은 각 테스트끼리 영향을 주지 않도록 테스트 실행 객체를 매 테스트마다 만들고 종료 시 삭제\\\n@BeforeAll - 전체 테스트를 시작하기 전에 1회 실행 (ex. 데이터베이스 연결, 테스트환경 초기화, 전체 테스트 실행주기에 한 번만 호출)\n@BeforeEach - 테스트 케이스를 시작하기 전마다 실행 (테스트 메서드에 사용하는 객체 초기화, 테스트에 필요한 데이터 삽입 등)\n@AfterAll - 전체 테스트를 마치고 종료하기 전에 1회 실행 (데이터베이스 연결 종료, 공통으로 사용하는 자원 해제 등)\n@AfterEach - 테스트 케이스를 종료하기 전마다 실행 (테스트 이후 특정데이터를 삭제 등)\n▶ 2-2. AssertJ Junit과 사용해 가독성을 높여주는 라이브러리로 다양한 문법을 지원한다. 기존 Junit은 기댓값과 실제 비교대상이 확실히 보이지 않아 잘 구분이 안되지만 isEqualTo 등 명확한 의미의 매머드로 대체가 가능하다.\n▶ 2-3. given-when-then 패턴 요즘 단위테스트의 가장 보편적인 형태로 1개의 단위테스트를 3단계로 나눠서 처리하는 패턴이다.\ngiven = 테스트 실행을 준비하는 단계 (어떤 상황, 데이터가 주어졌을 때) when = 테스트를 진행하는 단계 (어떤 함수를 실행시키면 ) then = 테스트 결과를 검증하는 단계 (어떤 결과가 기대된다.) 3. 단위 테스트 예제 점수의 평균을 계산해주는 클래스에 대한 단위 테스트를 해보자. 해당 예제는 객체 간의 메시지 교환이 없는 단순한 값 비교, 예외 확인을 위한 테스트 케이스이다.(일반적으로 스프링 애플리케이션은 다양한 객체에서 메시지를 전달받아 의존성이 생기는데, 이럴 경우 Mock(가짜) 객체를 사용하여 테스트가 가능하다.)\n▶ 3-0. 테스트 대상인 평균점수 조회 다음과 같이 0점 이상의 점수들에 대한 평균을 구하는 클래스가 있을 때\npublic class AverageScoreCalculator { private static Integer sum = 0; private static Integer count = 0; public void addScore(Integer score) { if (!validateScores(score)) { throw new IllegalStateException(\"Invalid score\"); } sum += score; count++; } private boolean validateScores(Integer score) { return score \u003e 0; } public Double getAverageScore() { return (double) (sum / count); } } ▶ 3-1. 점수의 평균이 일치하는지 테스트 실제 평균의 값과, 클래스 연산 결과가 일치하는지 테스트한다.\n@DisplayName(\"점수의 평균 테스트\") @Test void averageScoreTest() { //given AverageScoreCalculator averageScoreCalculator = new AverageScoreCalculator(); int[] scores = {10,20,30,40,50}; //when for (int i = 0; i","wordCount":"737","inLanguage":"en","datePublished":"2023-11-14T15:36:35Z","dateModified":"2023-11-14T15:36:35Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/45/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법</h1><div class=post-meta><span title='2023-11-14 15:36:35 +0000 UTC'>November 14, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/45/img.png></p><h2 id=단위-테스트 style=color:#000;text-align:start ke-size=size26>1. 단위 테스트<a hidden class=anchor aria-hidden=true href=#단위-테스트>#</a></h2><p>하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.</p><blockquote><p><strong>Fast -</strong> 빠르게 동작하여 자주 돌릴 수 있어야 한다.<br><strong>Independent -</strong> 테스트는 독립적이며 서로 의존해서는 안된다.<br><strong>Repeatable -</strong>  어느 환경에서도 반복이 가능해야 한다.<br><strong>Self-validating -</strong> 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.<br><strong>Timely -</strong> 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다.</p></blockquote><h2 id=junit style=color:#000;text-align:start ke-size=size26>2. Junit<a hidden class=anchor aria-hidden=true href=#junit>#</a></h2><p>Junit은 단위 테스트를 지원하는 오픈소스 프레임워크로 다음과 같은 특징을 가진다.</p><ul><li>문자 혹은 GUI 기반으로 실행</li><li>@Test 메서드를 호출할 때마다 새 인스턴스 생성</li><li>예상결과를 검증하는 assertion 제공</li><li>자동실행, 자체결과 확인 및 즉각적인 피드백 제공</li><li>테스트 방식을 구분할 수 있는 어노테이션을 제공하며, 어노테이션만으로 간결하게 실행이 가능</li></ul><h3 id=어노테이션-종류 style=color:#000;text-align:start ke-size=size23>▶ 2-1. 어노테이션 종류<a hidden class=anchor aria-hidden=true href=#어노테이션-종류>#</a></h3><blockquote><p><strong>@DisplayName -</strong> 테스트 이름 명시<br><strong>@Test -</strong> 테스트를 수행할 메서드, Junit은 각 테스트끼리 영향을 주지 않도록 테스트 실행 객체를 매 테스트마다 만들고 종료 시 삭제\<br><strong>@BeforeAll -</strong> 전체 테스트를 시작하기 전에 1회 실행 (ex. 데이터베이스 연결, 테스트환경 초기화, 전체 테스트 실행주기에 한 번만 호출)<br><strong>@BeforeEach -</strong> 테스트 케이스를 시작하기 전마다 실행 (테스트 메서드에 사용하는 객체 초기화, 테스트에 필요한 데이터 삽입 등)<br><strong>@AfterAll -</strong> 전체 테스트를 마치고 종료하기 전에 1회 실행 (데이터베이스 연결 종료, 공통으로 사용하는 자원 해제 등)<br><strong>@AfterEach -</strong> 테스트 케이스를 종료하기 전마다 실행 (테스트 이후 특정데이터를 삭제 등)</p></blockquote><h3 id=assertj style=color:#000;text-align:start ke-size=size23>▶ 2-2. AssertJ<a hidden class=anchor aria-hidden=true href=#assertj>#</a></h3><p>Junit과 사용해 가독성을 높여주는 라이브러리로 다양한 문법을 지원한다. 기존 Junit은 기댓값과 실제 비교대상이 확실히 보이지 않아 잘 구분이 안되지만 isEqualTo 등 명확한 의미의 매머드로 대체가 가능하다.</p><h3 id=given-when-then-패턴 style=color:#000;text-align:start ke-size=size23>▶ 2-3. given-when-then 패턴<a hidden class=anchor aria-hidden=true href=#given-when-then-패턴>#</a></h3><p>요즘 단위테스트의 가장 보편적인 형태로 1개의 단위테스트를 3단계로 나눠서 처리하는 패턴이다.</p><ul><li><strong>given =</strong> 테스트 실행을 준비하는 단계 (어떤 상황, 데이터가 주어졌을 때)</li><li><strong>when =</strong> 테스트를 진행하는 단계 (어떤 함수를 실행시키면 )</li><li><strong>then =</strong> 테스트 결과를 검증하는 단계 (어떤 결과가 기대된다.)</li></ul><h2 id=단위-테스트-예제 style=color:#000;text-align:start ke-size=size26>3. 단위 테스트 예제<a hidden class=anchor aria-hidden=true href=#단위-테스트-예제>#</a></h2><p>점수의 평균을 계산해주는 클래스에 대한 단위 테스트를 해보자. 해당 예제는 객체 간의 메시지 교환이 없는 단순한 값 비교, 예외 확인을 위한 테스트 케이스이다.(일반적으로 스프링 애플리케이션은 다양한 객체에서 메시지를 전달받아 의존성이 생기는데, 이럴 경우 Mock(가짜) 객체를 사용하여 테스트가 가능하다.)</p><h3 id=테스트-대상인-평균점수-조회 style=color:#000;text-align:start ke-size=size23>▶ 3-0. 테스트 대상인 평균점수 조회 <a hidden class=anchor aria-hidden=true href=#테스트-대상인-평균점수-조회>#</a></h3><p>다음과 같이 0점 이상의 점수들에 대한 평균을 구하는 클래스가 있을 때</p><pre tabindex=0><code>public class AverageScoreCalculator {
    private static Integer sum = 0;
    private static Integer count = 0;
    public void addScore(Integer score) {
        if (!validateScores(score)) {
            throw new IllegalStateException(&#34;Invalid score&#34;);
        }
        sum += score;
        count++;
    }
    private boolean validateScores(Integer score) {
        return score &gt; 0;
    }
    public Double getAverageScore() {
        return (double) (sum / count);
    }
}
</code></pre><p> </p><h3 id=-3-1-점수의-평균이-일치하는지-테스트>▶ 3-1. 점수의 평균이 일치하는지 테스트<a hidden class=anchor aria-hidden=true href=#-3-1-점수의-평균이-일치하는지-테스트>#</a></h3><p>실제 평균의 값과, 클래스 연산 결과가 일치하는지 테스트한다.</p><pre tabindex=0><code>@DisplayName(&#34;점수의 평균 테스트&#34;)
    @Test
    void averageScoreTest() {
        //given
        AverageScoreCalculator averageScoreCalculator = new AverageScoreCalculator();
        int[] scores = {10,20,30,40,50};
        //when
        for (int i = 0; i&lt;scores.length; i++)    {
            averageScoreCalculator.addScore(scores[i]);
        }
        Double averageScore = averageScoreCalculator.getAverageScore();
        //then
        assertThat(averageScore).isEqualTo(Arrays.stream(scores).average().getAsDouble());
    }
</code></pre><h3 id=평균점수의-범위-테스트 style=color:#000;text-align:start ke-size=size23>▶ 3-2. 평균점수의 범위 테스트<a hidden class=anchor aria-hidden=true href=#평균점수의-범위-테스트>#</a></h3><p>점수의 평균이 1~100점 이내에 존재하는지 확인한다.</p><pre tabindex=0><code>@DisplayName(&#34;평균 점수 범위 테스트&#34;)
    @Test
    void averageScoreRangeTest()    {
        //given
        AverageScoreCalculator averageScoreCalculator = new AverageScoreCalculator();
        int[] scores = {10,20,30,40,50};
        //when
        for (int i = 0; i&lt;scores.length; i++)    {
            averageScoreCalculator.addScore(scores[i]);
        }
        Double averageScore = averageScoreCalculator.getAverageScore();
        //then
        assertThat(averageScore &gt;= 0 &amp;&amp; averageScore &lt;= 100).isTrue();
    }
</code></pre><p> </p><h3 id=-3-3-개별점수-유효성-테스트>▶ 3-3. 개별점수 유효성 테스트<a hidden class=anchor aria-hidden=true href=#-3-3-개별점수-유효성-테스트>#</a></h3><p>유효하지 않은 점수가 인풋 될 경우 IllegalStateException이 기대되기에, assertThrow로 Exception을 테스트한다.</p><pre tabindex=0><code>@DisplayName(&#34;개별 잘못된 점수 테스트&#34;)
    @Test
    public void averageScoreInvalidScoreTest(){
        //given
        AverageScoreCalculator averageScoreCalculator = new AverageScoreCalculator();
        int[] scores = {10,20,30,40,-1};
        //when
        final IllegalStateException exception = assertThrows(IllegalStateException.class, () -&gt; {
            for (int i = 0; i&lt;scores.length; i++)    {
                averageScoreCalculator.addScore(scores[i]);
            }
        });
        //then
        assertThat(exception.getMessage()).isEqualTo(&#34;Invalid score&#34;);
    }
</code></pre><h2 id=4-주요-assert-메서드>4. 주요 Assert 메서드 <a hidden class=anchor aria-hidden=true href=#4-주요-assert-메서드>#</a></h2><h3 id=4-1-주요-비교-검증-테스트-메서드>▶ 4-1. 주요 비교 검증 테스트 메서드<a hidden class=anchor aria-hidden=true href=#4-1-주요-비교-검증-테스트-메서드>#</a></h3><table><thead><tr><th>메서드 이름</th><th>설명</th></tr></thead><tbody><tr><td>isEqualTo(A)</td><td>A 값과 같은지 검증</td></tr><tr><td>isNotEqualTo(A)</td><td>A 값과 다른지 검증</td></tr><tr><td>contains(A)</td><td>A 값을 포함하는지 검증</td></tr><tr><td>doesNotContain(A)</td><td>A 값을 포함하지 않는지 검증</td></tr><tr><td>startWith(A)</td><td>접두사가 A인지 검증</td></tr><tr><td>endsWith(A)</td><td>접미사가 A인지 검증</td></tr><tr><td>isEmpty()</td><td>비어 있는 값인지 검증</td></tr><tr><td>isNotEmpty()</td><td>비어 있지 않은 값인지 검증</td></tr><tr><td>isPositive()</td><td>양수인지 검증</td></tr><tr><td>isNegative()</td><td>음수인지 검증</td></tr><tr><td>isGreaterThan(a)</td><td>a보다 큰 값인지 검증</td></tr><tr><td>isLessThan(a)</td><td>a보다 작은 값인지 검증</td></tr></tbody></table><h3 id=4-2-http-주요-응답코드-테스트-메서드>▶ 4-2. HTTP 주요 응답코드 테스트 메서드<a hidden class=anchor aria-hidden=true href=#4-2-http-주요-응답코드-테스트-메서드>#</a></h3><table><thead><tr><th>코드</th><th>매핑 메서드</th><th>설명</th></tr></thead><tbody><tr><td>200 OK</td><td>isOk()</td><td>HTTP 응답코드가 200 OK인지 검증</td></tr><tr><td>201 Created</td><td>isCreated()</td><td>HTTP 응답코드가 201 Created 검증</td></tr><tr><td>400 Bad Request</td><td>isBadRequest()</td><td>HTTP 응답코드가 400 BadRequest검증</td></tr><tr><td>403 Forbidden</td><td>isForbidden()</td><td>HTTP 응답코드가 403 Forbidden검증</td></tr><tr><td>404 Not Found</td><td>isNotFound()</td><td>HTTP 응답코드가 404 Not Found 검증</td></tr><tr><td>4**</td><td>is4xxClientError()</td><td>HTTP 응답코드가 4** 검증</td></tr><tr><td>500 Internal Server Error</td><td>isInternalServerError()</td><td>HTTP 응답코드가 500 InternalServerError 검증</td></tr><tr><td>5**</td><td>is5xxClientError()</td><td>HTTP 응답코드가 5** 검증</td></tr></tbody></table><p> </p><p> </p><p> </p><p> </p><p>참고</p><ul><li><p>도서 : 스프링 부트 3 백엔드 개발자 되기 - 자바 편</p></li><li><p><a href=https://mangkyu.tistory.com/143>https://mangkyu.tistory.com/143</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/spring/>Spring</a></li><li><a href=http://localhost:1313/tags/tdd/>TDD</a></li><li><a href=http://localhost:1313/tags/junit/>JUnit</a></li><li><a href=http://localhost:1313/tags/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/>단위테스트</a></li><li><a href=http://localhost:1313/tags/assertj/>Assertj</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>