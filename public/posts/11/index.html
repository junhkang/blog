<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] BRIN 인덱스의 원리 및 특징 | Jun Kang's Blog</title>
<meta name=keywords content="brin,Index,PostgreSQL"><meta name=description content='
 

1. BRIN 인덱스란?

[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Block range index의 약자
[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)
[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)'><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/11/><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/11/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://junhkang.com/posts/11/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] BRIN 인덱스의 원리 및 특징"><meta property="og:description" content=' 1. BRIN 인덱스란? [▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Block range index의 약자
[▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값) [▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-18T19:03:08+00:00"><meta property="article:modified_time" content="2023-09-18T19:03:08+00:00"><meta property="article:tag" content="Brin"><meta property="article:tag" content="Index"><meta property="article:tag" content="PostgreSQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] BRIN 인덱스의 원리 및 특징"><meta name=twitter:description content='
 

1. BRIN 인덱스란?

[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Block range index의 약자
[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)
[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] BRIN 인덱스의 원리 및 특징","item":"https://junhkang.com/posts/11/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] BRIN 인덱스의 원리 및 특징","name":"[PostgreSQL] BRIN 인덱스의 원리 및 특징","description":" 1. BRIN 인덱스란? [▪]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026rdquo;}[ ]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026quot;}Block range index의 약자\n[▪]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026rdquo;}[ ]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026quot;}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값) [▪]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026rdquo;}[ ]{style=\u0026ldquo;font-family: AppleSDGothicNeo-Regular, \u0026lsquo;Malgun Gothic\u0026rsquo;, \u0026lsquo;맑은 고딕\u0026rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;\u0026quot;}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)\n","keywords":["brin","Index","PostgreSQL"],"articleBody":" 1. BRIN 인덱스란? [▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;\"}Block range index의 약자\n[▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;\"}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값) [▪]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;”}[ ]{style=“font-family: AppleSDGothicNeo-Regular, ‘Malgun Gothic’, ‘맑은 고딕’, dotum, 돋움, sans-serif; color: #666666; text-align: left;\"}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)\n[[[Block range는 테이블 내에서 근접한 물리주소를 가진 page 그룹을 의미한다. ]{style=“text-align: left;\"}각 Block range 에 대해 일부 요약 정보가 인덱스로 저장된다. 예를 들어 상점의 판매 주문을 저장하는 테이블에는 각 주문이 배치된 날짜 열이 있을 수 있으며 대부분의 경우 이전 주문시점에 맞게 순차적으로 주문정보가 들어갈 것이고, ZIP 코드 열을 저장하는 테이블에는 도시에 대한 모든 코드가 자연스럽게 그룹화되어 있을 것이다. ]{style=“background-color: #fdfdfd; text-align: start;”}[]{style=“background-color: #fdfdfd; text-align: start;”}]{style=“color: #000000;”}\n[BRIN 인덱스는 정기적인 비트맵 인덱스 검색을 통해 쿼리를 결과를 확인하고, 인덱스에 의해 저장된 요약 정보가 쿼리 조건과 일치하면, 범위 내 모든 페이지의 모든 튜플을 반환한다. 쿼리 실행기는 반환된 튜플을 다시 검사하고, 쿼리 조건과 일치하지 않는 튜플을 폐기한다. (결과가 일치하지 않아 폐기된 인덱스는 손실된다.) BRIN 인덱스는 매우 작기 때문에 인덱스를 스캔하면 순차적 스캔에 비해 오버헤드가 거의 발생하지 않지만, 일치하는 튜플이 없는 것으로 알려진 테이블의 많은 부분을 스캔하는 것은 피할 수 있다.]{style=“background-color: #fdfdfd; color: #000000; text-align: start;”}\n[BRIN 인덱스가 저장할 특정 데이터는 인덱스의 각 열에 대해 선택된 연산자 유형에 따라서도 달라진다. 예를 들어 선형 정렬 순서를 갖는 데이터 유형은 각 블록 범위 내에서 최솟값과 최댓값을 저장할 수 있고, 기하학적 유형은 블록 범위의 모든 객체에 대한 경계 정보를 저장할 수도 있다.]{style=“color: #000000;”}\n2. BRIN 인덱스 관리 Brin 인덱스가 생성될시, 모든 존재하는 heap page를 스캔하고, 각 block range마다 요약 인덱스 tuple을 생성하고 마지막으로 불완전한 block range를 생성한다. 새로운 page가 데이터로 가득 차면, 이미 요약된 block range가 새 튜플의 데이터로 요약 정보가 업데이트된다. 마지막 요약 범위에 속하지 않는 새 페이지가 생성되면 요약 튜플을 자동으로 획득하지 않고 나중에 요약 실행이 호출될 때까지 해당 튜플은 요약되지 않은 상태로 남아 해당 범위에 대한 초기 요약을 만든다. 이 과정을 직접 실행하는 몇 가지 방법이 있다. 테이블을 auto vacuum 하여 요약되지 않은 page ranges를 요약한다. 만약 auto summarize 파라미터가 on이라면(default 아님), autovacuum이 데이터베이스에 실행될 때마다 summarization이 실행된다.\n--요약 안된 전체 범위 요약 brin_summarize_new_values(regclass) --주어진 page만 요약 (요약안됐을 경우에만) brin_summarize_range(regclass, bigint) 을 통해 ranges에 summarization 실행 가능하다. 반대로 [ 다음을]{style=“background-color: #f8f9fa; color: #000000; text-align: left;”}[ 통해 요약을 해제 하는것도 가능하다. ]{style=“color: #333333; text-align: start;”}\nbrin_desummarize_range(regclass, bigint) tuple의 기존값이 변경되어 인덱스 tuple이 더 이상 좋은 결과를 나타내지 못할 때 유용하다. 3. BRIN VS B-TREE ▪ BRIN 인덱스는 B-TREE 인덱스보다 쿼리 성능이 좋다.\n[▪ ]{style=“color: #666666; text-align: left;\"}BRIN 인덱스는, B-TREE에서 사용하는 용량의 1%만 사용한다. ▪ BRIN이 특정 블록 범위만 다루다 보니, 검색 범위를 이탈할 경우 해당하는 블록 범위 전체를 검사한다. ▪ BRIN은 lossy index이므로, 데이터의 hash 값을 저장하는 컬럼에 BRIN을 써도 데이터가 포함된 블록을 정확히 반환하지 못한다. [▪ ]{style=“color: #666666; text-align: left;\"}인덱스 생성 속도가 BRIN이 더 빠르다.[ ]{style=“color: #666666; text-align: left;”}\n**4. 연산자 ** 이름 인덱싱 된 데이터 유형 인덱싱 가능한 연산자 abstime_minmax_ops abstime \u003c \u003c= = \u003e= \u003e int8_minmax_ops bigint \u003c \u003c= = \u003e= \u003e bit_minmax_ops bit \u003c \u003c= = \u003e= \u003e varbit_minmax_ops bit varying \u003c \u003c= = \u003e= \u003e box_inclusion_ops box \u003c\u003c \u0026\u003c \u0026\u0026 \u0026\u003e \u003e\u003e ~= @\u003e \u003c@ \u0026\u003c| \u003c\u003c| |\u003e\u003e |\u0026\u003e bytea_minmax_ops bytea \u003c \u003c= = \u003e= \u003e bpchar_minmax_ops character \u003c \u003c= = \u003e= \u003e char_minmax_ops “char” \u003c \u003c= = \u003e= \u003e date_minmax_ops date \u003c \u003c= = \u003e= \u003e float8_minmax_ops double precision \u003c \u003c= = \u003e= \u003e inet_minmax_ops inet \u003c \u003c= = \u003e= \u003e network_inclusion_ops inet \u0026\u0026 \u003e\u003e= \u003c\u003c= = \u003e\u003e \u003c\u003c int4_minmax_ops integer \u003c \u003c= = \u003e= \u003e interval_minmax_ops interval \u003c \u003c= = \u003e= \u003e macaddr_minmax_ops macaddr \u003c \u003c= = \u003e= \u003e name_minmax_ops name \u003c \u003c= = \u003e= \u003e numeric_minmax_ops numeric \u003c \u003c= = \u003e= \u003e pg_lsn_minmax_ops pg_lsn \u003c \u003c= = \u003e= \u003e oid_minmax_ops oid \u003c \u003c= = \u003e= \u003e range_inclusion_ops any range type \u003c\u003c \u0026\u003c \u0026\u0026 \u0026\u003e \u003e\u003e @\u003e \u003c@ -|- = \u003c \u003c= = \u003e \u003e= float4_minmax_ops real \u003c \u003c= = \u003e= \u003e reltime_minmax_ops reltime \u003c \u003c= = \u003e= \u003e int2_minmax_ops smallint \u003c \u003c= = \u003e= \u003e text_minmax_ops text \u003c \u003c= = \u003e= \u003e tid_minmax_ops tid \u003c \u003c= = \u003e= \u003e timestamp_minmax_ops timestamp without time zone \u003c \u003c= = \u003e= \u003e timestamptz_minmax_ops timestamp with time zone \u003c \u003c= = \u003e= \u003e time_minmax_ops time without time zone \u003c \u003c= = \u003e= \u003e timetz_minmax_ops time with time zone \u003c \u003c= = \u003e= \u003e uuid_minmax_ops uuid \u003c \u003c= = \u003e= \u003e\n참고 :\nhttps://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/\nhttps://www.postgresql.kr/docs/13/brin-intro.htmlhttps://www.postgresql.kr/docs/13/brin-intro.html\n\\\n","wordCount":"775","inLanguage":"en","datePublished":"2023-09-18T19:03:08Z","dateModified":"2023-09-18T19:03:08Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/11/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] BRIN 인덱스의 원리 및 특징</h1><div class=post-meta><span title='2023-09-18 19:03:08 +0000 UTC'>September 18, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p> </p><img src=0><h2 id=brin-인덱스란 ke-size=size26><strong>1. BRIN 인덱스란?</strong><a hidden class=anchor aria-hidden=true href=#brin-인덱스란>#</a></h2><blockquote><p>[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Block range index의 약자<br>[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)
[▪]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&rdquo;}[ ]{style=&ldquo;font-family: AppleSDGothicNeo-Regular, &lsquo;Malgun Gothic&rsquo;, &lsquo;맑은 고딕&rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;"}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)</p></blockquote><p>[[[Block range는 테이블 내에서 근접한 물리주소를 가진 page 그룹을 의미한다. ]{style=&ldquo;text-align: left;"}각 Block range 에 대해 일부 요약 정보가 인덱스로 저장된다. 예를 들어 상점의 판매 주문을 저장하는 테이블에는 각 주문이 배치된 날짜 열이 있을 수 있으며 대부분의 경우 이전 주문시점에 맞게 순차적으로 주문정보가 들어갈 것이고, ZIP 코드 열을 저장하는 테이블에는 도시에 대한 모든 코드가 자연스럽게 그룹화되어 있을 것이다. ]{style=&ldquo;background-color: #fdfdfd; text-align: start;&rdquo;}[]{style=&ldquo;background-color: #fdfdfd; text-align: start;&rdquo;}]{style=&ldquo;color: #000000;&rdquo;}</p><p>[BRIN 인덱스는 정기적인 비트맵 인덱스 검색을 통해 쿼리를 결과를 확인하고, 인덱스에 의해 저장된 요약 정보가 쿼리 조건과 일치하면, 범위 내 모든 페이지의 모든 튜플을 반환한다. 쿼리 실행기는 반환된 튜플을 다시 검사하고, 쿼리 조건과 일치하지 않는 튜플을 폐기한다. (결과가 일치하지 않아 폐기된 인덱스는 손실된다.) BRIN 인덱스는 매우 작기 때문에 인덱스를 스캔하면 순차적 스캔에 비해 오버헤드가 거의 발생하지 않지만, 일치하는 튜플이 없는 것으로 알려진 테이블의 많은 부분을 스캔하는 것은 피할 수 있다.]{style=&ldquo;background-color: #fdfdfd; color: #000000; text-align: start;&rdquo;}</p><p>[BRIN 인덱스가 저장할 특정 데이터는 인덱스의 각 열에 대해 선택된 연산자 유형에 따라서도 달라진다. 예를 들어 선형 정렬 순서를 갖는 데이터 유형은 각 블록 범위 내에서 최솟값과 최댓값을 저장할 수 있고, 기하학적 유형은 블록 범위의 모든 객체에 대한 경계 정보를 저장할 수도 있다.]{style=&ldquo;color: #000000;&rdquo;}</p><h2 id=brin-인덱스-관리 ke-size=size26><strong>2. BRIN 인덱스 관리</strong><a hidden class=anchor aria-hidden=true href=#brin-인덱스-관리>#</a></h2><p>Brin 인덱스가 생성될시, 모든 존재하는 heap page를 스캔하고, 각 block range마다 요약 인덱스 tuple을 생성하고 마지막으로 불완전한 block range를 생성한다. 새로운 page가 데이터로 가득 차면, 이미 요약된 block range가 새 튜플의 데이터로 요약 정보가 업데이트된다. 마지막 요약 범위에 속하지 않는 새 페이지가 생성되면 요약 튜플을 자동으로 획득하지 않고 나중에 요약 실행이 호출될 때까지 해당 튜플은 요약되지 않은 상태로 남아 해당 범위에 대한 초기 요약을 만든다. 이 과정을 직접 실행하는 몇 가지 방법이 있다. 테이블을 auto vacuum 하여 요약되지 않은 page ranges를 요약한다. 만약 auto summarize 파라미터가 on이라면(default 아님), autovacuum이 데이터베이스에 실행될 때마다 summarization이 실행된다.</p><pre tabindex=0><code>--요약 안된 전체 범위 요약
brin_summarize_new_values(regclass) 

--주어진 page만 요약 (요약안됐을 경우에만)
brin_summarize_range(regclass, bigint)
</code></pre><p> </p><p>을 통해 ranges에 summarization 실행 가능하다. 반대로 [ 다음을]{style=&ldquo;background-color: #f8f9fa; color: #000000; text-align: left;&rdquo;}[ 통해 요약을 해제 하는것도 가능하다. ]{style=&ldquo;color: #333333; text-align: start;&rdquo;}</p><pre tabindex=0><code> brin_desummarize_range(regclass, bigint)
</code></pre><p> </p><p>tuple의 기존값이 변경되어 인덱스 tuple이 더 이상 좋은 결과를 나타내지 못할 때 유용하다.
 </p><h2 id=3-brin-vs-b-tree><strong>3. BRIN VS B-TREE</strong><a hidden class=anchor aria-hidden=true href=#3-brin-vs-b-tree>#</a></h2><blockquote><p>▪ BRIN 인덱스는 B-TREE 인덱스보다 쿼리 성능이 좋다.<br>[▪ ]{style=&ldquo;color: #666666; text-align: left;"}BRIN 인덱스는, B-TREE에서 사용하는 용량의 1%만 사용한다.
▪ BRIN이 특정 블록 범위만 다루다 보니, 검색 범위를 이탈할 경우 해당하는 블록 범위 전체를 검사한다.
▪ BRIN은 lossy index이므로, 데이터의 hash 값을 저장하는 컬럼에 BRIN을 써도 데이터가 포함된 블록을 정확히 반환하지 못한다.
[▪ ]{style=&ldquo;color: #666666; text-align: left;"}인덱스 생성 속도가 BRIN이 더 빠르다.[
]{style=&ldquo;color: #666666; text-align: left;&rdquo;}</p></blockquote><h2 id=연산자 style=background-color:#fff;color:#555;text-align:start ke-size=size26>**4. 연산자 **<a hidden class=anchor aria-hidden=true href=#연산자>#</a></h2><hr><p>이름 인덱싱 된 데이터 유형 인덱싱 가능한 연산자
abstime_minmax_ops abstime &lt; &lt;= = >= >
int8_minmax_ops bigint &lt; &lt;= = >= >
bit_minmax_ops bit &lt; &lt;= = >= >
varbit_minmax_ops bit varying &lt; &lt;= = >= >
box_inclusion_ops box &lt;&lt; &&lt; && &> >> ~= @> &lt;@ &&lt;| &lt;&lt;| |>> |&>
bytea_minmax_ops bytea &lt; &lt;= = >= >
bpchar_minmax_ops character &lt; &lt;= = >= >
char_minmax_ops &ldquo;char&rdquo; &lt; &lt;= = >= >
date_minmax_ops date &lt; &lt;= = >= >
float8_minmax_ops double precision &lt; &lt;= = >= >
inet_minmax_ops inet &lt; &lt;= = >= >
network_inclusion_ops inet && >>= &lt;&lt;= = >> &lt;&lt;
int4_minmax_ops integer &lt; &lt;= = >= >
interval_minmax_ops interval &lt; &lt;= = >= >
macaddr_minmax_ops macaddr &lt; &lt;= = >= >
name_minmax_ops name &lt; &lt;= = >= >
numeric_minmax_ops numeric &lt; &lt;= = >= >
pg_lsn_minmax_ops pg_lsn &lt; &lt;= = >= >
oid_minmax_ops oid &lt; &lt;= = >= >
range_inclusion_ops any range type &lt;&lt; &&lt; && &> >> @> &lt;@ -|- = &lt; &lt;= = > >=
float4_minmax_ops real &lt; &lt;= = >= >
reltime_minmax_ops reltime &lt; &lt;= = >= >
int2_minmax_ops smallint &lt; &lt;= = >= >
text_minmax_ops text &lt; &lt;= = >= >
tid_minmax_ops tid &lt; &lt;= = >= >
timestamp_minmax_ops timestamp without time zone &lt; &lt;= = >= >
timestamptz_minmax_ops timestamp with time zone &lt; &lt;= = >= >
time_minmax_ops time without time zone &lt; &lt;= = >= >
timetz_minmax_ops time with time zone &lt; &lt;= = >= >
uuid_minmax_ops uuid &lt; &lt;= = >= ></p><hr><p> </p><p>참고 :</p><p><a href=https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/>https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/</a></p><p><a href=https://www.postgresql.kr/docs/13/brin-intro.htmlhttps://www.postgresql.kr/docs/13/brin-intro.html>https://www.postgresql.kr/docs/13/brin-intro.htmlhttps://www.postgresql.kr/docs/13/brin-intro.html</a></p><p>\</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/brin/>Brin</a></li><li><a href=https://junhkang.com/tags/index/>Index</a></li><li><a href=https://junhkang.com/tags/postgresql/>PostgreSQL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>