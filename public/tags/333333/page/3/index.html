<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>333333 | Jun Kang&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Jun Kang">
<link rel="canonical" href="http://localhost:1313/tags/333333/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/333333/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/333333/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Jun Kang&#39;s Blog (Alt + H)">Jun Kang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    333333
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[네트워크] TCP/IP의 개념
    </h2>
  </header>
  <div class="entry-content">
    <p>패킷 전송방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서대로 받는 것을 보장하지 않지만, TCP는 IP 위에서 동작하는 프로토콜로 데이터의 전달을 보증하고 보낸 순서대로 받게 해 준다. IP가 패킷 간의 관계를 이해하지 못하고 목적지를 찾아가는 데만 집중한다면 TCP는 Endpoint 간 통신할 준비가 되어있는지, 데이터 전송이 제대로 되었는지, 데이터가 변질되지 않은지, 데이터 유실은 없는지 등을 점검한다.즉 IP주소 체계를 따르고 IP Routing을 통해 목적지에 도달하여 TCP의 특성을 활용하여 송신자와 수신자의 논리적 연결을 생성, 신뢰성 유지한다.(HTTP, FTP, SFTP 등 TCP를 기반으로 하는 많은 어플리케이션 프로토콜들이 IP 위에서 동작하기 때문에 묶어서 TCP/IP로 부르기도 한다.)### 1-1. IP (Internet Protocol)클라이언트와 서버는 각 IP주소를 가지고 지정한 IP 주소에 패킷 단위로 데이터를 전송한다. 전송된 데이터는 인터넷 망 내의 노드를 거쳐 목적지에 도달하게 된다. IP프로토콜만으로 통신할 경우 한계가 존재한다.&gt; 비연결성 - IP프로토콜만으로는 클라이언트에서 서버가 패킷을 받을 수 있는 상황인지 확인할 수 없다. 따라서 수신 서버가 없거나 서비스가 불가능하더라도 패킷을 전송한다.비신뢰성 - 인터넷 망 내 노드에 문제가 생기는 경우 패킷이 손실 없이 안전하게 도달하지 못할 수 있거나 전송순서가 바뀔 수 있다.또한, 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이라면 IP 만으로는 구분할 수 없다.### 1-2. TCP (Transmission Control Protocol)IP의 핵심 프로토콜 중 하나로 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간의 일련의 옥텟을데이터 패킷에 일련의 번호를 부여함으로써 안정적으로 순서대로 에러 없이 교환하도록 한다. Transport Layer에 위치하며 네트워크 정보전달을 통제하는 프로토콜이다. Endpoint 간 연결을 생성하고 데이터를 얼마나 보냈는지, 받았는지가 TCP 헤더에 담겨있으며 흐름제어, 혼잡제어에 관여할 수 있는 다양한 요소들이 포함되어 있다. TCP는 3-way handshake를 통해 통신을 시도한다.2023.10.18 - [네트워크] - [네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념1. 소켓(Socket)이란 소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로junhkang.tistory.comTCP의 특징신뢰성보장 &amp; 흐름제어분할된 데이터의 고유번호를 통해 수신자가 어디까지 받았는지 지속적으로 확인가능하며, 이를 통해 데이터의 손실 없이 전송이 가능하다. TCP Header 내의 window size를 사용해 한번에 송/수신할 수 있는 데이터 양을 정하며 수신 측에서 받을 수 있는 양을 기준으로 Window size가 정해진다(3-hand shake 간 결정됨). 송수신시 계속 확인 응답을 받기에 신뢰도가 높지만, 데이터 용량이 증가하여 수신속도가 떨어진다.혼잡제어Endpoint 간의 흐름제어 외에 네트워크망의 혼잡제어를 한다. 송신자는 연결초기에 데이터 송출량을 낮게 잡고 보내면서 수신자의 수신을 확인하며 데이터 송출량을 조금씩 늘린다. 이를 통해 네트워크에 가장 적합한 데이터 송출량을 확인할 수 있으며 이를 ‘Slow Start’라고 한다.멀티캐스트 불가능1:1 전송방식으로 유니캐스트성이다. 단일 송신자와 단일수신자 간의 경로 연결이 설정된다.#네트워크 #iP #TCP/IP #tcp
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [네트워크] TCP/IP의 개념" href="http://localhost:1313/posts/31/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?
    </h2>
  </header>
  <div class="entry-content">
    <p>CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다.### 스레드의 종류스레드는 지원 주체에 따라 2가지로 나눌 수 있다.User Threads- 유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드- 라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.- 동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.- 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)- 스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다Kernel Threads- 커널 스레드는 커널이 지원하는 스레드- 커널 스레드를 사용하면 안정적이지만 유저모드에서 커널모드로 계속 바꿔줘야 하기에 성능이 저하된다.- 반대로 유저 스레드를 사용하면 안정성은 떨어지지만 성능이 저하되지는 않는다.- 스레드가 시스템 호출 등으로 중단되어도 다른 스레드를 중단시키지 않고 계속 실행시킨다.### Thread Group (스레드 그룹)Thread Group (스레드 그룹)이란 관련 있는 스레드를 그룹으로 묶어 다루는 장치이다. 쓰레드 그룹은 다른 스레드그룹에 포함될 수 있으며, 트리형태로 연결된다. 스레드는는 자신이 포함된 스레드 그룹이나 하위 그룹에는 접근가능 하지만, 다른 그룹에는 접근할 수 없다.### Deamon Thread(데몬 스레드)- 다른 일반 스레드의 작업을 돕는 보조 쓰레드- 일반 스레드가 모두 종료되면 자동으로 종료- 일정시간마도 자동수행되는 저장/ 화면 갱신등에 사용### Thread Pools스레드를 요청할 때마다 매번 새로 생성하고, 수행하고, 지우고 반복하면 성능저하로 이어진다.그래서 미리 스레드 풀에 여러 개의 스레드를 만들어두고 요청이 오면 스레드풀에서 스레드를 할당해 주는 방법을 사용한다.## 2. 멀티스레드란?한 번에 하나의 작업만 수행하면 싱글 스레드, 하나의 프로세스가 둘 이상의 스레드가 동시에 작업을 수행하면 멀티스레드라 한다.멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다.### 멀티스레드의 장점두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.프로세스사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생 (스레드 전환 시에도 일어나지만 속도가 더 빠르다)응답성 : 대화형 프로그램을 멀티스레드화 하면 일부 스레드가 중단되거나 긴 작업을 수행하더라도 다른 스레드가 별도의 작업을 할 수 있어 응답성이 좋다.자원공유 : 프로세스 내의 자원과 메모리를 공유함으로 시스템 자원의 낭비가 적다. 또한 같은 주소 공간 내에 여러 개의 활동성 스레드를 가질 수 있다는 장점이 있다.경제성 : 메모리와 자원할당은 많인 비용이 소모된다. 스레드는 프로세스 내 자원을 공유하기에 스레드생성과 Context Switching을 하는 것이 효율적이다.멀티프로세서 활용 : 각각의 스레드가 다른 프로세스에서 병렬로 수행 가능하다. 단일 쓰레드 프로세스는 CPU가 많아도 1개의 CPU에서만 실행되지만, 다중 스레드화 하면 다중 CPU에서 병렬성이 증간된다.프로세스와 비교두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.스레드, 프로세스 사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생하나 스레드의 Context Switching의 속도가 더 빨라서 효율적이다.### 멀티스레드의 단점- 캐시, 변환 생인 버퍼(TLB) 등의 하드웨어 리소스를 공유할 때 서로 간섭할 수 있다.- Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하되어 단순 계산은 싱글 스레드 보다 실행시간이 개선되지 않고 오히려 지연될 수 있다.- 멀티 쓰레딩의 하드웨어 지원을 위해 애플리케이션, 운영체제 모두에 최적화 변경이 필요하다.- 각 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다.예를 들어 스레드 1, 스레드 2로 다음 작업을 수행할 때,&gt; - 공유되는 변수 i의 값을 레지스터에 저장- 레지스터의 값을 1 증가- 변수 i에 그 값을 저장쓰레드동작i스레드 1의 레지스터스레드 2의 레지스터스레드 1i의 값을 레지스터에 저장00스레드 1레지스터 값을 1 증가01스레드 1i에 값 저장11스레드 2i의 값을 레지스터에 저장111스레드 2레지스터 값을 1 증가112스레드 2i에 값 저장212스레드 순서가 정상적으로 처리된다면 다음과 같이 최종적으로 i = 2가 되지만, 스레드 실행 순서가 달라진다면스레드동작i스레드 1의 레지스터스레드 2의 레지스터스레드 1i의 값을 레지스터에 저장00스레드 2i의 값을 레지스터에 저장000스레드 1레지스터 값을 1 증가010스레드 2레지스터 값을 1 증가011스레드 1i에 값 저장111스레드 2i에 값 저장111i = 1 이 되기에 의도와 다른 수행이 일어나며, 스레드의 실행조건에 따라 다른 결과를 나타내기에 원인 파악이 힘들다.이러한 문제를 경쟁조건이라고 하며 세마포어 같은 방법으로 공유데이터에 접근하는 스레드의 개수를 한 개 이하로 유지하여 해결할 수 있다.### Context Switching컴퓨터가 동시에 처리할 수 있는 작업 수는 CPU의 코어 수량과 같다. CPU 코어보다 많은 스레드가 동시에 실행되면 각 코어별로 정해진 시간만큼 번갈아가며 작업을 수행한다. 각 스레드가 서로 번갈아가며 교체될때 쓰레드간 현재까지의 작업상태나 다음 작업에 필요한 데이터를 저장하고 읽는 작업을 하는데 이를 Context Switching라고 한다. Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하된다. 그래서 많은 양의 단순계산은 싱글 쓰레드로 처리하는 것이 효율적인 경우가 있기에 쓰레드 수가 많은 게 항상 고성능은 아니다.### Multithreaded Server Architecture서버와 클라이언트 사이에도 멀티 스레드를 구현한다. 클라이언트가 새로운 요청을 하면 서버는 스레드를 새로 생성해서 요청을 수행한다. 프로세스 보다 쓰레드를 생성하는 것이 더 빠르기 때문에 효율적이다.### Multicore Programming동시성(Concurrency)동시성은 싱글 프로세스에서 사용되는 방식으로 프로세서가 여러 개의 스레드를 번갈아가면 수행하며 동시에 실행되는 것처럼 보이게 한다.병렬성(Parallelism)병렬성은 멀티코어 방식에서 사용되는 방식으로 여러 개의 코어가 스레드를 동시에 수행한다.## 3. Multithreading Models유저 스레드와 커널 쓰레드 관계를 정의하는 방식이다.### Many-to-One Model- 하나의 커널 스레드에 여러 개의 유저 스레드 연결- 사용자 수준에서의 스레드 관리- 주로 커널 스레드를 지원하지 않는 시스템에서 사용- 한 번에 하나의 유저스레드만 커널에 접근가능- 멀티코어 시스템에서 병렬적인 수행이 불가능### One-to-One Model- 하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델- Many-to-One방식에서 시스템 호출 시 다른 스레드들이 중단되는 문제를 해결할 수 있어 동시성 향상- 멀티프로세서 시스템에서는 동시에 여러 개 쓰레드 수행 가능- 유저 스레드 증가분만큼 커널 스레드가 증가.- 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기에 성능저하 발생가능### Many-to-Many Model- 여러 유저스레드가 더 적거나 같은 수의 커널 스레드에 대응하는 모델- 운영체제에 충분한 수의 커널 스레드를 생성가능- 커널 스레드의 구체적 개수는 프로그램이나 작동기기에 따라 상이- 멀티프로세서 프로그램에서는 싱글프로세서 보다 더 많은 커널 스레드가 생성- 커널이 사용자 스레드와 커널 스레드의 매핑을 적절하게 조절### Two-level Model- Many-to-Many 모델과 유사- 특정 유저 스레드를 위한 커널 스레드를 따로 제공하는 모델- 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리 가능참고https://ko.wikipedia.org/wiki/스레드_(컴퓨팅)https://rebro.kr/174http://www.tcpschool.com/java/java_thread_multihttps://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9#OS #운영체제 #스레드 #멀티스레드
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?" href="http://localhost:1313/posts/28/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라
    </h2>
  </header>
  <div class="entry-content">
    <p>클라이언트가 클래스 인스턴스를 얻는 방법에는 전통적인 방법 중 하나는 public이다. 하지만 정적 팩터리 메서드(static factory method)도 꼭 알아두어야한다.## 1. 정적 팩터리 메서드란?그렇다면 정적 팩터리 메서드는 무엇일까? 간단히 말해 객체 생성의 역할을 하는 클래스 메서드로, static 메서드를 통해 인스턴스를 생성하는 것이다. 다음은 java의 기본 Boolean 클래스 내 정적 팩토리 메서드의 간단한 예시이다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.02.29.png)이팩티브 자바에서는 정적 팩토리 메서드를 사용할 시의 5가지 장점과 2가지 단점에 대해 서술하고 있어 자세한 비교를 통해 하나하나 알아보려 한다.## 2. 정적 팩토리 메서드 (static factory method)의 장점#### 2-1. 이름을 가질 수 있다.인스턴스를 대표하는 생성자가 명확하거나, 반환될 객체에 대한 설명이 필요하지 않을 경우에는 크게 느껴지지 않는 차이일 수 있지만, 이름을 가질 수 있어 반환될 객체의 특징을 설명할 수 있다는 것은 굉장한 장점이다. 이펙티브 자바에서는 BigInteger와 BigInteger.probablePrime의 차이를 예로 들고 있다. 먼저 BigInteger(int, int, Random)의 예제를 보면![](/images/posts/53/스크린샷 2024-01-17 오후 5.09.35.png)설명을 읽어보면 “지정된 bitLength의 소수일 가능성이 있는 임의의 BigInteger를 생성한다.“는 것을 이해할 수 있지만, 그전에는 명확한 반환될 객체의 특성을 알 수 없다. 또한, 하나의 시그니처로는 생성자를 한 개만 만들 수 있기에 제약이 있다. 예를 들어 동일한 BigInteger(int, int, Random) 생성자는 다른 의미를 가질 수 없다. BigInteger(int, Random, int)와 같이 순서를 바꾸거나, 추가하는 식으로 피해 갈 수는 있지만, 당연히 좋지 않은 방식이다. (추가될 때마다 클래스 설명 문서를 확인해야 하고, 호출하는데 실수가 있을 수 있다.)그에 비해 자바 4에서 추가된 BigInteger.probablePrime을 보면![](/images/posts/53/스크린샷 2024-01-17 오후 5.16.10.png)“값이 소수인 BigInteger를 반환한다&#34;라는 의미를 이름만으로도 충분히 유추가 가능하다. 따라서 한 클래스에 시그니처 생성자가 여러 개 필요하다면 생성자를 정적 팩토리 메서드로 바꾸고 그 특징을 설명할 수 있는 이름을 붙이자#### 2-2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.개인적으로는 큰 시스템일수록 가장 큰 장점이 되지 않을까 싶은데, 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성된 인스턴스를 캐싱하여 활용하기에 불필요한 객체 생성 방지한다. 위의 예제에서 본 Boolean.valueOf(boolean)을 보면 객체를 아얘 생성하지 않는다. 그래서 (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 올려준다. 또한 이는 인스턴스의 생명 주기를 철저히 컨트롤 가능하는 뜻이며, 클래스를 싱글턴 혹은 인스턴스화 불가 상태로 만들 수도 있다.#### 2-3. 반환 타입의 하위 타입 객체를 반환할 수 있다.반환할 객체의 클래스를 자유롭게 선택할 수 있는 유연성을 제공한다. 응용하면 API를 만들 때 구현 클래스를 공개하지 않고 객체를 반환할 수 있어 API를 작게 유지가 가능하다. 자바 8 전에는 인터페이스에 정적 메서드 선언 불가하였고, 이름이 “Type&#34;인 인터페이스를 반환하는 정적 메서드가 필요하면 “Types&#34;라는 (인스턴스화 불가인) 동반 클래스를 만들어 그 안에 정의하는 것이 관례였다.예를 들어 자바 컬렉션 프레임워크는 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 붙인 총 45개의 유틸리티 구현체를 제공하고, 이 구현체 대부분을 단 하나의 인스턴스화 불가 클래스인 java.util.Collections에서 정적 팩토리 메서드를 통해 얻도록 한다.다음은 java.util.Collections의 동기화 기능의 정적 팩터리 메서드이다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.31.56.png)![](/images/posts/53/스크린샷 2024-01-17 오후 5.30.15.png)컬렉션 프레임워크 자체는 이 45개 클래스를 공개하지 않기 때문에 API 외견을 훨씬 작게 만들 수 있었다. API가 작아진 것은 물론 개념적인 무게, 프로그래머가 API를 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮아졌다.(프로그래머는 명시한 인터페이스 대로 동작하는 객체를 얻을 것임을 알기에 굳이 문서를 찾거나 실제 구현클래스가 무엇인지 알아보지 않아도 된다. 나아가 정적 팩토리 메서드를 사용하는 클라이언트는 얻은 객체를 인터페이스만으로 다루게 된다.)추가로, 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기에 인스턴스화 불가 동반 클래스를 둘 이유가 별로 없다. 동반 클래스에 두었던 public 정적 멤버들 상당수를 그냥 인터페이스 자체에 두면 된다. (자바 9에서는 private 정적 메서드까지 허용하지만 정적 필드와 정적 멤버 클래스는 여전히 public이어야만 함)#### 2-4. 입력 매개 변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.반환 타입의 하위타입이기만 하면 어떤 클래스의 객체를 반환하던 상관없다. 심지어 다음 릴리즈에서는 또 다른 클래스의 객체를 반환해도 된다. 즉 하위 타입이기만 하면 API 변경 시 또 다른 클래스의 객체를 반환해도 된다. 예를들어 EnumSet 클래스는 public 생성자 없이 정적 팩토리만 제공하는데 openjdk에서는 원소의 수에 따라 두 가지 하위 클래스중 하나의 인스턴스를 반환한다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.39.08.png)반환 값을 보면 원소가 64개 이하면 long변수 하나로 원소를 관리하는 RegularEnumSet을, 65개 이상이면 long 배열로 관리하는 JumboEnumSet을 반환한다. 만약 원소가 적을 때 RegularEnumSet을 사용할 이점이 없어진다면 다음 릴리즈에는 이를 삭제해도 클라이언트는 아무런 변화도 알 수 없을 것이다. 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없다. EnumSet의 하위 클래스이기만 하면 된다.#### 2-5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.메서드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않는다는 것은 서비스 제공자 프레임워크 (service provider framework)의 근간이다. 이 뜻을 자세히 살펴보면서비스 제공자 프레임워크의 제공자(provider)는 서비스의 구현체이고, 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리해준다.서비스 제공자 프레임워크의 핵심 프레임워크 3가지는&gt; 서비스 인터페이스 (service interface) - 구현체의 동작을 정의한다.제공자 등록 API(provider registration API) - 제공자가 구현체를 등록할 때 사용서비스 접근 API(service access API) - 클라이언트가 서비스의 인스턴스를 얻을 때 사용 (클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건 명시 가능, 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환)이 중 서비스 접근 API가 바로 앞서 말한 서비스 제공자 프레임워크의 근간이라고 한 유연한 정적팩토리의 실체이다. (추가로 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명하는 서비스 제공자 인터페이스 (Service Provider Interface)가 쓰이기도 한다.)익숙한 프레임워크이자 대표적인 서비스 제공자 프레임워크인 JDBC(java database connectivity)를 살펴보면 이해가 쉽다.&gt; Connection - 서비스 인터페이스 역할DriverManager.registerDriver - 제공자 등록 API 역할DriverManager.getConnection - 서비스 접근 API 역할Driver - 서비스 제공자 인터페이스 역할(자바 6부터는 java.util.ServiceLoader라는 범용 서비스 제공자 프레임워크가 제공되어 프레임워크를 직접 만들 필요가 거의 없지만, JDBC는 6전에 등장하였기에 ServiceLoader를 사용하지 않는다.)## 3. 정적 팩토리 메서드 (static factory method)의 단점#### 3-1. 상속을 하려면 public, protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스 생성이 불가하다.컬렉션 프레임워크의 유틸리티 구현 클래스들은 상속이 불가하다는 말이다. 상속보다 컴포지션을 사용하도록 유도하고 불변타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점일 수도 있다.#### 3-2. 정적 팩토리 메서드는 프로그래머가 찾기 힘들다.생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다. API 문서를 규격화하고, 메서드 명도 널리 알려진 규약에 따라 짓는 것으로 어느 정도 해결해야 한다.#### 3-3. 정적 팩토리 메서드에서 흔히 사용하는 네이밍- From : 매개변수를 하나 받아서 해당 타입 인스턴스를 반환하는 형변환 메서드 ex)Date d = Date.from(instant);- Of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드Set faceCards =EnumSet.of(JACK,QUEEN, KING);- valueOf : from과 of의 더 자세한 버전BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);- Instance / getInstance : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않음StackWalker Luke = StackWalker.getInstance(options);- Create/newInstance : instance/getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장 ex)Object newArray = Array.newInstance(classObject, arrayLen);- getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리 매서드를 정의할 때 사용. “Type&#34;은 팩터리 메서드가 반환할 객체의 타입FileStore fs = Files.getFileStore(path)- newType : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용. “Type&#34;은 팩터리 메서드가 반환할 객체의 타입BufferReader br = Files.newFufferedReader(path)- type : getType과 newType의 간결한 버전List litany = Collections.list(legacyLitany);## 4. 정리적정 팩터리 매서드와 public 생성자는 각각 쓰임새가 있으니 장담점을 이해하고 써야 한다. 정적 팩토리를 사용할 경우가 유리한 경우가 더 많기에 무작정 public 생성자를 썼다면 다시 한번 생각해 보자책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능하다.https://github.com/junhkang/effective-java-summaryGitHub - junhkang/effective-java-summary: A personal summary of Effective Java (by Joshua Bloch)A personal summary of Effective Java (by Joshua Bloch) - GitHub - junhkang/effective-java-summary: A personal summary of Effective Java (by Joshua Bloch)github.com#Effective Java #정적 팩토리 메서드
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라" href="http://localhost:1313/posts/53/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    </h2>
  </header>
  <div class="entry-content">
    <p>한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.2023.11.06 - [Spring] - [Spring] IoC(제어의 역전) &amp; DI(의존성 주입)의 개념[Spring] IoC(제어의 역전) &amp; DI(의존성 주입)의 개념1. IoC (Inversion of Control) 제어의 역전 IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한junhkang.tistory.com이펙티브 자바 책에서는 “맞춤법 검사기 (SpellChecker)” 클레스에서 “사전 (Dictionary)” 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.## 2. 예제### 2-1. 정적 유틸리티정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.public class SpellCheckerStatic {private static final Lexicon dictionary = new Lexicon();private SpellCheckerStatic() {} // 객체 생성 방지public static boolean isValid(String word) {return dictionary.isValid(word);}public static List suggestions(String typo) {return dictionary.suggestions(typo);}}### 2-2. 싱글턴싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.public class SpellCheckerSingleton {private static final Lexicon dictionary = new Lexicon();private SpellCheckerSingleton() {}public static SpellCheckerSingleton INSTANCE = new SpellCheckerSingleton();public static boolean isValid(String word) {return dictionary.isValid(word);}public static List suggestions(String typo) {return dictionary.suggestions(typo);}}두방식 모두 dictionary 자원을 한 가지만 사용한다. 그렇기에 다양한 언어의 사전을 사용하거나 특수 언어용 사전을 별도로 쓰는 경우의 확장성을 생각해 보면 좋지 않다. 일반적으로 클래스에서 여러 자원을 참조할 경우 흔히 발생하는 상황이다. 위의 Spellchecker클래스에서 여러 사전을 유연하게 쓸 수 있도록 수정하려면 대표적으로 다음 두 가지 방식이 있을 것이다.1. 단순히 dictionary 필드에서 final 제한을 제거하고 다른 사전으로 교체하는 메서드를 추가한다.어색하고, 오류를 내기 쉬우며 멀티 스레드 환경에서 사용 불가능하다. 사용하는 자원 객체에 따라 이후 동작이 달라지는 클래스에서는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.2. 인스턴스를 생성하는 시점에 필요에 맞는 dictionary를 넘겨주는 방식으로 변경한다. (의존객체 주입)의존 객체 주입의 한 형태로 맞춤법 검사기를 생성할 때 의존 객체인 사전을 주입해주면 된다. SpellChecker 클래스가 여러 인스턴스를 지원해야 하며 클라이언트가 원하는 자원을 사용해야 한다.### 2-3. 의존객체 주입의존객체 주입은 유연성과 테스트 용이성을 높여준다.public class SpellCheckerInjection {private static final Lexicon dictionary;public SpellCheckerInjection(Lexicon disctionary) {this.dictionary = Objects.requireNonNull(disctionary);}public static boolean isValid(String word) {return dictionary.isValid(word);}public static List suggestions(String typo) {return dictionary.suggestions(typo);}}예시에서는 dictionary라는 하나의 자원만 사용하지만 여러 개의 자원을 참조하는 경우가 대부분이다. 그런 상황에서 의존객체 주입을 사용했을 때의 장점을 생각해 보자.- 몇 개의 자원에 의존하던 관계없이 실행된다.- 불변성을 보장하여 여러 클라이언트가 의존객체들을 안심하고 공유할 수 있다.- 테스트가 용이하다.이에 변형으로 생성자에 자원 팩토리 자체를 넘겨주는 방식도 별도로 소개하고 있다. 호출될 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.(팩토리 메서드 패턴) 책에서는 자바 8의 Supplier 인터페이스를 팩토리를 표현한 완벽한 예제로 소개하고 있다.![](/images/posts/76/스크린샷 2024-03-25 오후 2.00.21.png)팩토리의 타입 매개변수를 제한하며, 이 방식을 사용해 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩토리를 넘길 수 있다. 다음 코드는 클라이언트가 제공한 팩토리가 생성한 타일들로 구성된 Mosaic를 만드는 샘플 메서드이다.Mosaic create(Supplier&lt;&gt; extends Tile&gt; tileFactory) {Tile tile = tileFactory.get();return new Mosaic(tile);}## 3. 정리클래스가 내부에서 하나 이상의 자원에 의존할 때 클래스 동작에 영향을 주는 자원이 있다면 싱글턴, 정적 유틸 클래스는 사용하지 않는 것이 좋고 이 자원들을 클래스가 새로 생성해서도 안된다. 필요한 자원들을 생성자에 넘겨주는 생성자 주입 방식으로 구현하면 클래스의 유연성, 재사용성, 테스트 용이성을 매우 개선해 준다.책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능하다.https://github.com/junhkang/effective-java-summaryGitHub - junhkang/effective-java-summary: Effective Java (by Joshua Bloch) 내용 및 예제 정리Effective Java (by Joshua Bloch) 내용 및 예제 정리. Contribute to junhkang/effective-java-summary development by creating an account on GitHub.github.com#이펙티브자바
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라" href="http://localhost:1313/posts/76/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/tags/333333/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Jun Kang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
