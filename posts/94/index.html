<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표 | Jun Kang's Blog</title>
<meta name=keywords content="PostgreSQL,쿼리성능,PG_STAT_STATEMENTS"><meta name=description content="
1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?
RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 
pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 

쿼리빈도
쿼리 실행시간
쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)
쿼리 텍스트 저장

2. 설치 
설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다."><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/posts/94/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/94/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/94/"><meta property="og:title" content="[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표 | Jun Kang's Blog"><meta property="og:description" content="
1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?
RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 
pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 

쿼리빈도
쿼리 실행시간
쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)
쿼리 텍스트 저장

2. 설치 
설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다."><meta property="og:image" content="http://localhost:1313/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="http://localhost:1313/posts/94/"><meta property="twitter:title" content="[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표 | Jun Kang's Blog"><meta property="twitter:description" content="
1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?
RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 
pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 

쿼리빈도
쿼리 실행시간
쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)
쿼리 텍스트 저장

2. 설치 
설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다."><meta property="twitter:image" content="http://localhost:1313/images/og_img.jpg"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9413249746505723" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="http://localhost:1313/posts/94/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표"><meta property="og:description" content=" 1. RDS에서의 쿼리 성능 분석, pg_stat_statements란? RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자. pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 쿼리빈도 쿼리 실행시간 쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등) 쿼리 텍스트 저장 2. 설치 설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-14T17:49:46+00:00"><meta property="article:modified_time" content="2024-08-14T17:49:46+00:00"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="쿼리성능"><meta property="article:tag" content="PG_STAT_STATEMENTS"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표"><meta name=twitter:description content="
1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?
RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 
pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 

쿼리빈도
쿼리 실행시간
쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)
쿼리 텍스트 저장

2. 설치 
설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표","item":"http://localhost:1313/posts/94/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표","name":"[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표","description":" 1. RDS에서의 쿼리 성능 분석, pg_stat_statements란? RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자. pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 쿼리빈도 쿼리 실행시간 쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등) 쿼리 텍스트 저장 2. 설치 설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다.\n","keywords":["PostgreSQL","쿼리성능","PG_STAT_STATEMENTS"],"articleBody":" 1. RDS에서의 쿼리 성능 분석, pg_stat_statements란? RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자. pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. 쿼리빈도 쿼리 실행시간 쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등) 쿼리 텍스트 저장 2. 설치 설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다.\nCREATE EXTENSION pg_stat_statements; 만약 설치가 안된다면, RDS 데이터베이스가 할당된 파라미터 그룹에서 \"shared_preload_libraries\" 파라미터에 \"pg_stat_statements\"추가되어 있는지 확인하자\n3. 상세 지표 SELECT * FROM pg_stat_statements; 컬럼 설명 userid 쿼리 실행 사용자ID, 어떤 쿼리를 어떤 사용자가 사용했는지 추적 가능 dbid 쿼리 실행 데이터베이스 ID, 동일 인스턴스 에 여러 데이터베이스를 사용하는 경우, 데이터베이스 실행 추적 가능 queryid 쿼리 텍스트의 해쉬 값, 동일 쿼리 식별 가능 (쿼리가 변형되어도 ID를 통해 유사쿼리 그룹화 가능) query 실제 실행된 쿼리 텍스트 calls 쿼리가 실행된 횟수 total_time 쿼리의 총 실행 시간 (ms), 모든 호출의 실행시간 합산으로 쿼리의 전체 리소스 소비량을 알 수 있음 min_time 쿼리 실행 최소 시간 (ms) max_time 쿼리 실행 최대 시간 (ms) mean_time 쿼리 실행 평균 시간 (ms) stddev_time 쿼리 실행 표준편차 ( 실행 시간의 변동성 판단 가능, 변동성이 크다면 특정 상황에서 성능문제 발생할 수 있음 ) rows 쿼리 실행 결과 행 수 shared_blks_read 공유 메모리에서 블록이 히트된 횟수, 메모리에서 쿼리가 얼마나 효율적으로 데이터를 읽었는지 파악 가능 shared_blks_dirtied 디스크에서 읽은 공유 블록의 수 (값이 높으면 디스크 I/O가 많이 발생) shard_blks_written 쿼리 실행중 수정된 공유블록의 수, (데이터 변경이 얼마나 발생했는지 확인 가능) local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written shared_ 헤더의 값들과 유사, 공유 메모리가 아닌 로컬 메모리에서의 지표 temp_blks_read 쿼리 실행 중 임시 테이블에서 읽은 블록 수 (높으면 쿼리가 임시 테이블을 많이 사용중) temp_blks_written 쿼리 실행 중 임시 테이블에 기록된 블록 수 (높다면 쿼리 최적화 필요) blk_read_time 블록을 읽는데 총 걸린 시간 (ms) 쿼리가 I/O작업에서 얼마나 많은 시간을 소비했는지 확인 가능 blk_write_time 블록을 쓰는데 걸린 총 시간 (ms) 데이터 쓰기 작업이 성능에 얼마나 영향을 미쳤는지 파악 가능 4. 어떤 지표를 봐야 하나? 4-1. 쿼리 실행시간 관련 쿼리의 실행시간은 절대적인 기준으로 판단할 수 없다. 빠를수록 좋겠지만 \"5초 이상은 무조건 튜닝이 필요한 쿼리\"라고 할 수 없다는 것이다. 시스템 자원, 쿼리 플래닝 및 테스트를 통해 파악된 해당 쿼리의 \"예상된\" 소모 시간 대비, 혹은 \"기존\" 소모시간 대비 분석을 해야 한다.\ntotal_time : 쿼리가 총 소모한 시간이 특정 시점부터 급격히 증가하면 확인 대상 mean_time : 쿼리의 평균 실행시간이 특정 시점부터 급격히 증가하면 확인 대상 max_time : 쿼리 최대 실행시간이 특정 상황에서 비정상적으로 오래 시간이 걸린다면 확인 대상 calls : 쿼리 호출 횟수로, 예상 수치보다 자주 호출되거나, 자주 호출되는데 실행시간이 길다면 확인 대상 4-2. I/O 문제 디스크 읽기/쓰기 작업이 과도하게 발생하는 쿼리는 성능 문제를 일으킬 수 있다.\nshared_blks_read, shared_blks_write : 디스크에 읽고, 쓰는 공유 블록의 수로, 급격히 증가한다면 읽기/쓰기 작업이 과도하게 발생한 것을 의미하므로 확인 대상 temp_blks_read : 임시 테이블에서 읽은 블록수가 크다면 임시테이블 사용이 빈번한 쿼리로 확인대상 blk_write_time : 블록을 쓰는데 소요된 총시간으로 특정 시점부터 급격히 증가한다면 확인 대상 4-3. 변동성 및 불안정성 쿼리의 성능이 일관적이지 않다면 특정 상황에만 문제가 될 수 있는 쿼리로, 성능 문제를 일으킬 수 있다.\nstddev_time : 쿼리 실행시간의 표준편차, 값이 크다면 성능이 일관되지 않다는 의미로 확인 대상 max_time : 쿼리 실행 최대시간, 특정 시점에서만 비정상적으로 실행시간 증가한다면 확인 대상 5. 주의사항 pg_stat_statements는 쿼리에 대한 추가 통계를 수집하기 때문에 성능에 약간의 오버헤드를 유발할 수 있다. 일반적으로 시스템 운영에 영향을 줄정도로 크지 않지만, 매우 트래픽이 많은 시스템은 주의가 필요하다. 통계가 계속 축적되기 때문에 설정에 따라 디스크 사용량이 증가할 수 있다. pg_stat_statements_max (기본값 : 5000)을 적절히 조정하여 관리해야 한다. pg_stat_statements를 통해 실행되는 쿼리문 자체가 저장되기에 민감 데이터가 노출되지 않도록 관리해야 한다. (사용자 권한을 제한 권고) 누적된 집계 외에 특정 시점 이후의 성능을 분석하고 싶다면 통계 초기화해야 한다. SELECT pg_stat_statements_reset(); 6. 정리 pg_stat_statements의 지표를 통해 쿼리 성능 분석이 가능하다. 특히 쿼리 실행시간, 디스크 I/O, 변동성의 관점에서 쿼리 분석을 시작하는 것이 좋다. 트래픽이 아주 많은 시스템의 경우 익스텐션 설치만으로도 오버헤드가 발생할 수 있으니 충분한 테스트가 필요하다. 모든 지표들이 객관적인 정답을 가지고 있진 않기에, 현재 운영 중인 서비스의 시스템 자원, 쿼리 플래닝 및 테스트를 통해 파악된 해당 쿼리의 \"예상된\" 소모 시간과 \"기존\" 소모시간을 지속적으로 관리하여 예외적인 상황들을 빠르게 인지하고 대응하는 것이 중요하다.\n","wordCount":"672","inLanguage":"en","datePublished":"2024-08-14T17:49:46Z","dateModified":"2024-08-14T17:49:46Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/94/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표</h1><div class=post-meta><span title='2024-08-14 17:49:46 +0000 UTC'>August 14, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=rds에서의-쿼리-성능-분석-pg_stat_statements란 ke-size=size26>1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?<a hidden class=anchor aria-hidden=true href=#rds에서의-쿼리-성능-분석-pg_stat_statements란>#</a></h2><p>RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 </p><p>pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. </p><ul><li>쿼리빈도</li><li>쿼리 실행시간</li><li>쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)</li><li>쿼리 텍스트 저장</li></ul><h2 id=설치 ke-size=size26>2. 설치 <a hidden class=anchor aria-hidden=true href=#설치>#</a></h2><p>설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다.</p><pre tabindex=0><code>CREATE EXTENSION pg_stat_statements;
</code></pre><p>만약 설치가 안된다면, RDS 데이터베이스가 할당된 파라미터 그룹에서 "shared_preload_libraries" 파라미터에 "pg_stat_statements"추가되어 있는지 확인하자</p><p><img loading=lazy src=/images/posts/94/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-14%20%EC%98%A4%ED%9B%84%204.44.51.png></p><h2 id=상세-지표 ke-size=size26>3. 상세 지표<a hidden class=anchor aria-hidden=true href=#상세-지표>#</a></h2><pre tabindex=0><code>SELECT * FROM pg_stat_statements;
</code></pre><table><thead><tr><th>컬럼</th><th>설명</th></tr></thead><tbody><tr><td>userid</td><td>쿼리 실행 사용자ID, 어떤 쿼리를 어떤 사용자가 사용했는지 추적 가능</td></tr><tr><td>dbid</td><td>쿼리 실행 데이터베이스 ID, 동일 인스턴스 에 여러 데이터베이스를 사용하는 경우, 데이터베이스 실행 추적 가능</td></tr><tr><td>queryid</td><td>쿼리 텍스트의 해쉬 값, 동일 쿼리 식별 가능 (쿼리가 변형되어도 ID를 통해 유사쿼리 그룹화 가능)</td></tr><tr><td>query</td><td>실제 실행된 쿼리 텍스트</td></tr><tr><td>calls</td><td>쿼리가 실행된 횟수</td></tr><tr><td>total_time</td><td>쿼리의 총 실행 시간 (ms), 모든 호출의 실행시간 합산으로 쿼리의 전체 리소스 소비량을 알 수 있음</td></tr><tr><td>min_time</td><td>쿼리 실행 최소 시간 (ms)</td></tr><tr><td>max_time</td><td>쿼리 실행 최대 시간 (ms)</td></tr><tr><td>mean_time</td><td>쿼리 실행 평균 시간 (ms)</td></tr><tr><td>stddev_time</td><td>쿼리 실행 표준편차 ( 실행 시간의 변동성 판단 가능, 변동성이 크다면 특정 상황에서 성능문제 발생할 수 있음 )</td></tr><tr><td>rows</td><td>쿼리 실행 결과 행 수</td></tr><tr><td>shared_blks_read</td><td>공유 메모리에서 블록이 히트된 횟수, 메모리에서 쿼리가 얼마나 효율적으로 데이터를 읽었는지 파악 가능</td></tr><tr><td>shared_blks_dirtied</td><td>디스크에서 읽은 공유 블록의 수 (값이 높으면 디스크 I/O가 많이 발생)</td></tr><tr><td>shard_blks_written</td><td>쿼리 실행중 수정된 공유블록의 수, (데이터 변경이 얼마나 발생했는지 확인 가능)</td></tr><tr><td>local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written</td><td>shared_ 헤더의 값들과 유사, 공유 메모리가 아닌 로컬 메모리에서의 지표</td></tr><tr><td>temp_blks_read</td><td>쿼리 실행 중 임시 테이블에서 읽은 블록 수 (높으면 쿼리가 임시 테이블을 많이 사용중)</td></tr><tr><td>temp_blks_written</td><td>쿼리 실행 중 임시 테이블에 기록된 블록 수 (높다면 쿼리 최적화 필요)</td></tr><tr><td>blk_read_time</td><td>블록을 읽는데 총 걸린 시간 (ms) 쿼리가 I/O작업에서 얼마나 많은 시간을 소비했는지 확인 가능</td></tr><tr><td>blk_write_time</td><td>블록을 쓰는데 걸린 총 시간 (ms) 데이터 쓰기 작업이 성능에 얼마나 영향을 미쳤는지 파악 가능</td></tr></tbody></table><h2 id=4-어떤-지표를-봐야-하나>4. 어떤 지표를 봐야 하나?<a hidden class=anchor aria-hidden=true href=#4-어떤-지표를-봐야-하나>#</a></h2><h3 id=쿼리-실행시간-관련 ke-size=size23>4-1. 쿼리 실행시간 관련<a hidden class=anchor aria-hidden=true href=#쿼리-실행시간-관련>#</a></h3><p>쿼리의 실행시간은 절대적인 기준으로 판단할 수 없다. 빠를수록 좋겠지만 "5초 이상은 무조건 튜닝이 필요한 쿼리"라고 할 수 없다는 것이다. 시스템 자원, 쿼리 플래닝 및 테스트를 통해 파악된 해당 쿼리의 "예상된" 소모 시간 대비, 혹은 "기존" 소모시간 대비 분석을 해야 한다.</p><ul><li><strong>total_time :</strong> 쿼리가 총 소모한 시간이 특정 시점부터 급격히 증가하면 확인 대상</li><li><strong>mean_time :</strong> 쿼리의 평균 실행시간이 특정 시점부터 급격히 증가하면 확인 대상</li><li><strong>max_time :</strong> 쿼리 최대 실행시간이 특정 상황에서 비정상적으로 오래 시간이 걸린다면 확인 대상</li><li><strong>calls :</strong> 쿼리 호출 횟수로, 예상 수치보다 자주 호출되거나, 자주 호출되는데 실행시간이 길다면 확인 대상</li></ul><h3 id=io-문제 ke-size=size23>4-2. I/O 문제<a hidden class=anchor aria-hidden=true href=#io-문제>#</a></h3><p>디스크 읽기/쓰기 작업이 과도하게 발생하는 쿼리는 성능 문제를 일으킬 수 있다.</p><ul><li><strong>shared_blks_read, shared_blks_write :</strong> 디스크에 읽고, 쓰는 공유 블록의 수로, 급격히 증가한다면 읽기/쓰기 작업이 과도하게 발생한 것을 의미하므로 확인 대상</li><li><strong>temp_blks_read :</strong> 임시 테이블에서 읽은 블록수가 크다면 임시테이블 사용이 빈번한 쿼리로 확인대상</li><li><strong>blk_write_time :</strong> 블록을 쓰는데 소요된 총시간으로 특정 시점부터 급격히 증가한다면 확인 대상</li></ul><h3 id=변동성-및-불안정성 ke-size=size23>4-3. 변동성 및 불안정성<a hidden class=anchor aria-hidden=true href=#변동성-및-불안정성>#</a></h3><p>쿼리의 성능이 일관적이지 않다면 특정 상황에만 문제가 될 수 있는 쿼리로, 성능 문제를 일으킬 수 있다.</p><ul><li><strong>stddev_time :</strong> 쿼리 실행시간의 표준편차, 값이 크다면 성능이 일관되지 않다는 의미로 확인 대상</li><li><strong>max_time :</strong> 쿼리 실행 최대시간, 특정 시점에서만 비정상적으로 실행시간 증가한다면 확인 대상</li></ul><h2 id=주의사항 ke-size=size26>5. 주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h2><ul><li>pg_stat_statements는 쿼리에 대한 추가 통계를 수집하기 때문에 성능에 약간의 오버헤드를 유발할 수 있다. 일반적으로 시스템 운영에 영향을 줄정도로 크지 않지만, 매우 트래픽이 많은 시스템은 주의가 필요하다.</li><li>통계가 계속 축적되기 때문에 설정에 따라 디스크 사용량이 증가할 수 있다. pg_stat_statements_max (기본값 : 5000)을 적절히 조정하여 관리해야 한다.</li><li>pg_stat_statements를 통해 실행되는 쿼리문 자체가 저장되기에 민감 데이터가 노출되지 않도록 관리해야 한다. (사용자 권한을 제한 권고)</li><li>누적된 집계 외에 특정 시점 이후의 성능을 분석하고 싶다면 통계 초기화해야 한다.</li></ul><pre tabindex=0><code>SELECT pg_stat_statements_reset();
</code></pre><h2 id=정리 ke-size=size26>6. 정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>pg_stat_statements의 지표를 통해 쿼리 성능 분석이 가능하다. 특히 쿼리 실행시간, 디스크 I/O, 변동성의 관점에서 쿼리 분석을 시작하는 것이 좋다. 트래픽이 아주 많은 시스템의 경우 익스텐션 설치만으로도 오버헤드가 발생할 수 있으니 충분한 테스트가 필요하다. 모든 지표들이 객관적인 정답을 가지고 있진 않기에, 현재 운영 중인 서비스의 시스템 자원, 쿼리 플래닝 및 테스트를 통해 파악된 해당 쿼리의 "예상된" 소모 시간과 "기존" 소모시간을 지속적으로 관리하여 예외적인 상황들을 빠르게 인지하고 대응하는 것이 중요하다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/postgresql/>PostgreSQL</a></li><li><a href=http://localhost:1313/tags/%EC%BF%BC%EB%A6%AC%EC%84%B1%EB%8A%A5/>쿼리성능</a></li><li><a href=http://localhost:1313/tags/pg_stat_statements/>PG_STAT_STATEMENTS</a></li></ul></footer><div class=giscus><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>