<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>0 | Jun Kang&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Jun Kang">
<link rel="canonical" href="http://localhost:1313/tags/0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/0/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Jun Kang&#39;s Blog (Alt + H)">Jun Kang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    0
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?
    </h2>
  </header>
  <div class="entry-content">
    <p>CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다.### 스레드의 종류스레드는 지원 주체에 따라 2가지로 나눌 수 있다.User Threads- 유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드- 라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.- 동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.- 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)- 스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다Kernel Threads- 커널 스레드는 커널이 지원하는 스레드- 커널 스레드를 사용하면 안정적이지만 유저모드에서 커널모드로 계속 바꿔줘야 하기에 성능이 저하된다.- 반대로 유저 스레드를 사용하면 안정성은 떨어지지만 성능이 저하되지는 않는다.- 스레드가 시스템 호출 등으로 중단되어도 다른 스레드를 중단시키지 않고 계속 실행시킨다.### Thread Group (스레드 그룹)Thread Group (스레드 그룹)이란 관련 있는 스레드를 그룹으로 묶어 다루는 장치이다. 쓰레드 그룹은 다른 스레드그룹에 포함될 수 있으며, 트리형태로 연결된다. 스레드는는 자신이 포함된 스레드 그룹이나 하위 그룹에는 접근가능 하지만, 다른 그룹에는 접근할 수 없다.### Deamon Thread(데몬 스레드)- 다른 일반 스레드의 작업을 돕는 보조 쓰레드- 일반 스레드가 모두 종료되면 자동으로 종료- 일정시간마도 자동수행되는 저장/ 화면 갱신등에 사용### Thread Pools스레드를 요청할 때마다 매번 새로 생성하고, 수행하고, 지우고 반복하면 성능저하로 이어진다.그래서 미리 스레드 풀에 여러 개의 스레드를 만들어두고 요청이 오면 스레드풀에서 스레드를 할당해 주는 방법을 사용한다.## 2. 멀티스레드란?한 번에 하나의 작업만 수행하면 싱글 스레드, 하나의 프로세스가 둘 이상의 스레드가 동시에 작업을 수행하면 멀티스레드라 한다.멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다.### 멀티스레드의 장점두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.프로세스사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생 (스레드 전환 시에도 일어나지만 속도가 더 빠르다)응답성 : 대화형 프로그램을 멀티스레드화 하면 일부 스레드가 중단되거나 긴 작업을 수행하더라도 다른 스레드가 별도의 작업을 할 수 있어 응답성이 좋다.자원공유 : 프로세스 내의 자원과 메모리를 공유함으로 시스템 자원의 낭비가 적다. 또한 같은 주소 공간 내에 여러 개의 활동성 스레드를 가질 수 있다는 장점이 있다.경제성 : 메모리와 자원할당은 많인 비용이 소모된다. 스레드는 프로세스 내 자원을 공유하기에 스레드생성과 Context Switching을 하는 것이 효율적이다.멀티프로세서 활용 : 각각의 스레드가 다른 프로세스에서 병렬로 수행 가능하다. 단일 쓰레드 프로세스는 CPU가 많아도 1개의 CPU에서만 실행되지만, 다중 스레드화 하면 다중 CPU에서 병렬성이 증간된다.프로세스와 비교두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.스레드, 프로세스 사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생하나 스레드의 Context Switching의 속도가 더 빨라서 효율적이다.### 멀티스레드의 단점- 캐시, 변환 생인 버퍼(TLB) 등의 하드웨어 리소스를 공유할 때 서로 간섭할 수 있다.- Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하되어 단순 계산은 싱글 스레드 보다 실행시간이 개선되지 않고 오히려 지연될 수 있다.- 멀티 쓰레딩의 하드웨어 지원을 위해 애플리케이션, 운영체제 모두에 최적화 변경이 필요하다.- 각 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다.예를 들어 스레드 1, 스레드 2로 다음 작업을 수행할 때,&gt; - 공유되는 변수 i의 값을 레지스터에 저장- 레지스터의 값을 1 증가- 변수 i에 그 값을 저장쓰레드동작i스레드 1의 레지스터스레드 2의 레지스터스레드 1i의 값을 레지스터에 저장00스레드 1레지스터 값을 1 증가01스레드 1i에 값 저장11스레드 2i의 값을 레지스터에 저장111스레드 2레지스터 값을 1 증가112스레드 2i에 값 저장212스레드 순서가 정상적으로 처리된다면 다음과 같이 최종적으로 i = 2가 되지만, 스레드 실행 순서가 달라진다면스레드동작i스레드 1의 레지스터스레드 2의 레지스터스레드 1i의 값을 레지스터에 저장00스레드 2i의 값을 레지스터에 저장000스레드 1레지스터 값을 1 증가010스레드 2레지스터 값을 1 증가011스레드 1i에 값 저장111스레드 2i에 값 저장111i = 1 이 되기에 의도와 다른 수행이 일어나며, 스레드의 실행조건에 따라 다른 결과를 나타내기에 원인 파악이 힘들다.이러한 문제를 경쟁조건이라고 하며 세마포어 같은 방법으로 공유데이터에 접근하는 스레드의 개수를 한 개 이하로 유지하여 해결할 수 있다.### Context Switching컴퓨터가 동시에 처리할 수 있는 작업 수는 CPU의 코어 수량과 같다. CPU 코어보다 많은 스레드가 동시에 실행되면 각 코어별로 정해진 시간만큼 번갈아가며 작업을 수행한다. 각 스레드가 서로 번갈아가며 교체될때 쓰레드간 현재까지의 작업상태나 다음 작업에 필요한 데이터를 저장하고 읽는 작업을 하는데 이를 Context Switching라고 한다. Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하된다. 그래서 많은 양의 단순계산은 싱글 쓰레드로 처리하는 것이 효율적인 경우가 있기에 쓰레드 수가 많은 게 항상 고성능은 아니다.### Multithreaded Server Architecture서버와 클라이언트 사이에도 멀티 스레드를 구현한다. 클라이언트가 새로운 요청을 하면 서버는 스레드를 새로 생성해서 요청을 수행한다. 프로세스 보다 쓰레드를 생성하는 것이 더 빠르기 때문에 효율적이다.### Multicore Programming동시성(Concurrency)동시성은 싱글 프로세스에서 사용되는 방식으로 프로세서가 여러 개의 스레드를 번갈아가면 수행하며 동시에 실행되는 것처럼 보이게 한다.병렬성(Parallelism)병렬성은 멀티코어 방식에서 사용되는 방식으로 여러 개의 코어가 스레드를 동시에 수행한다.## 3. Multithreading Models유저 스레드와 커널 쓰레드 관계를 정의하는 방식이다.### Many-to-One Model- 하나의 커널 스레드에 여러 개의 유저 스레드 연결- 사용자 수준에서의 스레드 관리- 주로 커널 스레드를 지원하지 않는 시스템에서 사용- 한 번에 하나의 유저스레드만 커널에 접근가능- 멀티코어 시스템에서 병렬적인 수행이 불가능### One-to-One Model- 하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델- Many-to-One방식에서 시스템 호출 시 다른 스레드들이 중단되는 문제를 해결할 수 있어 동시성 향상- 멀티프로세서 시스템에서는 동시에 여러 개 쓰레드 수행 가능- 유저 스레드 증가분만큼 커널 스레드가 증가.- 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기에 성능저하 발생가능### Many-to-Many Model- 여러 유저스레드가 더 적거나 같은 수의 커널 스레드에 대응하는 모델- 운영체제에 충분한 수의 커널 스레드를 생성가능- 커널 스레드의 구체적 개수는 프로그램이나 작동기기에 따라 상이- 멀티프로세서 프로그램에서는 싱글프로세서 보다 더 많은 커널 스레드가 생성- 커널이 사용자 스레드와 커널 스레드의 매핑을 적절하게 조절### Two-level Model- Many-to-Many 모델과 유사- 특정 유저 스레드를 위한 커널 스레드를 따로 제공하는 모델- 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리 가능참고https://ko.wikipedia.org/wiki/스레드_(컴퓨팅)https://rebro.kr/174http://www.tcpschool.com/java/java_thread_multihttps://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9#OS #운영체제 #스레드 #멀티스레드
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?" href="http://localhost:1313/posts/28/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라
    </h2>
  </header>
  <div class="entry-content">
    <p>클라이언트가 클래스 인스턴스를 얻는 방법에는 전통적인 방법 중 하나는 public이다. 하지만 정적 팩터리 메서드(static factory method)도 꼭 알아두어야한다.## 1. 정적 팩터리 메서드란?그렇다면 정적 팩터리 메서드는 무엇일까? 간단히 말해 객체 생성의 역할을 하는 클래스 메서드로, static 메서드를 통해 인스턴스를 생성하는 것이다. 다음은 java의 기본 Boolean 클래스 내 정적 팩토리 메서드의 간단한 예시이다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.02.29.png)이팩티브 자바에서는 정적 팩토리 메서드를 사용할 시의 5가지 장점과 2가지 단점에 대해 서술하고 있어 자세한 비교를 통해 하나하나 알아보려 한다.## 2. 정적 팩토리 메서드 (static factory method)의 장점#### 2-1. 이름을 가질 수 있다.인스턴스를 대표하는 생성자가 명확하거나, 반환될 객체에 대한 설명이 필요하지 않을 경우에는 크게 느껴지지 않는 차이일 수 있지만, 이름을 가질 수 있어 반환될 객체의 특징을 설명할 수 있다는 것은 굉장한 장점이다. 이펙티브 자바에서는 BigInteger와 BigInteger.probablePrime의 차이를 예로 들고 있다. 먼저 BigInteger(int, int, Random)의 예제를 보면![](/images/posts/53/스크린샷 2024-01-17 오후 5.09.35.png)설명을 읽어보면 “지정된 bitLength의 소수일 가능성이 있는 임의의 BigInteger를 생성한다.“는 것을 이해할 수 있지만, 그전에는 명확한 반환될 객체의 특성을 알 수 없다. 또한, 하나의 시그니처로는 생성자를 한 개만 만들 수 있기에 제약이 있다. 예를 들어 동일한 BigInteger(int, int, Random) 생성자는 다른 의미를 가질 수 없다. BigInteger(int, Random, int)와 같이 순서를 바꾸거나, 추가하는 식으로 피해 갈 수는 있지만, 당연히 좋지 않은 방식이다. (추가될 때마다 클래스 설명 문서를 확인해야 하고, 호출하는데 실수가 있을 수 있다.)그에 비해 자바 4에서 추가된 BigInteger.probablePrime을 보면![](/images/posts/53/스크린샷 2024-01-17 오후 5.16.10.png)“값이 소수인 BigInteger를 반환한다&#34;라는 의미를 이름만으로도 충분히 유추가 가능하다. 따라서 한 클래스에 시그니처 생성자가 여러 개 필요하다면 생성자를 정적 팩토리 메서드로 바꾸고 그 특징을 설명할 수 있는 이름을 붙이자#### 2-2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.개인적으로는 큰 시스템일수록 가장 큰 장점이 되지 않을까 싶은데, 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성된 인스턴스를 캐싱하여 활용하기에 불필요한 객체 생성 방지한다. 위의 예제에서 본 Boolean.valueOf(boolean)을 보면 객체를 아얘 생성하지 않는다. 그래서 (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 올려준다. 또한 이는 인스턴스의 생명 주기를 철저히 컨트롤 가능하는 뜻이며, 클래스를 싱글턴 혹은 인스턴스화 불가 상태로 만들 수도 있다.#### 2-3. 반환 타입의 하위 타입 객체를 반환할 수 있다.반환할 객체의 클래스를 자유롭게 선택할 수 있는 유연성을 제공한다. 응용하면 API를 만들 때 구현 클래스를 공개하지 않고 객체를 반환할 수 있어 API를 작게 유지가 가능하다. 자바 8 전에는 인터페이스에 정적 메서드 선언 불가하였고, 이름이 “Type&#34;인 인터페이스를 반환하는 정적 메서드가 필요하면 “Types&#34;라는 (인스턴스화 불가인) 동반 클래스를 만들어 그 안에 정의하는 것이 관례였다.예를 들어 자바 컬렉션 프레임워크는 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 붙인 총 45개의 유틸리티 구현체를 제공하고, 이 구현체 대부분을 단 하나의 인스턴스화 불가 클래스인 java.util.Collections에서 정적 팩토리 메서드를 통해 얻도록 한다.다음은 java.util.Collections의 동기화 기능의 정적 팩터리 메서드이다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.31.56.png)![](/images/posts/53/스크린샷 2024-01-17 오후 5.30.15.png)컬렉션 프레임워크 자체는 이 45개 클래스를 공개하지 않기 때문에 API 외견을 훨씬 작게 만들 수 있었다. API가 작아진 것은 물론 개념적인 무게, 프로그래머가 API를 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮아졌다.(프로그래머는 명시한 인터페이스 대로 동작하는 객체를 얻을 것임을 알기에 굳이 문서를 찾거나 실제 구현클래스가 무엇인지 알아보지 않아도 된다. 나아가 정적 팩토리 메서드를 사용하는 클라이언트는 얻은 객체를 인터페이스만으로 다루게 된다.)추가로, 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기에 인스턴스화 불가 동반 클래스를 둘 이유가 별로 없다. 동반 클래스에 두었던 public 정적 멤버들 상당수를 그냥 인터페이스 자체에 두면 된다. (자바 9에서는 private 정적 메서드까지 허용하지만 정적 필드와 정적 멤버 클래스는 여전히 public이어야만 함)#### 2-4. 입력 매개 변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.반환 타입의 하위타입이기만 하면 어떤 클래스의 객체를 반환하던 상관없다. 심지어 다음 릴리즈에서는 또 다른 클래스의 객체를 반환해도 된다. 즉 하위 타입이기만 하면 API 변경 시 또 다른 클래스의 객체를 반환해도 된다. 예를들어 EnumSet 클래스는 public 생성자 없이 정적 팩토리만 제공하는데 openjdk에서는 원소의 수에 따라 두 가지 하위 클래스중 하나의 인스턴스를 반환한다.![](/images/posts/53/스크린샷 2024-01-17 오후 5.39.08.png)반환 값을 보면 원소가 64개 이하면 long변수 하나로 원소를 관리하는 RegularEnumSet을, 65개 이상이면 long 배열로 관리하는 JumboEnumSet을 반환한다. 만약 원소가 적을 때 RegularEnumSet을 사용할 이점이 없어진다면 다음 릴리즈에는 이를 삭제해도 클라이언트는 아무런 변화도 알 수 없을 것이다. 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없다. EnumSet의 하위 클래스이기만 하면 된다.#### 2-5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.메서드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않는다는 것은 서비스 제공자 프레임워크 (service provider framework)의 근간이다. 이 뜻을 자세히 살펴보면서비스 제공자 프레임워크의 제공자(provider)는 서비스의 구현체이고, 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리해준다.서비스 제공자 프레임워크의 핵심 프레임워크 3가지는&gt; 서비스 인터페이스 (service interface) - 구현체의 동작을 정의한다.제공자 등록 API(provider registration API) - 제공자가 구현체를 등록할 때 사용서비스 접근 API(service access API) - 클라이언트가 서비스의 인스턴스를 얻을 때 사용 (클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건 명시 가능, 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환)이 중 서비스 접근 API가 바로 앞서 말한 서비스 제공자 프레임워크의 근간이라고 한 유연한 정적팩토리의 실체이다. (추가로 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명하는 서비스 제공자 인터페이스 (Service Provider Interface)가 쓰이기도 한다.)익숙한 프레임워크이자 대표적인 서비스 제공자 프레임워크인 JDBC(java database connectivity)를 살펴보면 이해가 쉽다.&gt; Connection - 서비스 인터페이스 역할DriverManager.registerDriver - 제공자 등록 API 역할DriverManager.getConnection - 서비스 접근 API 역할Driver - 서비스 제공자 인터페이스 역할(자바 6부터는 java.util.ServiceLoader라는 범용 서비스 제공자 프레임워크가 제공되어 프레임워크를 직접 만들 필요가 거의 없지만, JDBC는 6전에 등장하였기에 ServiceLoader를 사용하지 않는다.)## 3. 정적 팩토리 메서드 (static factory method)의 단점#### 3-1. 상속을 하려면 public, protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스 생성이 불가하다.컬렉션 프레임워크의 유틸리티 구현 클래스들은 상속이 불가하다는 말이다. 상속보다 컴포지션을 사용하도록 유도하고 불변타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점일 수도 있다.#### 3-2. 정적 팩토리 메서드는 프로그래머가 찾기 힘들다.생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다. API 문서를 규격화하고, 메서드 명도 널리 알려진 규약에 따라 짓는 것으로 어느 정도 해결해야 한다.#### 3-3. 정적 팩토리 메서드에서 흔히 사용하는 네이밍- From : 매개변수를 하나 받아서 해당 타입 인스턴스를 반환하는 형변환 메서드 ex)Date d = Date.from(instant);- Of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드Set faceCards =EnumSet.of(JACK,QUEEN, KING);- valueOf : from과 of의 더 자세한 버전BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);- Instance / getInstance : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않음StackWalker Luke = StackWalker.getInstance(options);- Create/newInstance : instance/getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장 ex)Object newArray = Array.newInstance(classObject, arrayLen);- getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리 매서드를 정의할 때 사용. “Type&#34;은 팩터리 메서드가 반환할 객체의 타입FileStore fs = Files.getFileStore(path)- newType : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 사용. “Type&#34;은 팩터리 메서드가 반환할 객체의 타입BufferReader br = Files.newFufferedReader(path)- type : getType과 newType의 간결한 버전List litany = Collections.list(legacyLitany);## 4. 정리적정 팩터리 매서드와 public 생성자는 각각 쓰임새가 있으니 장담점을 이해하고 써야 한다. 정적 팩토리를 사용할 경우가 유리한 경우가 더 많기에 무작정 public 생성자를 썼다면 다시 한번 생각해 보자책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능하다.https://github.com/junhkang/effective-java-summaryGitHub - junhkang/effective-java-summary: A personal summary of Effective Java (by Joshua Bloch)A personal summary of Effective Java (by Joshua Bloch) - GitHub - junhkang/effective-java-summary: A personal summary of Effective Java (by Joshua Bloch)github.com#Effective Java #정적 팩토리 메서드
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라" href="http://localhost:1313/posts/53/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[이펙티브 자바] 6. 불필요한 객체 생성을 피하라
    </h2>
  </header>
  <div class="entry-content">
    <p>똑같은 객체를 매번 새로 생성하는 것보다 하나를 생성 후 재사용하는 것이 훨씬 효율적이다. 특히 불변 객체는 언제든 재사용이 가능하다. 다음은 객체 생성 시 사용하면 안 되는 극단적인 예이다.String s = new String(&#34;bikini&#34;);보기만 해도 불편한 이 생성방식은 실행될 때마다 String 객체를 새로 생성한다. 이후에 기능적으로는 동일하게 사용되지만 큰 반복문이나 자주 호출되는 메서드 안에 있다면 쓸모없는 인스턴스가 여러 개 생성될 것이다. 개선된 객체 생성 방식을 확인해 보자.String s = &#34;bikini&#34;;이제 익숙한 String 객체 선언 방식이 되었다. 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스 사용하는 방식으로, 이 방식을 사용하면 같은 가상 머신 안에서 이와 같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다. 생성자 대신 정적 팩토리를 제공하는 불변 클래스에서도 정적 팩터리 메서드를 사용해서 불필요한 객체 생성을 피할 수 있다. 예를들어 Boolean 생성자 대신 Boolean.valueOf 팩토리 메서드를 사용하면 호출될 때마다 새로운 객체가 생성되는 것을 방지할 수 있다.## 2. 객체의 반복 시 캐싱 사용불변객체뿐 아니라 가변객체도 사용 중에 변경되지 않는다는 것을 알 수 있다면 재사용이 가능하다. 특히 생성 비용이 비싼 객체의 생성이 반복해서 필요할 경우 캐싱하여 사용 권장한다. 주어진 문자열이 유효한 로마 숫자인지를 확인하는 메서드 예제를 확인해 보자.static boolean isRomanNumeral(String s) {return s.matches(&#34;^(&gt;=.)M*(C[MD]|D?C{0,3})&#34;&#43; &#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&#34;);}기능상으로는 문제가 없는 String.matches를 사용한 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법 중 하나이다. 하지만 빈번한 호출이 있을 경우 성능 측면에서는 적합하지 않다. Pattern 인스턴스는 한번 사용하고 버려 저서 바로 GC대상이 되며 Pattern은 입력받은 정규표현식에 해당하는 유한 상태머신을 만들기 때문에 인스턴스 생성비용이 높다&gt; 유한 상태머신 [Finite State Machine (FS)] - 단순히 객체를 생성하는 것이 아니라 정규표현식에 일치하는 문자열을 찾기 위해 문자열을 상태에 따라 순차적으로 처리하는 논리 구조를 생성하기에 계산적으로 복잡하고 리소스를 많이 사용한다.성능을 개선하려면 Pattern 인스턴스를 클래스 초기화 과정에서 생성하여 캐싱하고 isRomanNumeral이 호출될 때마다 재사용하는 방법을 적용하면 된다.public class RomanNumerals {private static final Pattern ROMAN = Pattern.compile(&#34;^(&gt;=.)M*(C[MD]|D?C{0,3})&#34;&#43; &#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&#34;);static boolean isRomanNumeral(String s) {return ROMAN.matcher(s).matches();}}isRomanNumeral이 자주 호출될 때 성능개선 효과를 볼 수 있으며 ROMAN 필드를 final로 꺼내면서 의미가 더 명확해진다.8글자 기준으로 100,000번 반복 호출 시 거의 10배의 시간 효율을 확인할 수 있었다. (테스트 코드는 깃허브에서 확인 가능)![](/images/posts/77/스크린샷 2024-03-26 오후 5.23.04.png)반면 isRomanNumeral 방식의 클래스가 초기화된 후 이 메서드를 한 번도 호출하지 않으면 ROMAN필드는 쓸데없이 초기화된 것이다.이 경우 isRomanNumeral 메서드가 처음 호출될 때 필드를 초기화하는 지연 초기화로 불필요한 초기화를 없앨 순 있지만 성능개선에 비해 코드복잡도가 올라가서 추천하지 않은 방식이다.## 3. 불필요한 객체 생성 (keySet)객체가 불변이면 재사용하는 것이 항상 안전하지만, 불변인지 명확하지 않은 경우도 있다.Map 인터페이스의 keySet 메서드를 확인해 보자. Map인터페이스의 KeySet메서드는 Map 객체 안의 키를 Set뷰로 반환한다. 뷰를 통해 원본 ‘Map’에서 키를 제거하는 등, 반환된 Set인스턴스가 가변이더라도 모든 반환된 ‘Set’ 인스턴스는 동일한 ‘Map’ 인스턴스를 대변하기 때문에 기능적으로 정확히 일치한다. 반환된 ‘Set’을 통해 원본 ‘Map’의 키를 수정하거나 제거하면, 이변경 사항이 ‘Map’에 그대로 반영되어 참조하는 모든 뷰에 영향을 미치기에 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀌게 된다.따라서 ‘keySet’ 메서드를 여러 번 호출하여 여러 개의 ‘Set’ 뷰를 생성해도 기능상 문제는 없지만, 실질적으로 볼 수 있는 효과가 없다. 모든 ‘Set’ 뷰는 원본 ‘Map’을 참조하기에 여러뷰를 생성하는 것보다 단일 뷰를 재사용하는 것이 효율적이다.## 4. 오토박싱불필요한 객체를 만들어내는 또 다른 방식으로는 오토박싱이 있다. 자바에서 기본 타입과 박싱 된 기본타입을 섞어 쓸 때 자동으로 상호변환해 주는 기능이다. 다만 오토박싱은 기본 타입과 박싱 된 타입의 구분을 흐리게 해 주지만 아얘 구분을 없애는 것은 아니다.다음 예제는 모든 양의 정수의 총합을 구하는 메서드로 int는 충분히 크지 않아 long을 사용 중이다. 기능 상으로는 동일하지만 성능에서는 오토박싱을 사용함으로써 성능에서 큰 차이를 보이고 있다.### 3-1. 오토박싱 사용private static long sumLong() {Long sum = 0L;for (long i = 0; i &lt;= Integer.MAX_VALUE; i&#43;&#43;) {sum &#43;= i;}return sum;}### 3-2. 기본 타입사용private static long sumlong() {Long sum = 0L;for (long i = 0; i &lt;= Integer.MAX_VALUE; i&#43;&#43;) {sum &#43;= i;}return sum;}오토박싱을 사용한 예제를 보면 sum 변수를 Long으로 선언하여 불필요한 Long인스턴스가 2^31개나 생성된다. 실제로 두 메서드의 실행 시간을 비교해 보면 아주 큰 차이가 남을 확인할 수 있다.![](/images/posts/77/스크린샷 2024-03-26 오후 5.34.15.png)그래서 박싱 된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의해야 한다.## 4. 주의객체의 재사용이 효율적임을 강조했지만, 이펙티브 자바에서는 무조건적인 재사용이 효율적이지 않은 상황도 공유하고 있다. 프로그램의 명확성, 간결성, 기능을 위한 객체 생성은 일반적으로 좋지만 단순히 재사용성을 높이기 위해 객체 pool을 생성하는 것은 효율적이지 못하다. 데이터베이스 연결 같은 경우 생성 비용이 워낙 비싸기에 객체 pool(집합)을 생성하여 재사용하는 것이 효율적이지만, 일반적으로 자체 객체 풀은 객체를 풀에서 반환하는 추가로직이 필요하기에 코드의 명확성과 간결성이 떨어진다. 또한 사용하지 않는 개체들이 메모리에 남아있게 되어 메모리 사용량이 증가하게 된다. 또한 JVM GC가 상당히 최적화되어 있어 가벼운 객체를 효율적으로 관리하고 메모리를 회수하는데 최적화되어있기에, 가벼운 객체의 경우는 직접풀을 관리하는 것보다 새로 생성하는 것이 효율적일 수 있다.## 5. 정리- 불변이 보장된 객체의 경우 재사용을 항상 고려- 무거운 객체의 반복 생성 시 캐싱을 사용- 불필요한 객체 생성을 주의- 의도치 않은 오토박싱이 숨어들지 않도록 주의- 데이터베이스 연결 같이 생성 비용이 아주 큰 경우를 제외하고는 객체 풀을 사용하여 객체를 재사용하는 것보다 새로 생성하는 것이 효율적예제 및 성능 테스트 코드https://github.com/junhkang/effective-java-summary/tree/master/src/main/java/org/example/ch01/item06/codes#이펙티브자바
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [이펙티브 자바] 6. 불필요한 객체 생성을 피하라" href="http://localhost:1313/posts/77/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/tags/0/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Jun Kang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
