<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Java] 클래스 로딩 과정(Java Class Loading Process)이란? | Jun Kang's Blog</title>
<meta name=keywords content="Java,jvm,클래스"><meta name=description content="
1. 클래스 로딩 과정 (Java Class Loading Process) 이란?
자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 
자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.
2. 클래스 로더 3단계 과정
클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/35/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/35/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/35/"><meta property="og:title" content="[Java] 클래스 로딩 과정(Java Class Loading Process)이란? | Jun Kang's Blog"><meta property="og:description" content="
1. 클래스 로딩 과정 (Java Class Loading Process) 이란?
자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 
자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.
2. 클래스 로더 3단계 과정
클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/35/"><meta property="twitter:title" content="[Java] 클래스 로딩 과정(Java Class Loading Process)이란? | Jun Kang's Blog"><meta property="twitter:description" content="
1. 클래스 로딩 과정 (Java Class Loading Process) 이란?
자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 
자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.
2. 클래스 로더 3단계 과정
클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/35/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[Java] 클래스 로딩 과정(Java Class Loading Process)이란?"><meta property="og:description" content=" 1. 클래스 로딩 과정 (Java Class Loading Process) 이란? 자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다. 자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (‘java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.
2. 클래스 로더 3단계 과정 클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-23T17:30:32+00:00"><meta property="article:modified_time" content="2023-10-23T17:30:32+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Jvm"><meta property="article:tag" content="클래스"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Java] 클래스 로딩 과정(Java Class Loading Process)이란?"><meta name=twitter:description content="
1. 클래스 로딩 과정 (Java Class Loading Process) 이란?
자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 
자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.
2. 클래스 로더 3단계 과정
클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[Java] 클래스 로딩 과정(Java Class Loading Process)이란?","item":"https://junhkang.com/posts/35/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Java] 클래스 로딩 과정(Java Class Loading Process)이란?","name":"[Java] 클래스 로딩 과정(Java Class Loading Process)이란?","description":" 1. 클래스 로딩 과정 (Java Class Loading Process) 이란? 자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다. 자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (\u0026lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.\n2. 클래스 로더 3단계 과정 클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.\n","keywords":["Java","jvm","클래스"],"articleBody":" 1. 클래스 로딩 과정 (Java Class Loading Process) 이란? 자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다. 자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (‘java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.\n2. 클래스 로더 3단계 과정 클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.\n1. Loading\n클래스 파일을 읽어 바이너리 코드로 만들고 JVM의 메모리에 로드\n2. Linking\n클래스파일 사용을 위한 검증\n코드 내부의 러퍼런스를 연결\n3. Initialization\nStatic 변수들의 초기화 및 값 할당 3. 클래스 로드 시점 Loading 시점에서 JVM은 실행 시점에 모든 클래스를 메모리에 올려놓지 않고 필요한 클래스를 동적으로 메모리에 적재하여 효율적으로 관리한다.\n1. 인스턴스 생성시\n2. Static 변수 할당\n3. Static 메서드 호출\n4. Static final 상수 호출 (Static 변수, 메소드 호출과 다르게 Outer 클래스가 로딩되지 않는다, JVM의 Method Area에 Constant Pool에 따로 저장되어 관리되기 때문이다.)\n4. 클래스 로더의 종류 JVM을 실행했을 때 각 클래스 로더들은 자신이 호출할 수 있는 클래스들을 호출하여 JVM에 로딩하게 된다.\n1. 부트스트랩 클래스 로더\n$JAVA_HOME/jre/lib/rt.jar 에서 rt.jar에 있는 JVM을 실행시키기 위한 최소한의 핵심 클래스들을 로딩한다.\n-verbose:class JVM 옵션을 주고 자바 애플리케이션을 실행시키면 rt.jar에 있는 파일 로딩되는 것을 확인할 수 있다.\nJava 9 이후로는 rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 축소되어 정확하게 ClassLoader 내 최상위 클래스들만 로드한다.\n2. 확장 클래스로더\n$JAVA_HOME/jre/lib/ext 경로의 자바 확장 클래스들을 로딩한다\n3. 애플리케이션 클래스 로더\n자바 프로그램 실행 시$CLASSPATH에 설정된 경로의 클래스들을 로딩하게 된다. 이 시점에 개발된. class파일들이 로딩된다.\n클래스 로더들은 계층 구조를 가지도록 생성이 가능하고 각 부모 클래스 로더에서 자식클래스 로더를 가지는 형태로 클래스 로더를 만들 수 있다. 5. 클래스 로더의 작동원칙 위임 원칙 (Delegate Load Request)\nSystem Loader가 A라는 클래스를 로딩할 때 그 요청은 부모로더들로 거슬러 올라가 부트스트랩 로더에 도착한 후 그 밑으로 로딩 요청을 수행한다. 최상위 클래스 로더에 요청을 위임한 후, 파일을 찾으며 자식 클래스 로더에게 넘기며, 클래스로더 중 하나라도 파일 찾는 데 성공하면 자식 로더에게 넘겨준다. 가시성 제약 조건(Have Visibility Constraint)\n부모 로더에서 찾지 못한 클래스는 자식 로더로 찾지 못하고, 자식로더가 찾지 못한 것은 부모로더에 위임해서 찾을 수 있다 언로드 불가 (Cannot unload classes)\n클래스 로더로 로딩된 클래스들은 JVM 상에서 없앨 수 없다 유일성 원칙 (Uniqueness Principle)\n하위 클래스 로더가 상위 클래스 로더에서 로드한 클래스를 다시 로드하지 않아야 한다.\n상위 클래스로만 책임을 위임하기에 고유한 클래스를 보장할 수 있게 해주는 원칙이다. 참고\nhttps://co-no.tistory.com/103\nhttps://engkimbs.tistory.com/entry/Java-Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95Java-Class-Loading-Process\n클래스 로더 시스템의 3단계 동작 과정 / 출처 :https://dailyheumsi.tistory.com/196\n클래스 로더 동작순서 (출처 : https://engkimbs.tistory.com/)\n","wordCount":"411","inLanguage":"en","datePublished":"2023-10-23T17:30:32Z","dateModified":"2023-10-23T17:30:32Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/35/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[Java] 클래스 로딩 과정(Java Class Loading Process)이란?</h1><div class=post-meta><span title='2023-10-23 17:30:32 +0000 UTC'>October 23, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=클래스-로딩-과정-java-class-loading-process-이란 ke-size=size26><strong>1. 클래스 로딩 과정 (Java Class Loading Process) 이란?</strong><a hidden class=anchor aria-hidden=true href=#클래스-로딩-과정-java-class-loading-process-이란>#</a></h2><p>자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 </p><p>자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&lsquo;java.lang.ClassNotFoundException'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.</p><h2 id=클래스-로더-3단계-과정 ke-size=size26><strong>2. 클래스 로더 3단계 과정</strong><a hidden class=anchor aria-hidden=true href=#클래스-로더-3단계-과정>#</a></h2><p>클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.</p><p><img loading=lazy src=/images/posts/35/img.png></p><blockquote><p><strong>1. Loading</strong><br>클래스 파일을 읽어 바이너리 코드로 만들고 JVM의 메모리에 로드<br><strong>2. Linking</strong><br>클래스파일 사용을 위한 검증<br>코드 내부의 러퍼런스를 연결<br><strong>3. Initialization</strong><br>Static 변수들의 초기화 및 값 할당
 </p></blockquote><h2 id=3-클래스-로드-시점><strong>3. 클래스 로드 시점</strong><a hidden class=anchor aria-hidden=true href=#3-클래스-로드-시점>#</a></h2><p>Loading 시점에서 JVM은 실행 시점에 모든 클래스를 메모리에 올려놓지 않고 필요한 클래스를 동적으로 메모리에 적재하여 효율적으로 관리한다.</p><blockquote><p><strong>1. 인스턴스 생성시</strong><br><strong>2. Static 변수 할당</strong><br><strong>3. Static 메서드 호출</strong><br><strong>4. Static final 상수 호출</strong> 
(Static 변수, 메소드 호출과 다르게 Outer 클래스가 로딩되지 않는다, JVM의 Method Area에 Constant Pool에 따로 저장되어 관리되기 때문이다.)</p></blockquote><h2 id=클래스-로더의-종류 ke-size=size26><strong>4. 클래스 로더의 종류</strong><a hidden class=anchor aria-hidden=true href=#클래스-로더의-종류>#</a></h2><p><img loading=lazy src=/images/posts/35/img_1.png></p><p>JVM을 실행했을 때 각 클래스 로더들은 자신이 호출할 수 있는 클래스들을 호출하여 JVM에 로딩하게 된다.</p><blockquote><p><strong>1. 부트스트랩 클래스 로더</strong><br>$JAVA_HOME/jre/lib/rt.jar 에서 rt.jar에 있는 JVM을 실행시키기 위한 최소한의 핵심 클래스들을 로딩한다.<br>-verbose:class JVM 옵션을 주고 자바 애플리케이션을 실행시키면 rt.jar에 있는 파일 로딩되는 것을 확인할 수 있다.<br>Java 9 이후로는 rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 축소되어 정확하게 ClassLoader 내 최상위 클래스들만 로드한다.<br><strong>2. 확장 클래스로더</strong><br>$JAVA_HOME/jre/lib/ext 경로의 자바 확장 클래스들을 로딩한다<br><strong>3. 애플리케이션  클래스 로더</strong><br>자바 프로그램 실행 시$CLASSPATH에 설정된 경로의 클래스들을 로딩하게 된다. 이 시점에 개발된. class파일들이 로딩된다.</p></blockquote><p>클래스 로더들은 계층 구조를 가지도록 생성이 가능하고 각 부모 클래스 로더에서 자식클래스 로더를 가지는 형태로 클래스 로더를 만들 수 있다. </p><h2 id=클래스-로더의-작동원칙 ke-size=size26><strong>5. 클래스 로더의 작동원칙</strong><a hidden class=anchor aria-hidden=true href=#클래스-로더의-작동원칙>#</a></h2><p><strong>위임 원칙 (Delegate Load Request)</strong></p><p><img loading=lazy src=/images/posts/35/img_2.png></p><p>System Loader가 A라는 클래스를 로딩할 때 그 요청은 부모로더들로 거슬러 올라가 부트스트랩 로더에 도착한 후 그 밑으로 로딩 요청을 수행한다. 최상위 클래스 로더에 요청을 위임한 후, 파일을 찾으며 자식 클래스 로더에게 넘기며, 클래스로더 중 하나라도 파일 찾는 데 성공하면 자식 로더에게 넘겨준다.
 </p><p><strong>가시성 제약 조건(Have Visibility Constraint)</strong></p><p>부모 로더에서 찾지 못한 클래스는 자식 로더로 찾지 못하고, 자식로더가 찾지 못한 것은 부모로더에 위임해서 찾을 수 있다
 </p><p><strong>언로드 불가 (Cannot unload classes)</strong></p><p>클래스 로더로 로딩된 클래스들은 JVM 상에서 없앨 수 없다
 </p><p><strong>유일성 원칙 (Uniqueness Principle)</strong></p><p>하위 클래스 로더가 상위 클래스 로더에서 로드한 클래스를 다시 로드하지 않아야 한다.</p><p>상위 클래스로만 책임을 위임하기에 고유한 클래스를 보장할 수 있게 해주는 원칙이다.
 </p><p> </p><p> </p><p> </p><p>참고</p><ul><li><p><a href=https://co-no.tistory.com/103>https://co-no.tistory.com/103</a></p></li><li><p><a href=https://engkimbs.tistory.com/entry/Java-Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95Java-Class-Loading-Process>https://engkimbs.tistory.com/entry/Java-Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95Java-Class-Loading-Process</a></p></li><li><p>클래스 로더 시스템의 3단계 동작 과정 / 출처 :https://dailyheumsi.tistory.com/196</p></li><li><p>클래스 로더 동작순서 (출처 : <a href=https://engkimbs.tistory.com/>https://engkimbs.tistory.com/</a>)</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/java/>Java</a></li><li><a href=https://junhkang.com/tags/jvm/>Jvm</a></li><li><a href=https://junhkang.com/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/>클래스</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>