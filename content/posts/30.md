---
title: '[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념'
date: '2023-10-18 15:32:25'
categories: ['네트워크']
tags: ['네트워크', 'TCP/IP', 'tcp', '소켓', 'udp']
---

------------------------------------------------------------------------

## 1. 소켓(Socket)이란 {#소켓socket이란 ke-size="size26"}

소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.

소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.

![](/images/posts/30/img.png)

### **1-1. 서버 소켓** {#서버-소켓 ke-size="size23"}

클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다.

-   **socket() -** CLOSED 상태의 소켓 인스턴스 생성
-   **bind() -** ip, port 할당 (중복, 권한 문제로 주소& 포트 할당에 실패 할 수 있다.)
-   **listen() -** 서버 소켓 상태는 LISTEN 상태로 변경, 클라이언트 요청을 queue 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정
-   **accept() -** 각 클라이언트와 통신에 필요한 새로운 연결된 소켓을 획득, 클라이언트와 연결
-   **send() / recv() -** 데이터 송수신
-   **close() -** 소켓 닫기

listen상태에서 3-way handshaking을 거쳐 클라이언트, 소켓 연결이 ESTABLISH 상태가 되며, 그 후 accept()\~close()를 반복하며 데이터를 송수신한다.

### **1-2. 클라이언트 소켓** {#클라이언트-소켓 ke-size="size23"}

서버로 연결요청 및 데이터 전송을한다.

-   **sockect() -** CLOSED 상태의 소켓 인스턴스 생성
-   **connect() -** 소켓에 남는 local port 자동으로 할당(별도 ip, port를 바인딩도 가능) , 서버 ip, port로 연결 요청- 3-way handshake가 일어난다. (CLOSED-\>SYN_SENT-\>ESTABLISHED 상태로 변경)
-   **send() / recv() -** 데이터 송수신
-   **close() -** 소켓 닫기

서버 소켓이 연결은 맺은 후 \"새로운\" 소켓을 만든다고 표현한 이유는, accept() 할시 기존 listen()하고 있는 소켓은 데이터 송수신에 사용되지 않고, 클라이언트를 연결하기 위해 새로운 소켓을 획득하기 때문이다.

따라서 accept() 후에는 서버에 대기상태 (LISTENING) 상태의 소켓과 신규 연결된 소켓 (ESTABLISHED) 소켓 2개가 동시에 존재한다.

## 2. 3-way handshake {#way-handshake ke-size="size26"}

![](/images/posts/30/img_1.png)

서버가 클라이언트 요청을 기다리며 listen 상태일 때 3-way handshake를 통해 클라이언트-서버 사이 소켓이 연결된다.

-   SYN - synchronize의 약자로 처음 주고받을 데이터의 일련번호
-   ACK - Acknowledgement의 약자로 어떤 번호까지의 데이터를 정상수신 했는지에 대한 데이터

> **#1.** 클라이언트에서 서버 OS에 가상경로 오픈을 의뢰하며 SYN 패킷 전송. 클라이언트는 SYN을 보내고 응답을 기다리는 SYN_SENT 상태로 변경\
> **#2.** 서버는 listen 상태이기에 ACK+SYN 패킷 응답 발송, 클라이언트에서 다시 ACK로 응답하기를 기다리며 SYN_RECEIVED 상태로 변경\
> **#3.** 클라이언트도 다시 ACK패킷으로 응답하며 서버의 새로운 소켓이 생성되며 연결. 서버의 상태가 ESTABLISHED로 변경

#2이 완료되는 시점에 클라이언트소켓은 send() (데이터송신)이 가능하다.

서버는 ACK를 받지 못하고 SYN_RCV 상태이지만 클라이언트 소켓은 이미 ESTABLISHED 상태이기 때문이다.

## 3. 소켓(Socket)의 종류 {#소켓socket의-종류 ke-size="size26"}

### **3-1. TCP (스트림 소켓)** {#tcp-스트림-소켓 ke-size="size23"}

![](/images/posts/30/img_2.png)

-   양방향 바이트 스트림 전송, 연결 지향방식의 소켓
-   송수신자의 연결을 보장하여 신뢰성 있는 데이터 송신 가능
-   오류수정, 전송처리, 흐름제어
-   송신되는 순서에 따라 중복되지 않게 데이터 수신
-   소량의 데이터보다 대량의 데이터 전송에 적합

### **3-2. UDP (데이터그램 소켓)** {#udp-데이터그램-소켓 ke-size="size23"}

![](/images/posts/30/img_3.png)

-   비연결형 소켓
-   데이터 크기에 제한이 있음
-   데이터의 순서와 신뢰성을 보장하지 않음
-   점대점뿐만 아니라 일대다 연결도 가능
-   확실하게 전달이 보장되지 않음, 데이터가 손실돼도 오류가 발생하지 않음
-   실시간 멀티미디어 정보를 위해 주로 사용
-   accept 과정 없이 소켓 생성 후 바로 데이터 송수신
 

 

 

 

 

 

참고

- https://devkly.com/network/3-way-handshake-with-c/

- https://velog.io/@newdana01/%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-HTTP%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4
 

