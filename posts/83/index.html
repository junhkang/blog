<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항 | Jun Kang's Blog</title>
<meta name=keywords content="Union,PostgreSQL,Except,intersect"><meta name=description content="
1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합
UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.
query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.
2. UNION
query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.
2-1. UNION 단일 사용
1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/83/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/83/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/83/"><meta property="og:title" content="[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항 | Jun Kang's Blog"><meta property="og:description" content="
1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합
UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.
query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.
2. UNION
query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.
2-1. UNION 단일 사용
1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/83/"><meta property="twitter:title" content="[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항 | Jun Kang's Blog"><meta property="twitter:description" content="
1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합
UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.
query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.
2. UNION
query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.
2-1. UNION 단일 사용
1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/83/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항"><meta property="og:description" content=" 1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합 UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.
query1 UNION [ALL] query2 query1 INTERSECT [ALL] query2 query1 EXCEPT [ALL] query2 해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.
2. UNION query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.
2-1. UNION 단일 사용 1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-08T16:04:29+00:00"><meta property="article:modified_time" content="2024-04-08T16:04:29+00:00"><meta property="article:tag" content="Union"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="Except"><meta property="article:tag" content="Intersect"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항"><meta name=twitter:description content="
1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합
UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.
query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.
2. UNION
query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.
2-1. UNION 단일 사용
1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항","item":"https://junhkang.com/posts/83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항","name":"[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항","description":" 1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합 UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.\nquery1 UNION [ALL] query2 query1 INTERSECT [ALL] query2 query1 EXCEPT [ALL] query2 해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.\n2. UNION query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.\n2-1. UNION 단일 사용 1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다.\n","keywords":["Union","PostgreSQL","Except","intersect"],"articleBody":" 1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합 UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.\nquery1 UNION [ALL] query2 query1 INTERSECT [ALL] query2 query1 EXCEPT [ALL] query2 해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.\n2. UNION query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.\n2-1. UNION 단일 사용 1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다.\n(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) ORDER BY ID; 2-2. UNION ALL 1~5 번째 ROWS, 4~8번째 ROWS를 합친 결과를 보면 다음과 같다. (1000004, 1000005 중복 출력)\n(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) ORDER BY ID; 3. INTERSECT query1과 query2에 동시에 존재하는 ROWS를 반환한다. INTERSECT ALL을 사용하면 중복을 제거해 준다. 예제에선 동일 값을 중복생성하기 위해 UNION과 결합해서 사용하였다.\n3-1. INTERSECT 단일 사용 [1~5 번째 ROWS X 2, 4~8번째 ROWS X 2중 교차되는 ROWS만 중복 제거한 후 출력(1000004, ]{style=“color: #333333; text-align: start;\"}1000005가 중복 제거된 후 출력)\n((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)) INTERSECT ((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)) ORDER BY ID; 3-2. INTERSECT ALL 1~5 번째 ROWS X 2, 4~8번째 ROWS X 2중 교차되는 ROWS만 중복을 포함하여 출력(1000004, 1000005가 두 번씩 중복 출력)\n((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)) INTERSECT ALL ((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)) ORDER BY ID; 4. EXCEPT query1에는 존재하고, query2에는 존재하지 않는 ROWS를 반환한다. EXCEPT ALL을 사용하면 중복을 제거해 준다. 위 예제와 동일하게 중복된 상황을 위해 UNION 쿼리와 결합하여 사용하였다.\n4-1. EXCEPT 단일 사용 선행쿼리에 존재하고, 후행쿼리에 존재하지 않는 ROWS를 중복을 제거한 후 반환한다.\n((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)) EXCEPT (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) ORDER BY ID; 4-2. EXCEPT ALL 선행쿼리에 존재하고, 후행쿼리에 존재하지 않는 ROWS를 중복 제거 없이 모두 반환한다.\n((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5) UNION ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)) EXCEPT ALL (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3) ORDER BY ID; 주의할 점은, EXCEPT만 사용할 경우, 선행쿼리에 동일한 ROWS가 아무리 많더라도 후행쿼리에 하나라도 존재할 경우 모두 삭제되지만, EXCEPT ALL로 중복을 모두 리턴할 경우, 후행 쿼리에 존재하는 만큼만 ROWS가 삭제된다.\n(EXCEPT ALL의 경우 1000003, 1000004 ROWS가 후행 쿼리에 존재하지만, 선행쿼리에 2개씩 존재하기에 여전히 출력되고 있다.) 5. 복합 사용 세 가지 구문은 복합적으로 사용할 수 있다. 예를 들어 다음 두 개의 쿼리는 같은 결과를 리턴한다.\nquery1 UNION query2 EXCEPT query3 -- 동일 (query1 UNION query2) EXCEPT query3 해당 예제에서 확인할 수 있듯, 괄호를 통해 구문의 실행 순서를 조절할 수 있다. 괄호가 없을 때 UNION, EXCEPT는 왼쪽에서 오른쪽으로 실행되며, INTERSECT가 최우선으로 적용된다. (공통부분 추출이기에 더 엄격한 필터 취급)\nquery1 UNION query2 INTERSECT query3 -- 동일 query1 UNION (query2 INTERSECT query3) 또한 개별 쿼리를 괄호로 지정할 수 있으며, LIMIT/OFFSET 같이 특정 쿼리에만 지정하고 싶은 구문이 있을 경우 다르게 적용할 수 있다.\n(2~4 예제에서 사용 중)\n-- UNION 결과에 LIMIT 10 적용 SELECT a FROM b UNION SELECT x FROM y LIMIT 10 -- UNION 결과에 LIMIT 10 적용 (1과 동일) (SELECT a FROM b UNION SELECT x FROM y) LIMIT 10 -- 후행 쿼리 결과에만 LIMIT 10 적용 SELECT a FROM b UNION (SELECT x FROM y LIMIT 10) 참고 https://www.postgresql.org/docs/16/queries-union.html\n","wordCount":"639","inLanguage":"en","datePublished":"2024-04-08T16:04:29Z","dateModified":"2024-04-08T16:04:29Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/83/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://junhkang.com/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항</h1><div class=post-meta><span title='2024-04-08 16:04:29 +0000 UTC'>April 8, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=union-intersect-except를-통한-쿼리-결합 ke-size=size26>1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합<a hidden class=anchor aria-hidden=true href=#union-intersect-except를-통한-쿼리-결합>#</a></h2><p>UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.</p><pre tabindex=0><code>query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
</code></pre><p>해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.</p><h2 id=union ke-size=size26>2. UNION<a hidden class=anchor aria-hidden=true href=#union>#</a></h2><p>query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.</p><h3 id=union-단일-사용 ke-size=size23>2-1. UNION 단일 사용<a hidden class=anchor aria-hidden=true href=#union-단일-사용>#</a></h3><p>1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다.</p><pre tabindex=0><code>(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)
UNION
(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)
ORDER BY ID;
</code></pre><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.32.47.png>
 </p><h3 id=2-2-union-all>2-2. UNION ALL<a hidden class=anchor aria-hidden=true href=#2-2-union-all>#</a></h3><p>1~5 번째 ROWS, 4~8번째 ROWS를 합친 결과를 보면 다음과 같다. (1000004, 1000005 중복 출력)</p><pre tabindex=0><code>(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)
UNION ALL
(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)
ORDER BY ID;
</code></pre><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.34.11.png></p><h2 id=inserset ke-size=size26>3. INTERSECT<a hidden class=anchor aria-hidden=true href=#inserset>#</a></h2><p>query1과 query2에 동시에 존재하는 ROWS를 반환한다. INTERSECT ALL을 사용하면 중복을 제거해 준다. 예제에선 동일 값을 중복생성하기 위해 UNION과 결합해서 사용하였다.</p><h3 id=intersect-단일-사용 ke-size=size23>3-1. INTERSECT 단일 사용<a hidden class=anchor aria-hidden=true href=#intersect-단일-사용>#</a></h3><p>[1~5 번째 ROWS X 2, 4~8번째 ROWS X 2중 교차되는 ROWS만 중복 제거한 후 출력(1000004, ]{style=&ldquo;color: #333333; text-align: start;"}1000005가 중복 제거된 후 출력)</p><pre tabindex=0><code>((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)
 UNION ALL
 (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5))
INTERSECT
((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)
 UNION ALL
 (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3))
ORDER BY ID;
</code></pre><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.43.27.png></p><h3 id=intersect-all ke-size=size23>3-2. INTERSECT ALL<a hidden class=anchor aria-hidden=true href=#intersect-all>#</a></h3><p>1~5 번째 ROWS X 2, 4~8번째 ROWS X 2중 교차되는 ROWS만 중복을 포함하여 출력(1000004, 1000005가 두 번씩 중복 출력)</p><pre tabindex=0><code>((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)
 UNION ALL
 (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5))
INTERSECT ALL
((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)
 UNION ALL
 (SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3))
ORDER BY ID;
</code></pre><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.41.47.png>
 </p><h2 id=4-except>4. EXCEPT<a hidden class=anchor aria-hidden=true href=#4-except>#</a></h2><p>query1에는 존재하고, query2에는 존재하지 않는 ROWS를 반환한다. EXCEPT ALL을 사용하면 중복을 제거해 준다. 위 예제와 동일하게 중복된 상황을 위해 UNION 쿼리와 결합하여 사용하였다.</p><h3 id=except-단일-사용 ke-size=size23>4-1. EXCEPT 단일 사용<a hidden class=anchor aria-hidden=true href=#except-단일-사용>#</a></h3><p>선행쿼리에 존재하고, 후행쿼리에 존재하지 않는 ROWS를 중복을 제거한 후 반환한다.</p><pre tabindex=0><code>((SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5)
UNION ALL
(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5))
EXCEPT
(SELECT * FROM TEST_EXPLAIN ORDER BY ID LIMIT 5 OFFSET 3)
ORDER BY ID;
</code></pre><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.45.25.png></p><h3 id=except-all ke-size=size23>4-2. EXCEPT ALL<a hidden class=anchor aria-hidden=true href=#except-all>#</a></h3><p>선행쿼리에 존재하고, 후행쿼리에 존재하지 않는 ROWS를 중복 제거 없이 모두 반환한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>((<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> TEST_EXPLAIN <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> ID <span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>UNION</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> TEST_EXPLAIN <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> ID <span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXCEPT</span> <span style=color:#66d9ef>ALL</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> TEST_EXPLAIN <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> ID <span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>5</span> <span style=color:#66d9ef>OFFSET</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> ID;
</span></span></code></pre></div><p><img loading=lazy src=/images/posts/83/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%203.46.19.png></p><p>주의할 점은, EXCEPT만 사용할 경우, 선행쿼리에 동일한 ROWS가 아무리 많더라도 후행쿼리에 하나라도 존재할 경우 모두 삭제되지만, EXCEPT ALL로 중복을 모두 리턴할 경우, 후행 쿼리에 존재하는 만큼만 ROWS가 삭제된다.</p><p>(EXCEPT ALL의 경우 1000003, 1000004 ROWS가 후행 쿼리에 존재하지만, 선행쿼리에 2개씩 존재하기에 여전히 출력되고 있다.)
 </p><h2 id=5-복합-사용>5. 복합 사용<a hidden class=anchor aria-hidden=true href=#5-복합-사용>#</a></h2><p>세 가지 구문은 복합적으로 사용할 수 있다. 예를 들어 다음 두 개의 쿼리는 같은 결과를 리턴한다.</p><pre tabindex=0><code>query1 UNION query2 EXCEPT query3
-- 동일
(query1 UNION query2) EXCEPT query3
</code></pre><p>해당 예제에서 확인할 수 있듯, 괄호를 통해 구문의 실행 순서를 조절할 수 있다. 괄호가 없을 때 UNION, EXCEPT는 왼쪽에서 오른쪽으로 실행되며, <strong>INTERSECT가 최우선</strong>으로 적용된다. (공통부분 추출이기에 더 엄격한 필터 취급)</p><pre tabindex=0><code>query1 UNION query2 INTERSECT query3
-- 동일
query1 UNION (query2 INTERSECT query3)
</code></pre><p>또한 개별 쿼리를 괄호로 지정할 수 있으며, LIMIT/OFFSET 같이 특정 쿼리에만 지정하고 싶은 구문이 있을 경우 다르게 적용할 수 있다.</p><p>(2~4 예제에서 사용 중)</p><pre tabindex=0><code>-- UNION 결과에 LIMIT 10 적용
SELECT a FROM b UNION SELECT x FROM y LIMIT 10
</code></pre><pre tabindex=0><code>-- UNION 결과에 LIMIT 10 적용 (1과 동일)
(SELECT a FROM b UNION SELECT x FROM y) LIMIT 10
</code></pre><pre tabindex=0><code>-- 후행 쿼리 결과에만 LIMIT 10 적용
SELECT a FROM b UNION (SELECT x FROM y LIMIT 10)
</code></pre><ul><li>참고</li></ul><p><a href=https://www.postgresql.org/docs/16/queries-union.html>https://www.postgresql.org/docs/16/queries-union.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/union/>Union</a></li><li><a href=https://junhkang.com/tags/postgresql/>PostgreSQL</a></li><li><a href=https://junhkang.com/tags/except/>Except</a></li><li><a href=https://junhkang.com/tags/intersect/>Intersect</a></li></ul></footer><div class=giscus><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>