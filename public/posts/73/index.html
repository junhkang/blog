<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용 | Jun Kang's Blog</title>
<meta name=keywords content="디자인패턴,Decorator"><meta name=description content='
1. 데코레이터(Decorator) 패턴이란?
중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 "장식하는 사람"이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 "장식틀"을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.
+=============+
|Hello, world|
+=============+
사용될 클래스는 각각 다음과 같다.'><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/73/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/73/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="https://junhkang.com/posts/73/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용"><meta property="og:description" content=' 1. 데코레이터(Decorator) 패턴이란? 중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 "장식하는 사람"이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 "장식틀"을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.
+=============+ |Hello, world| +=============+ 사용될 클래스는 각각 다음과 같다.'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-18T17:23:46+00:00"><meta property="article:modified_time" content="2024-03-18T17:23:46+00:00"><meta property="article:tag" content="디자인패턴"><meta property="article:tag" content="Decorator"><meta name=twitter:card content="summary"><meta name=twitter:title content="[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용"><meta name=twitter:description content='
1. 데코레이터(Decorator) 패턴이란?
중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 "장식하는 사람"이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 "장식틀"을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.
+=============+
|Hello, world|
+=============+
사용될 클래스는 각각 다음과 같다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용","item":"https://junhkang.com/posts/73/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용","name":"[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용","description":" 1. 데코레이터(Decorator) 패턴이란? 중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 \u0026quot;장식하는 사람\u0026quot;이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 \u0026quot;장식틀\u0026quot;을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.\n+=============+ |Hello, world| +=============+ 사용될 클래스는 각각 다음과 같다.\n","keywords":["디자인패턴","Decorator"],"articleBody":" 1. 데코레이터(Decorator) 패턴이란? 중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 \"장식하는 사람\"이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 \"장식틀\"을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.\n+=============+ |Hello, world| +=============+ 사용될 클래스는 각각 다음과 같다.\nDisplay - 문자열 표시용 추상 \b클래스 StringDisplay - 단일 행으로 구성된 문자열 표시용 클래스 Border - 장식틀 추상 클래스 SideBorder - 좌우 장식틀 클래스 FullBorder - 상하좌우 장식틀 클래스 예제 클래스 다이어그램\n각 클래스의 역할\nComponent - 기능을 추가할 때 핵심이 되는 객체 (Display) ConcreteComponent - Component인터페이스를 구현하는 구현체 (StringDisplay) Decorator - Component와 동일한 인터페이스를 가지고 장식할 대상이 되는 Component도 포함(Border) ConcreteDecorator - 구체적인 Decorator (SideBorder, FullBorder) 2. 예제 2-1. Display 클래스 여러 행으로 이루어진 문자열을 표시하는 추상 클래스이다. 각 메서드의 역할을 살펴보면 다음과 같다.\ngetColumns - 가로 문자수 가져오기 getRows - 세로 문자수 가져오기 getRowText - 지정한 행의 문자열 가져오기 show - 모든 행을 표시하기 (getRow를 가져와서 for문을 돌며 getRowText 메서드로 표시할 문자열을 가져온다) public abstract class Display { public abstract int getColumns(); // 가로 문자 수를 얻는다 public abstract int getRows(); // 세로 행수를 얻는다 public abstract String getRowText(int row); // row행째 문자열을 얻는다 // 모든 행을 표시한다 public void show() { for (int i = 0; i \u003c getRows(); i++) { System.out.println(getRowText(i)); } } } 2-2. StringDisplay 클래스 Display 추상 클래스만 봐서는 이해하기 어려우므로 하위 클래스인 StringDisplay 클래스를 살펴보자. StringDisplay클래스는 장식이 들어갈 중심이 될 객체 역할이며, Display클래스에서 선언된 추상 메서드를 구현한다.\ngetColumns - string.length()로 반환되는 문자열의 길이 getRows - 1을 반환 getRowText - 0번째 행의 값을 취할 때만 string 필드 반환 public class StringDisplay extends Display { private String string; // 표시 문자열 public StringDisplay(String string) { this.string = string; } @Override public int getColumns() { return string.length(); } @Override public int getRows() { return 1; // 행수는 1 } @Override public String getRowText(int row) { if (row != 0) { throw new IndexOutOfBoundsException(); } return string; } } 2-3. Border 클래스 문자열을 표시하는 Display클래스의 하위 클래스로 정의되어 있다. 상속에 의해 내용물과 동일한 메서드를 가지게 된다. getColumns, getRows, getRowText, show 메서드를 그대로 상속받으며 인터페이스(API) 관점에서 보면 장식품(Boder)이 내용물(Display)을 동일시할 수 있다는 뜻이다.\npublic abstract class Border extends Display { protected Display display; // 이 장식틀이 감싸는 '내용물' protected Border(Display display) { // 인스턴스 생성 시 '내용물'을 인수로 지정 this.display = display; } } Border는 Display 형의 display 필드를 가지고 있으면서 Border도 Display의 하위 클래스 이므로 display필드의 내용물은 또 다른 장식(Border클래스의 하위 클래스) 일 수도 있다. 그리고 그 장식 또한 display필드를 가지고 있을 수 있다.\n2-4. SideBorder 클래스 SideBorder클래스는 구체적인 장식의 일종으로 Border클래스의 하위 클래스이다. SideBorder 클래스는 문자열 좌우에 정해진 문자로 장식한다.\nborderChar - 어떤 문자로 장식할지 지정 getColumns - 표시문자의 가로 문자수 (내용물의 문자수 + 좌우 장식 문자수) getRows - display.getRows()를 그대로 사용 getRowsText - 기존 문자열 양쪽에 borderChar를 붙인 후 반환 public class SideBorder extends Border { private char borderChar; // 장식 문자 // 내용물이 될 Display와 장식 문자를 지정 public SideBorder(Display display, char ch) { super(display); this.borderChar = ch; } @Override public int getColumns() { // 문자 수는 내용물의 양쪽에 장식 문자만큼 더한 것 return 1 + display.getColumns() + 1; } @Override public int getRows() { // 행수는 내용물의 행수와 같다 return display.getRows(); } @Override public String getRowText(int row) { // 지정 행의 내용은 내용물의 지정 행 양쪽에 장식 문자를 붙인 것 return borderChar + display.getRowText(row) + borderChar; } } 2-5. FullBorder 클래스 FullBorder 클래스는 SideBorder 클래스와 동일하게 Border 하위 클래스이다. 예제에서는 SiderBorder이 좌우로만 문자를 장식했다면, 상하좌우를 모두 장식할 수 있으며, 장식 문자는 따로 지정할 수 없게 되어있다.\ngetRowText - Row가 0일 경우 상단 장식추가, Row숫자보다 1클경우 하단 장식 추가 makeLine - 지정한 문자가 연속하는 문자열을 만드는 보조 메서드 public class FullBorder extends Border { public FullBorder(Display display) { super(display); } @Override public int getColumns() { // 문자 수는 내용물 양쪽에 좌우 장식 문자만큼 더한 것 return 1 + display.getColumns() + 1; } @Override public int getRows() { // 행수는 내용물의 행수에 상하 장식 문자만큼 더한 것 return 1 + display.getRows() + 1; } @Override public String getRowText(int row) { if (row == 0) { // 상단 테두리 return \"+\" + makeLine('-', display.getColumns()) + \"+\"; } else if (row == display.getRows() + 1) { // 하단 테두리 return \"+\" + makeLine('-', display.getColumns()) + \"+\"; } else { // 기타 return \"|\" + display.getRowText(row - 1) + \"|\"; } } // 문자 ch로 count 수만큼 연속한 문자열을 만든다 private String makeLine(char ch, int count) { StringBuilder line = new StringBuilder(); for (int i = 0; i \u003c count; i++) { line.append(ch); } return line.toString(); } } 2-6. Main 이제 샘플 코드를 실행시킬 메인 클래스를 보자\npublic static void main(String[] args) { Display b1 = new StringDisplay(\"Hello, world.\"); Display b2 = new SideBorder(b1, '#'); Display b3 = new FullBorder(b2); b1.show(); b2.show(); b3.show(); Display b4 = new SideBorder( new FullBorder( new FullBorder( new SideBorder( new FullBorder( new StringDisplay(\"Hello, world.\") ), '*' ) ) ), '/' ); b4.show(); 예제에서 각 인스턴스의 역할을 보면\nb1 - \"Hellow, world\"를 장식 없이 기본으로 표현 b2 - b1에 '#'으로 좌우 장식만 추가 b3 - b2에 상하좌우 전체 장식틀 추가 b4 - “Hello, world\"에 여러 겹 장식틀 추가 실행 결과를 확인해 보면 다음과 같다.\n// b1.show() Hello, world. // b2.show() #Hello, world.# // b3.show() +---------------+ |#Hello, world.#| +---------------+ // b4.show() /+-------------------+/ /|+-----------------+|/ /||*+-------------+*||/ /||*|Hello, world.|*||/ /||*+-------------+*||/ /|+-----------------+|/ /+-------------------+/ b2, b3는 생성될 때 b1, b2를 각각 참조하는데, 서로의 관계를 확인해 보면 b1의 장식이 b2, b2의 장식이 b3인 관계가 성립한다.\n3. 정리 Decorator 패턴은 장식틀과 내용물을 동일시하는 디자인 패턴이다. 장식틀을 사용해서 특징을 추가하며 감싸더라도 내부 API는 가려지지 않는다는 특징이 있고(외부에서 getColumns, getRows 등의 메서드를 볼 수 있다.) 장식틀을 중첩적으로 추가하여 중심이 되는 객체를 계속해서 변경할 수 있다. 내용물과 장식틀이 동일시된다는 점에서 Composite 패턴과 유사한 점이 있지만, Decorator 패턴은 바깥 테두리를 추가함으로써 기능을 추가 나가는 것이 주된 목적이라는 점에서 다르다.\n4. 장점 내용 변경 없이 기능 추가 가능 - 핵심 객체에 대한 변경 없이, 장식틀을 추가하여 기능을 추가할 수 있다. 단순한 구성으로 다양한 변경 가능 - 구체적인 장식틀 (ConcreteDecorator)를 많이 준비하면 장식틀끼리 조합하여 새로운 객체를 계쏙 만들어 낼 수 있기 때문이다. 단순한 구성의 장식틀의 조합으로 다양한 기능을 추가할 수 있다. - 참고 : JAVA 언어로 배우는 디자인 패턴 입문 3편\n- 상세 예제소스는 깃허브에서 확인가능\nhttps://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/decorator\n","wordCount":"1042","inLanguage":"en","datePublished":"2024-03-18T17:23:46Z","dateModified":"2024-03-18T17:23:46Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/73/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용</h1><div class=post-meta><span title='2024-03-18 17:23:46 +0000 UTC'>March 18, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=데코레이터decorator-패턴이란 ke-size=size26>1. 데코레이터(Decorator) 패턴이란?<a hidden class=anchor aria-hidden=true href=#데코레이터decorator-패턴이란>#</a></h2><p>중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 "장식하는 사람"이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 "장식틀"을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.</p><pre tabindex=0><code class=language-asciidoc data-lang=asciidoc>+=============+
|Hello, world|
+=============+
</code></pre><p>사용될 클래스는 각각 다음과 같다.</p><ul><li><strong>Display -</strong> 문자열 표시용 추상 클래스</li><li><strong>StringDisplay -</strong> 단일 행으로 구성된 문자열 표시용 클래스</li><li><strong>Border -</strong> 장식틀 추상 클래스</li><li><strong>SideBorder -</strong> 좌우 장식틀 클래스</li><li><strong>FullBorder -</strong> 상하좌우 장식틀 클래스</li></ul><p><img loading=lazy src=/images/posts/73/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-18%20%EC%98%A4%ED%9B%84%204.10.50.png></p><p>예제 클래스 다이어그램</p><p>각 클래스의 역할</p><ul><li><strong>Component -</strong> 기능을 추가할 때 핵심이 되는 객체 (Display)</li><li><strong>ConcreteComponent -</strong> Component인터페이스를 구현하는 구현체 (StringDisplay)</li><li><strong>Decorator -</strong> Component와 동일한 인터페이스를 가지고 장식할 대상이 되는 Component도 포함(Border)</li><li><strong>ConcreteDecorator -</strong> 구체적인 Decorator (SideBorder, FullBorder)</li></ul><h2 id=예제 ke-size=size26>2. 예제<a hidden class=anchor aria-hidden=true href=#예제>#</a></h2><h3 id=display-클래스 ke-size=size23>2-1. Display 클래스<a hidden class=anchor aria-hidden=true href=#display-클래스>#</a></h3><p>여러 행으로 이루어진 문자열을 표시하는 추상 클래스이다. 각 메서드의 역할을 살펴보면 다음과 같다.</p><ul><li><strong>getColumns -</strong> 가로 문자수 가져오기</li><li><strong>getRows -</strong> 세로 문자수 가져오기</li><li><strong>getRowText -</strong> 지정한 행의 문자열 가져오기</li><li><strong>show -</strong> 모든 행을 표시하기 (getRow를 가져와서 for문을 돌며 getRowText 메서드로 표시할 문자열을 가져온다)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Display</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>int</span> getColumns();               <span style=color:#75715e>// 가로 문자 수를 얻는다</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>int</span> getRows();                  <span style=color:#75715e>// 세로 행수를 얻는다</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> String getRowText(<span style=color:#66d9ef>int</span> row);     <span style=color:#75715e>// row행째 문자열을 얻는다</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 모든 행을 표시한다</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> show() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; getRows(); i++) {
</span></span><span style=display:flex><span>            System.<span style=color:#66d9ef>out</span>.println(getRowText(i));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=stringdisplay-클래스 ke-size=size23>2-2. StringDisplay 클래스<a hidden class=anchor aria-hidden=true href=#stringdisplay-클래스>#</a></h3><p>Display 추상 클래스만 봐서는 이해하기 어려우므로 하위 클래스인 StringDisplay 클래스를 살펴보자. StringDisplay클래스는 장식이 들어갈 중심이 될 객체 역할이며, Display클래스에서 선언된 추상 메서드를 구현한다.</p><ul><li><strong>getColumns -</strong> string.length()로 반환되는 문자열의 길이</li><li><strong>getRows -</strong> 1을 반환</li><li><strong>getRowText -</strong> 0번째 행의 값을 취할 때만 string 필드 반환</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>StringDisplay</span> extends Display {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>String</span> string; <span style=color:#75715e>// 표시 문자열 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>StringDisplay</span>(<span style=color:#66d9ef>String</span> string) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.string <span style=color:#f92672>=</span> string;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getColumns() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> string.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getRows() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 행수는 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>String</span> getRowText(<span style=color:#66d9ef>int</span> row) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IndexOutOfBoundsException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> string;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=border-클래스 ke-size=size23>2-3. Border 클래스<a hidden class=anchor aria-hidden=true href=#border-클래스>#</a></h3><p>문자열을 표시하는 Display클래스의 하위 클래스로 정의되어 있다. 상속에 의해 내용물과 동일한 메서드를 가지게 된다. <strong>getColumns, getRows, getRowText, show</strong> 메서드를 그대로 상속받으며 인터페이스(API) 관점에서 보면 장식품(Boder)이 내용물(Display)을 동일시할 수 있다는 뜻이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>public <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Border</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Display</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>Display</span> display<span style=color:#f92672>;</span>             <span style=color:#75715e>// 이 장식틀이 감싸는 &#39;내용물&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>Border</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Display</span> display<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// 인스턴스 생성 시 &#39;내용물&#39;을 인수로 지정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span>display <span style=color:#66d9ef>=</span> display<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Border는 Display 형의 display 필드를 가지고 있으면서 Border도 Display의 하위 클래스 이므로 display필드의 내용물은 또 다른 장식(Border클래스의 하위 클래스) 일 수도 있다. 그리고 그 장식 또한 display필드를 가지고 있을 수 있다.</p><h3 id=sideborder-클래스 ke-size=size23>2-4. SideBorder 클래스<a hidden class=anchor aria-hidden=true href=#sideborder-클래스>#</a></h3><p>SideBorder클래스는 구체적인 장식의 일종으로 Border클래스의 하위 클래스이다. SideBorder 클래스는 문자열 좌우에 정해진 문자로 장식한다.</p><ul><li><strong>borderChar -</strong> 어떤 문자로 장식할지 지정</li><li><strong>getColumns -</strong> 표시문자의 가로 문자수 (내용물의 문자수 + 좌우 장식 문자수)</li><li><strong>getRows -</strong> display.getRows()를 그대로 사용</li><li><strong>getRowsText -</strong> 기존 문자열 양쪽에 borderChar를 붙인 후 반환</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>SideBorder</span> extends Border {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>char</span> borderChar;  <span style=color:#75715e>// 장식 문자
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 내용물이 될 Display와 장식 문자를 지정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SideBorder</span>(Display <span style=color:#a6e22e>display</span>, <span style=color:#66d9ef>char</span> ch) {
</span></span><span style=display:flex><span>        super(<span style=color:#a6e22e>display</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.borderChar <span style=color:#f92672>=</span> ch;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getColumns() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 문자 수는 내용물의 양쪽에 장식 문자만큼 더한 것
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>display</span>.getColumns() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getRows() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 행수는 내용물의 행수와 같다 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>display</span>.getRows();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>String</span> getRowText(<span style=color:#66d9ef>int</span> row) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 지정 행의 내용은 내용물의 지정 행 양쪽에 장식 문자를 붙인 것
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> borderChar <span style=color:#f92672>+</span> <span style=color:#a6e22e>display</span>.getRowText(row) <span style=color:#f92672>+</span> borderChar;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=fullborder-클래스 ke-size=size23>2-5. FullBorder 클래스<a hidden class=anchor aria-hidden=true href=#fullborder-클래스>#</a></h3><p>FullBorder 클래스는 SideBorder 클래스와 동일하게 Border 하위 클래스이다. 예제에서는 SiderBorder이 좌우로만 문자를 장식했다면, 상하좌우를 모두 장식할 수 있으며, 장식 문자는 따로 지정할 수 없게 되어있다.</p><ul><li>getRowText - Row가 0일 경우 상단 장식추가, Row숫자보다 1클경우 하단 장식 추가</li><li>makeLine - 지정한 문자가 연속하는 문자열을 만드는 보조 메서드</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>FullBorder</span> extends Border {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> FullBorder(Display <span style=color:#a6e22e>display</span>) {
</span></span><span style=display:flex><span>        super(<span style=color:#a6e22e>display</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getColumns() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 문자 수는 내용물 양쪽에 좌우 장식 문자만큼 더한 것
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>display</span>.getColumns() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> getRows() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 행수는 내용물의 행수에 상하 장식 문자만큼 더한 것
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>display</span>.getRows() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>String</span> getRowText(<span style=color:#66d9ef>int</span> row) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {                                                 <span style=color:#75715e>// 상단 테두리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>+</span> makeLine(<span style=color:#e6db74>&#39;-&#39;</span>, <span style=color:#a6e22e>display</span>.getColumns()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;+&#34;</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>==</span> <span style=color:#a6e22e>display</span>.getRows() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {                  <span style=color:#75715e>// 하단 테두리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>+</span> makeLine(<span style=color:#e6db74>&#39;-&#39;</span>, <span style=color:#a6e22e>display</span>.getColumns()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;+&#34;</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {                                                           <span style=color:#75715e>// 기타
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;|&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>display</span>.getRowText(row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;|&#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 문자 ch로 count 수만큼 연속한 문자열을 만든다
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>String</span> makeLine(<span style=color:#66d9ef>char</span> ch, <span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>        StringBuilder <span style=color:#a6e22e>line</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>line</span>.append(ch);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>line</span>.toString();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=main ke-size=size23>2-6. Main<a hidden class=anchor aria-hidden=true href=#main>#</a></h3><p>이제 샘플 코드를 실행시킬 메인 클래스를 보자</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haxe data-lang=haxe><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> void main(String[<span style=color:#960050;background-color:#1e0010>]</span> args<span style=color:#960050;background-color:#1e0010>)</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>Display</span> <span style=color:#960050;background-color:#1e0010>b1</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>StringDisplay(&#34;Hello,</span> <span style=color:#960050;background-color:#1e0010>world.&#34;);</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>Display</span> <span style=color:#960050;background-color:#1e0010>b2</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>SideBorder(b1,</span> <span style=color:#960050;background-color:#1e0010>&#39;#&#39;);</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>Display</span> <span style=color:#960050;background-color:#1e0010>b3</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>FullBorder(b2);</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>b1.show();</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>b2.show();</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>b3.show();</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>Display</span> <span style=color:#960050;background-color:#1e0010>b4</span> <span style=color:#960050;background-color:#1e0010>=</span>
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>SideBorder(</span>
</span></span><span style=display:flex><span>                    <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>FullBorder(</span>
</span></span><span style=display:flex><span>                        <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>FullBorder(</span>
</span></span><span style=display:flex><span>                            <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>SideBorder(</span>
</span></span><span style=display:flex><span>                                <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>FullBorder(</span>
</span></span><span style=display:flex><span>                                    <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>StringDisplay(&#34;Hello,</span> <span style=color:#960050;background-color:#1e0010>world.&#34;)</span>
</span></span><span style=display:flex><span>                                <span style=color:#960050;background-color:#1e0010>),</span>
</span></span><span style=display:flex><span>                                <span style=color:#960050;background-color:#1e0010>&#39;*&#39;</span>
</span></span><span style=display:flex><span>                            <span style=color:#960050;background-color:#1e0010>)</span>
</span></span><span style=display:flex><span>                        <span style=color:#960050;background-color:#1e0010>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#960050;background-color:#1e0010>),</span>
</span></span><span style=display:flex><span>                    <span style=color:#960050;background-color:#1e0010>&#39;/&#39;</span>
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>);</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>b4.show();</span>
</span></span></code></pre></div><p>예제에서 각 인스턴스의 역할을 보면</p><ul><li><strong>b1 -</strong> "Hellow, world"를 장식 없이 기본으로 표현</li><li><strong>b2 -</strong> b1에 '#'으로 좌우 장식만 추가</li><li><strong>b3 -</strong> b2에 상하좌우 전체 장식틀 추가</li><li><strong>b4 -</strong> &ldquo;Hello, world"에 여러 겹 장식틀 추가</li></ul><p>실행 결과를 확인해 보면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d><span style=display:flex><span><span style=color:#75715e>// b1.show()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Hello<span style=color:#f92672>,</span> world<span style=color:#f92672>.</span>                    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// b2.show()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span>Hello<span style=color:#f92672>,</span> world<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>#</span>                    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// b3.show()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>+---------------+</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span><span style=color:#960050;background-color:#1e0010>#</span>Hello<span style=color:#f92672>,</span> world<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#f92672>|</span>                
</span></span><span style=display:flex><span><span style=color:#f92672>+---------------+</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// b4.show()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/+-------------------+/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/|+-----------------+|/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/||*+-------------+*||/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/||*|</span>Hello<span style=color:#f92672>,</span> world<span style=color:#f92672>.|*||/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/||*+-------------+*||/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>/|+-----------------+|/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/+-------------------+/</span>
</span></span></code></pre></div><p>b2, b3는 생성될 때 b1, b2를 각각 참조하는데, 서로의 관계를 확인해 보면 b1의 장식이 b2, b2의 장식이 b3인 관계가 성립한다.</p><h2 id=정리 ke-size=size26>3. 정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>Decorator 패턴은 장식틀과 내용물을 동일시하는 디자인 패턴이다. 장식틀을 사용해서 특징을 추가하며 감싸더라도 내부 API는 가려지지 않는다는 특징이 있고(외부에서 getColumns, getRows 등의 메서드를 볼 수 있다.) 장식틀을 중첩적으로 추가하여 중심이 되는 객체를 계속해서 변경할 수 있다. 내용물과 장식틀이 동일시된다는 점에서 Composite 패턴과 유사한 점이 있지만, Decorator 패턴은 바깥 테두리를 추가함으로써 기능을 추가 나가는 것이 주된 목적이라는 점에서 다르다.</p><h2 id=장점 ke-size=size26>4. 장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h2><ul><li><strong>내용 변경 없이 기능 추가 가능 -</strong> 핵심 객체에 대한 변경 없이, 장식틀을 추가하여 기능을 추가할 수 있다.</li><li><strong>단순한 구성으로 다양한 변경 가능 -</strong> 구체적인 장식틀 (ConcreteDecorator)를 많이 준비하면 장식틀끼리 조합하여 새로운 객체를 계쏙 만들어 낼 수 있기 때문이다. 단순한 구성의 장식틀의 조합으로 다양한 기능을 추가할 수 있다.</li></ul><p>- 참고 : JAVA 언어로 배우는 디자인 패턴 입문 3편</p><p>- 상세 예제소스는 깃허브에서 확인가능</p><p><a href=https://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/decorator>https://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/decorator</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/>디자인패턴</a></li><li><a href=https://junhkang.com/tags/decorator/>Decorator</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>