<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Spring] IoC(제어의 역전) & DI(의존성 주입)의 개념 | Jun Kang's Blog</title>
<meta name=keywords content="spring,di,IOC"><meta name=description content="
1. IoC (Inversion of Control) 제어의 역전

IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
 
이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
 "><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/42/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/42/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="https://junhkang.com/posts/42/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[Spring] IoC(제어의 역전) & DI(의존성 주입)의 개념"><meta property="og:description" content=" 1. IoC (Inversion of Control) 제어의 역전 IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다. 이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다. "><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-06T14:20:06+00:00"><meta property="article:modified_time" content="2023-11-06T14:20:06+00:00"><meta property="article:tag" content="Spring"><meta property="article:tag" content="Di"><meta property="article:tag" content="IOC"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Spring] IoC(제어의 역전) & DI(의존성 주입)의 개념"><meta name=twitter:description content="
1. IoC (Inversion of Control) 제어의 역전

IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
 
이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
 "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[Spring] IoC(제어의 역전) \u0026 DI(의존성 주입)의 개념","item":"https://junhkang.com/posts/42/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Spring] IoC(제어의 역전) \u0026 DI(의존성 주입)의 개념","name":"[Spring] IoC(제어의 역전) \u0026 DI(의존성 주입)의 개념","description":" 1. IoC (Inversion of Control) 제어의 역전 IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다. 이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다. ","keywords":["spring","di","IOC"],"articleBody":" 1. IoC (Inversion of Control) 제어의 역전 IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다. 이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다. IoC는 설계 패턴이 아닌 원칙이며 세부 구현은 개발자에게 달려있다. 스프링 컨테이너에서는 프로그램 내 객체의 라이프사이클을 인스턴스화하여 관리한다. XML, Java Annotation, Java 코드 등을 통해 애플리케이션에 필요한 객체 및 의존성 정보를 제공한다. IoC 컨테이너의 2가지 핵심 클래스는 다음과 같다.\nBeanFactory - 자바 객체(bean) 인스턴스의 라이프사이클을 관리하는 실질적인 컨테이너이며, 구동될 시가 아니라 요청이 있을 때 Bean 객체를 생성한다. ApplicationContext - 구동되는 시점에 등록된 Bean 객체를 스캔하여 객체화한다. 결론적으로 IoC는...\n어플리케이션 내의 코드 양을 줄인다. 클래스 간 결합을 느슨하게 한다. 애플리케이션 유지관리 및 테스트를 유리하게 한다. 어플리케이션 제어 책임이 개발자에서 프레임워크로 위임되므로, 핵심 비즈니스 로직에 더 집중할 수 있다. 2. DI (Dependency Injection, 의존성 주입) 의존성 주입은 프로그램 디자인이 결합도를 느슨하게 되도록 하고 의존관계 역전원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트 행위로부터 분리하는 것이다.\n2-1. 의존성 주입이란? A가 B에게 \"의존\"한다는 표현이 어떤 뜻일까? 한 객체가 다른 객체를 사용할 때 의존성이 있다고 표현하며 크게는 다음과 같은 상황에 의존한다고 한다.\n상속 또는 구현하는 경우 메서드를 호출하는 경우 A에서 B를 호출하는 경우 예를 들면 다음과 같은 경우에 Store객체가 Pencil객체에 의존성이 있다고 표현한다.\npublic class Store { private Pencil pencil; } DI는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에두고 클래스 레벨 의존관계가 고정되지 않도록 관계를 동적으로 주입하여 결합도를 낮출수 있게 해 준다. 어떤 객체가 사용하는 의존 객체를 직접 생성하는 것이 아니라, 주입을 받아 사용 하는것이다. 스프링에서의 의존성 주입은, 각 객체간의 의존관계를 스프링 컨테이너에서 개발자가 정의한 Bean 정보를 바탕으로 자동으로 주입해주는 기능을 의미한다. 이를통해 객체간 결합도를 낮추고 코드양을 줄여주며 유지보수를 편하게 해준다.\n2-2. 의존성 주입 방식 생성자주입, 필드주입, 수정자 주입등의 방법이 있다.\n생성자 주입 (권장) @Controller public class Controller{ private Service service; @Autowired public Controller(Service service){ this.service = service; } } 필드 주입 @Controller public class Controller{ @Autowired private Service service; } 수정자 주입 @Controller public class Controller{ private Service service; @Autowired public setService(Service service){ this.service = service; } } 결론적으로 DI는...\n객체를 직접 생성하는 것이 아닌, 외부에서 생성된 객체를 주입받아서 사용하는 것이다. 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행시점에 관계를 결정해 준다. 결합도를 낮추고 유연성을 확보하여 테스트를 용이하게 하며 개발 및 유지보수를 쉽게 해 준다. 참고\nhttps://kim-oriental.tistory.com/32\nhttps://mangkyu.tistory.com/150\n도서 : 스프링 부트 3 백엔드 개발자 되기 - 자바편\nhttps://stackoverflow.com/questions/3058/what-is-inversion-of-control/3140#3140\nhttps://velog.io/@virtualplastic/Spring-%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84-IOC-Inversion-of-Control#:~:text=5%2F9-,IOC(Inversion%20of%20Control)%20%EC%A0%9C%EC%96%B4%EC%9D%98%20%EC%97%AD%EC%A0%84,%EB%B3%B8%EC%97%85%EC%97%90%20%EC%A7%91%EC%A4%91%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8B%A4.\nhttps://june0122.tistory.com/18\n","wordCount":"426","inLanguage":"en","datePublished":"2023-11-06T14:20:06Z","dateModified":"2023-11-06T14:20:06Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/42/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[Spring] IoC(제어의 역전) & DI(의존성 주입)의 개념</h1><div class=post-meta><span title='2023-11-06 14:20:06 +0000 UTC'>November 6, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=ioc-inversion-of-control-제어의-역전 ke-size=size26>1. IoC (Inversion of Control) 제어의 역전<a hidden class=anchor aria-hidden=true href=#ioc-inversion-of-control-제어의-역전>#</a></h2><p><img loading=lazy src=/images/posts/42/img.png></p><p>IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
 </p><p>이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
 </p><p>IoC는 설계 패턴이 아닌 원칙이며 세부 구현은 개발자에게 달려있다. 스프링 컨테이너에서는 프로그램 내 객체의 라이프사이클을 인스턴스화하여 관리한다. XML, Java Annotation, Java 코드 등을 통해 애플리케이션에 필요한 객체 및 의존성 정보를 제공한다.
 </p><p>IoC 컨테이너의 2가지 핵심 클래스는 다음과 같다.</p><ul><li><strong>BeanFactory -</strong> 자바 객체(bean) 인스턴스의 라이프사이클을 관리하는 실질적인 컨테이너이며, 구동될 시가 아니라 요청이 있을 때 Bean 객체를 생성한다.</li><li><strong>ApplicationContext -</strong> 구동되는 시점에 등록된 Bean 객체를 스캔하여 객체화한다.</li></ul><p>결론적으로 IoC는...</p><ul><li>어플리케이션 내의 코드 양을 줄인다.</li><li>클래스 간 결합을 느슨하게 한다.</li><li>애플리케이션 유지관리 및 테스트를 유리하게 한다.</li><li>어플리케이션 제어 책임이 개발자에서 프레임워크로 위임되므로, 핵심 비즈니스 로직에 더 집중할 수 있다.
 </li></ul><h2 id=2-di-dependency-injection-의존성-주입>2. DI (Dependency Injection, 의존성 주입)<a hidden class=anchor aria-hidden=true href=#2-di-dependency-injection-의존성-주입>#</a></h2><blockquote><p>의존성 주입은 프로그램 디자인이 결합도를 느슨하게 되도록 하고 의존관계 역전원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트 행위로부터 분리하는 것이다.</p></blockquote><h3 id=의존성-주입이란 ke-size=size23>2-1. 의존성 주입이란?<a hidden class=anchor aria-hidden=true href=#의존성-주입이란>#</a></h3><p>A가 B에게 "의존"한다는 표현이 어떤 뜻일까? 한 객체가 다른 객체를 사용할 때 의존성이 있다고 표현하며 크게는 다음과 같은 상황에 의존한다고 한다.</p><ul><li>상속 또는 구현하는 경우</li><li>메서드를 호출하는 경우</li><li>A에서 B를 호출하는 경우</li></ul><p>예를 들면 다음과 같은 경우에 Store객체가 Pencil객체에 의존성이 있다고 표현한다.</p><pre tabindex=0><code>public class Store {
    private Pencil pencil;
}
</code></pre><p><img loading=lazy src=/images/posts/42/img_1.png></p><p>DI는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에두고 클래스 레벨 의존관계가 고정되지 않도록 관계를 동적으로 주입하여 결합도를 낮출수 있게 해 준다. 어떤 객체가 사용하는 의존 객체를 직접 생성하는 것이 아니라, 주입을 받아 사용 하는것이다. 스프링에서의 의존성 주입은, 각 객체간의 의존관계를 스프링 컨테이너에서 개발자가 정의한 Bean 정보를 바탕으로 자동으로 주입해주는 기능을 의미한다. 이를통해 객체간 결합도를 낮추고 코드양을 줄여주며 유지보수를 편하게 해준다.</p><h3 id=의존성-주입-방식 ke-size=size23>2-2. 의존성 주입 방식<a hidden class=anchor aria-hidden=true href=#의존성-주입-방식>#</a></h3><p>생성자주입, 필드주입, 수정자 주입등의 방법이 있다.</p><ul><li><strong>생성자 주입 (권장)</strong></li></ul><pre tabindex=0><code>@Controller 
public class Controller{
   private Service service;

   @Autowired 
   public Controller(Service service){
     this.service = service; 
   }
}
</code></pre><ul><li><strong>필드 주입</strong></li></ul><pre tabindex=0><code>@Controller
public class Controller{
  @Autowired 
  private Service service;
}
</code></pre><p> </p><ul><li><strong>수정자 주입</strong></li></ul><pre tabindex=0><code>@Controller 
public class Controller{
   private Service service;

   @Autowired 
   public setService(Service service){
     this.service = service; 
   }
}
</code></pre><p> </p><p>결론적으로 DI는...</p><ul><li>객체를 직접 생성하는 것이 아닌, 외부에서 생성된 객체를 주입받아서 사용하는 것이다.</li><li>강하게 결합된 클래스들을 분리하고, 애플리케이션 실행시점에 관계를 결정해 준다.</li><li>결합도를 낮추고 유연성을 확보하여 테스트를 용이하게 하며 개발 및 유지보수를 쉽게 해 준다.
 </li></ul><p> </p><p> </p><p> </p><p> </p><p>참고</p><ul><li><p><a href=https://kim-oriental.tistory.com/32>https://kim-oriental.tistory.com/32</a></p></li><li><p><a href=https://mangkyu.tistory.com/150>https://mangkyu.tistory.com/150</a></p></li><li><p>도서 : 스프링 부트 3 백엔드 개발자 되기 - 자바편</p></li><li><p><a href=https://stackoverflow.com/questions/3058/what-is-inversion-of-control/3140#3140>https://stackoverflow.com/questions/3058/what-is-inversion-of-control/3140#3140</a></p></li><li><p><a href=https://velog.io/@virtualplastic/Spring-%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84-IOC-Inversion-of-Control#>https://velog.io/@virtualplastic/Spring-%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84-IOC-Inversion-of-Control#</a>:~:text=5%2F9-,IOC(Inversion%20of%20Control)%20%EC%A0%9C%EC%96%B4%EC%9D%98%20%EC%97%AD%EC%A0%84,%EB%B3%B8%EC%97%85%EC%97%90%20%EC%A7%91%EC%A4%91%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8B%A4.</p></li><li><p><a href=https://june0122.tistory.com/18>https://june0122.tistory.com/18</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/spring/>Spring</a></li><li><a href=https://junhkang.com/tags/di/>Di</a></li><li><a href=https://junhkang.com/tags/ioc/>IOC</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>