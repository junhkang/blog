<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점 | Jun Kang's Blog</title>
<meta name=keywords content="wal,PostgreSQL,아카이브"><meta name=description content="

1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?
아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 "><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/66/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/66/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/66/"><meta property="og:title" content="[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점 | Jun Kang's Blog"><meta property="og:description" content="

1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?
아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 "><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/66/"><meta property="twitter:title" content="[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점 | Jun Kang's Blog"><meta property="twitter:description" content="

1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?
아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 "><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/66/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점"><meta property="og:description" content=" 1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란? 아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다. "><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-26T18:04:32+00:00"><meta property="article:modified_time" content="2024-02-26T18:04:32+00:00"><meta property="article:tag" content="Wal"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="아카이브"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점"><meta name=twitter:description content="

1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?
아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점","item":"https://junhkang.com/posts/66/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점","name":"[PostgreSQL] WAL (Write-Ahead Logging) \/ 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점","description":" 1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란? 아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다. ","keywords":["wal","PostgreSQL","아카이브"],"articleBody":" 1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란? 아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다. 충돌이 발생할 때마다 Log를 통해 데이터베이스를 복구할 수 있기 때문에,모든 트랜잭션 커밋 시마다 디스크의 데이터를 flush 할 필요 없다. 또한 WAL을 사용하면 디스크 쓰기 횟수가 현저히 줄어든다. 트랜잭션에 의해 변경된 모든 데이터 파일을 write 하는 것이 아니라 WAL 파일만 디스크에 flush 하면 트랜잭션이 커밋되기 때문이다. WAL은 순차적으로 작성되기 때문에 WAL 동기화 비용은 데이터 페이지를 flush 하는 것보다 코스트가 훨씬 적다. (특히 데이터베이스가 여러 군데의 작은 트랜잭션을 처리할 때 효율적이다.) 2. 장점 WAL은 온라인 백업 및 특정 시점 복구(PIT, point-in-time)를 지원 (WAL 데이터를 보관함으로써 사용가능한 WAL 데이터에 포함된 어떠한 순간으로도 롤백이 가능) 복원에 필요한 WAL 파일의 수량 제한이 없기에 백업을 시작한 시점 이후의 WAL 로그파일만 존재한다면 백업기간이 아무리 길더라도 복원이 가능 운영 서버의 WAL 파일을 주기적으로 백업해 놓는다면 운영 서버 장애 발생 시 빠르게 복구가 가능 3. 단점 특정 데이터베이스만을 대상 불가능, 전체 데이터베이스를 대상으로 진행 WAL 로그를 충분히 저장할 디스크 여유 공간 필요 대량의 데이터를 처리할때 WAL write 코스트 증가 4. 설정 $PGDATA의 postgresql.conf 파일 내의 파라미터를 통해 상세 설정 가능\n4-1. wal_level (Enum) WAL 레코드 정보의 양을 결정한다. 디폴트 값은 minimal이다.\nminimal - 충돌 또는 즉시 셧다운으로부터 복구하기 위한 최소한의 정보 archive - WAL 아카이브에 필요한 로깅 추가 hot_standby - 대기 서버에서 읽기전용 쿼리에 필요한 정보 추가 4-2. archive_mode (Boolean) archive_mode를 선택하면 완료된 WAL 세그먼트가 아카이브 저장소에 저장 (wal_level이 minimum인 경우 사용 불가)\n4-3. archive_command (String) 완료된 WAL 파일 세그먼트를 아카이빙 할 때 실행하는 쉘 명령어\n참고\nhttps://www.postgresql.org/docs/16/wal-intro.html\nhttps://postgresql.kr/docs/13/continuous-archiving.html#BACKUP-PITR-RECOVERY ","wordCount":"301","inLanguage":"en","datePublished":"2024-02-26T18:04:32Z","dateModified":"2024-02-26T18:04:32Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/66/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점</h1><div class=post-meta><span title='2024-02-26 18:04:32 +0000 UTC'>February 26, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/66/img.png></p><h2 id=wal-write-ahead-logging-아카이브-모드-백업archive-mode-backup이란 ke-size=size26>1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?<a hidden class=anchor aria-hidden=true href=#wal-write-ahead-logging-아카이브-모드-백업archive-mode-backup이란>#</a></h2><p>아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 </p><p>충돌이 발생할 때마다 Log를 통해 데이터베이스를 복구할 수 있기 때문에,모든 트랜잭션 커밋 시마다 디스크의 데이터를 flush 할 필요 없다.  또한 WAL을 사용하면 디스크 쓰기 횟수가 현저히 줄어든다. 트랜잭션에 의해 변경된 모든 데이터 파일을 write 하는 것이 아니라 WAL 파일만 디스크에 flush 하면 트랜잭션이 커밋되기 때문이다. WAL은 순차적으로 작성되기 때문에 WAL 동기화 비용은 데이터 페이지를 flush 하는 것보다 코스트가 훨씬 적다. (특히 데이터베이스가 여러 군데의 작은 트랜잭션을 처리할 때 효율적이다.) </p><h2 id=장점 ke-size=size26>2. 장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h2><ul><li>WAL은 온라인 백업 및 특정 시점 복구(PIT, point-in-time)를 지원 (WAL 데이터를 보관함으로써 사용가능한 WAL 데이터에 포함된 어떠한 순간으로도 롤백이 가능)</li><li>복원에 필요한 WAL 파일의 수량 제한이 없기에 백업을 시작한 시점 이후의 WAL 로그파일만 존재한다면 백업기간이 아무리 길더라도 복원이 가능</li><li>운영 서버의 WAL 파일을 주기적으로 백업해 놓는다면 운영 서버 장애 발생 시 빠르게 복구가 가능</li></ul><h2 id=단점 ke-size=size26>3. 단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h2><ul><li>특정 데이터베이스만을 대상 불가능, 전체 데이터베이스를 대상으로 진행</li><li>WAL 로그를 충분히 저장할 디스크 여유 공간 필요</li><li>대량의 데이터를 처리할때 WAL write 코스트 증가</li></ul><h2 id=설정 ke-size=size26>4. 설정<a hidden class=anchor aria-hidden=true href=#설정>#</a></h2><p>$PGDATA의 postgresql.conf 파일 내의 파라미터를 통해 상세 설정 가능</p><h4 id=wal_level-enum ke-size=size20>4-1. wal_level (Enum)<a hidden class=anchor aria-hidden=true href=#wal_level-enum>#</a></h4><p>WAL 레코드 정보의 양을 결정한다. 디폴트 값은 minimal이다.</p><ul><li><strong>minimal -</strong> 충돌 또는 즉시 셧다운으로부터 복구하기 위한 최소한의 정보 </li><li><strong>archive -</strong> WAL 아카이브에 필요한 로깅 추가</li><li><strong>hot_standby -</strong> 대기 서버에서 읽기전용 쿼리에 필요한 정보 추가</li></ul><h4 id=archive_mode-boolean ke-size=size20>4-2. archive_mode (Boolean)<a hidden class=anchor aria-hidden=true href=#archive_mode-boolean>#</a></h4><p>archive_mode를 선택하면 완료된 WAL 세그먼트가 아카이브 저장소에 저장 (wal_level이 minimum인 경우 사용 불가)</p><h4 id=archive_command-string ke-size=size20>4-3. archive_command (String)<a hidden class=anchor aria-hidden=true href=#archive_command-string>#</a></h4><p>완료된 WAL 파일 세그먼트를 아카이빙 할 때 실행하는 쉘 명령어</p><p>참고</p><ul><li><p><a href=https://www.postgresql.org/docs/16/wal-intro.html>https://www.postgresql.org/docs/16/wal-intro.html</a></p></li><li><p><a href=https://postgresql.kr/docs/13/continuous-archiving.html#BACKUP-PITR-RECOVERY>https://postgresql.kr/docs/13/continuous-archiving.html#BACKUP-PITR-RECOVERY</a>
 </p></li></ul><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/wal/>Wal</a></li><li><a href=https://junhkang.com/tags/postgresql/>PostgreSQL</a></li><li><a href=https://junhkang.com/tags/%EC%95%84%EC%B9%B4%EC%9D%B4%EB%B8%8C/>아카이브</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>