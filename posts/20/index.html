<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용 | Jun Kang's Blog</title>
<meta name=keywords content="Transaction,Lock,PostgreSQL"><meta name=description content="

1. 트랜잭션(Transaction)이란?
트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.
2. 트랜잭션 적용
트랜잭션을 사용하는 커맨드 예제이다.
--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
COMMIT;
트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)"><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/posts/20/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/20/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/20/"><meta property="og:title" content="[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용 | Jun Kang's Blog"><meta property="og:description" content="

1. 트랜잭션(Transaction)이란?
트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.
2. 트랜잭션 적용
트랜잭션을 사용하는 커맨드 예제이다.
--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
COMMIT;
트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)"><meta property="og:image" content="http://localhost:1313/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="http://localhost:1313/posts/20/"><meta property="twitter:title" content="[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용 | Jun Kang's Blog"><meta property="twitter:description" content="

1. 트랜잭션(Transaction)이란?
트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.
2. 트랜잭션 적용
트랜잭션을 사용하는 커맨드 예제이다.
--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
COMMIT;
트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)"><meta property="twitter:image" content="http://localhost:1313/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="http://localhost:1313/posts/20/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용"><meta property="og:description" content=" 1. 트랜잭션(Transaction)이란? 트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.
2. 트랜잭션 적용 트랜잭션을 사용하는 커맨드 예제이다.
--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다. BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; COMMIT; 트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-10T14:42:53+00:00"><meta property="article:modified_time" content="2023-10-10T14:42:53+00:00"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Lock"><meta property="article:tag" content="PostgreSQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용"><meta name=twitter:description content="

1. 트랜잭션(Transaction)이란?
트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.
2. 트랜잭션 적용
트랜잭션을 사용하는 커맨드 예제이다.
--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
COMMIT;
트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용","item":"http://localhost:1313/posts/20/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용","name":"[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용","description":" 1. 트랜잭션(Transaction)이란? 트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.\n2. 트랜잭션 적용 트랜잭션을 사용하는 커맨드 예제이다.\n--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다. BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = \u0026#39;Alice\u0026#39;; COMMIT; 트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)\n","keywords":["Transaction","Lock","PostgreSQL"],"articleBody":" 1. 트랜잭션(Transaction)이란? 트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.\n2. 트랜잭션 적용 트랜잭션을 사용하는 커맨드 예제이다.\n--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다. BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; COMMIT; 트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)\n[PostgreSQL] Postgresql Lock이란? (조회 및 kill, Dead lock)\nPostgreSQL에서는 모든 SQL 구문이 트랜잭션 안에서 실행되며, BEGIN을 명시적으로 실행하지 않아도 SQL 명령어를 실행시키면 BIGIN이 되었다고 간주한다. Postgresql의 툴로 사용하는 PgAdmin, Dbeaver, DataGrip 등의 툴에는 각각 트랜잭션을 Manual or Auto로 설정할 수 있다. Manual의 경우 트랜잭션을 commit, rollback을 명시적으로 선언해주지 않을 경우 트랜잭션이 계속 유지되며, Auto의 경우 명시적으로 선언하지 않아도 SQL이 성공적으로 실행된 후 즉시 commit이 실행된 것으로 간주한다.\n3. 트랜잭션의 4가지 특성 3-1. 원자성 Atomic 작업이 최종적으로는 하나로 취급된다. 동일 트랜잭션 내의 작업은 전부 취소 혹은 전부 작업된다. 트랜잭션 내의 작업에 오류가 발생하면 해당 트랜잭션 내의 모든 작업이 취소된다. 3-2. 내구성 durability 트랜잭션이 정상적으로 끝났을 경우, 변경완료된 자료에는 어떠한 간섭도 없이 저장되어야 하고, 손상이 되면 안 된다. 트랜잭션 완료까지 간섭을 없애기 위해, 데이터베이스에서는 트랜잭션이 정상종료됨을 전달받기 전에 트랜잭션에서 발생하는 모든 작업들을 영구저장장치(예, 하드디스크)에 기록해 둔다. 3-3. 고립성 isolation 트랜잭션은 다른 트랜잭션에 의해 간섭받지 않아야 한다. 여러 개의 트랜잭션 발생 시, 각각의 트랜잭션은 다른 트랜잭션의 변경 중인 데이터를 참조, 간섭할 수 없어야 한다. 3-4. 정합성 consistency 트랜잭션은 각강의 명령을 데이터베이스 원데이터에 영향을 주는 것이 아니라 트랜잭션 영역 안에 있는 모든 작업이 끝났을 때, 한 번에 그 변경사항이 데이터베이스에 적용된다. 4. SAVEPOINT 성공/실패에 따라 트랜잭션 내의 작업은 일괄 처리되지만 SAVEPOINT 명령을 사용하여 부분 커밋을 하여 좀 더 유연하게 처리가 가능하다.\nsavepoint로 취소작업을 진행한 뒤에도 트랜잭션 내 작업을 계속 진행할 수 있다. savepoint가 필요 없다고 판단될 시 삭제하여 시스템 자원을 늘릴 수 있다. savepoint로 돌아갈 경우 그지점 이후의 savepoint들도 모두 롤백된다. BEGIN; UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice'; SAVEPOINT my_savepoint; UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob'; ROLLBACK TO my_savepoint; UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Wally'; COMMIT; 참고 https://www.postgresql.kr/docs/9.6/tutorial-transactions.html ","wordCount":"382","inLanguage":"en","datePublished":"2023-10-10T14:42:53Z","dateModified":"2023-10-10T14:42:53Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/20/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용</h1><div class=post-meta><span title='2023-10-10 14:42:53 +0000 UTC'>October 10, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/20/img.png></p><h2 id=트랜잭션transaction이란 ke-size=size26>1. 트랜잭션(Transaction)이란?<a hidden class=anchor aria-hidden=true href=#트랜잭션transaction이란>#</a></h2><p>트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.</p><h2 id=트랜잭션-적용 ke-size=size26>2. 트랜잭션 적용<a hidden class=anchor aria-hidden=true href=#트랜잭션-적용>#</a></h2><p>트랜잭션을 사용하는 커맨드 예제이다.</p><pre tabindex=0><code>--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = &#39;Alice&#39;;
COMMIT;
</code></pre><p>트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)</p><p><a href=https://junhkang.tistory.com/4>[PostgreSQL] Postgresql Lock이란? (조회 및 kill, Dead lock)</a></p><blockquote><p>PostgreSQL에서는 모든 SQL 구문이 트랜잭션 안에서 실행되며, BEGIN을 명시적으로 실행하지 않아도 SQL 명령어를 실행시키면  BIGIN이 되었다고 간주한다. Postgresql의 툴로 사용하는 PgAdmin, Dbeaver, DataGrip 등의 툴에는 각각 트랜잭션을 Manual or Auto로 설정할 수 있다. Manual의 경우 트랜잭션을 commit, rollback을 명시적으로 선언해주지 않을 경우 트랜잭션이 계속 유지되며, Auto의 경우 명시적으로 선언하지 않아도 SQL이 성공적으로 실행된 후 즉시 commit이 실행된 것으로 간주한다.</p></blockquote><h2 id=트랜잭션의-4가지-특성 ke-size=size26>3. 트랜잭션의 4가지 특성<a hidden class=anchor aria-hidden=true href=#트랜잭션의-4가지-특성>#</a></h2><h3 id=원자성-atomic ke-size=size23>     3-1. 원자성 Atomic<a hidden class=anchor aria-hidden=true href=#원자성-atomic>#</a></h3><ul><li>작업이 최종적으로는 하나로 취급된다.</li><li>동일 트랜잭션 내의 작업은 전부 취소 혹은 전부 작업된다.</li><li>트랜잭션 내의 작업에 오류가 발생하면 해당 트랜잭션 내의 모든 작업이 취소된다. </li></ul><h3 id=내구성-durability ke-size=size23>    3-2. 내구성 durability<a hidden class=anchor aria-hidden=true href=#내구성-durability>#</a></h3><ul><li>트랜잭션이 정상적으로 끝났을 경우, 변경완료된 자료에는 어떠한 간섭도 없이 저장되어야 하고, 손상이 되면 안 된다.</li><li>트랜잭션 완료까지 간섭을 없애기 위해, 데이터베이스에서는 트랜잭션이 정상종료됨을 전달받기 전에 트랜잭션에서 발생하는 모든 작업들을 영구저장장치(예, 하드디스크)에 기록해 둔다.</li></ul><h3 id=고립성-isolation ke-size=size23>     3-3. 고립성 isolation<a hidden class=anchor aria-hidden=true href=#고립성-isolation>#</a></h3><ul><li>트랜잭션은 다른 트랜잭션에 의해 간섭받지 않아야 한다.</li><li>여러 개의 트랜잭션 발생 시, 각각의 트랜잭션은 다른 트랜잭션의 변경 중인 데이터를 참조, 간섭할 수 없어야 한다.</li></ul><h3 id=정합성-consistency ke-size=size23>    3-4. 정합성 consistency<a hidden class=anchor aria-hidden=true href=#정합성-consistency>#</a></h3><ul><li>트랜잭션은 각강의 명령을 데이터베이스 원데이터에 영향을 주는 것이 아니라 트랜잭션 영역 안에 있는 모든 작업이 끝났을 때, 한 번에 그 변경사항이 데이터베이스에 적용된다.</li></ul><h2 id=savepoint ke-size=size26>4. SAVEPOINT<a hidden class=anchor aria-hidden=true href=#savepoint>#</a></h2><p>성공/실패에 따라  트랜잭션 내의 작업은 일괄 처리되지만 SAVEPOINT 명령을 사용하여 부분 커밋을 하여 좀 더 유연하게 처리가 가능하다.</p><ul><li>savepoint로 취소작업을 진행한 뒤에도 트랜잭션 내 작업을 계속 진행할 수 있다.</li><li>savepoint가 필요 없다고 판단될 시 삭제하여 시스템 자원을 늘릴 수 있다.</li><li>savepoint로 돌아갈 경우 그지점 이후의 savepoint들도 모두 롤백된다.</li></ul><pre tabindex=0><code>BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = &#39;Alice&#39;;
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = &#39;Bob&#39;;
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = &#39;Wally&#39;;
COMMIT;
</code></pre><p> </p><p>참고 </p><ul><li><a href=https://www.postgresql.kr/docs/9.6/tutorial-transactions.html>https://www.postgresql.kr/docs/9.6/tutorial-transactions.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/transaction/>Transaction</a></li><li><a href=http://localhost:1313/tags/lock/>Lock</a></li><li><a href=http://localhost:1313/tags/postgresql/>PostgreSQL</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>