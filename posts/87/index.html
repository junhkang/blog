<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=50666&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용 | Jun Kang's Blog</title>
<meta name=keywords content="디자인패턴,Strategy"><meta name=description content='
1. 전략(Strategy) 패턴이란?
Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다.
 
모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.
2. 전략(Strategy) 패턴의 구조
전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.'><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:50666/posts/87/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:50666/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:50666/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:50666/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:50666/apple-touch-icon.png><link rel=mask-icon href=http://localhost:50666/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:50666/posts/87/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:50666/posts/87/"><meta property="og:title" content="[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용 | Jun Kang's Blog"><meta property="og:description" content='
1. 전략(Strategy) 패턴이란?
Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다.
 
모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.
2. 전략(Strategy) 패턴의 구조
전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.'><meta property="og:image" content="http://localhost:50666/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="http://localhost:50666/posts/87/"><meta property="twitter:title" content="[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용 | Jun Kang's Blog"><meta property="twitter:description" content='
1. 전략(Strategy) 패턴이란?
Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다.
 
모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.
2. 전략(Strategy) 패턴의 구조
전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.'><meta property="twitter:image" content="http://localhost:50666/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="http://localhost:50666/posts/87/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용"><meta property="og:description" content=' 1. 전략(Strategy) 패턴이란? Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다. 모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.
2. 전략(Strategy) 패턴의 구조 전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-12T15:42:02+00:00"><meta property="article:modified_time" content="2024-04-12T15:42:02+00:00"><meta property="article:tag" content="디자인패턴"><meta property="article:tag" content="Strategy"><meta name=twitter:card content="summary"><meta name=twitter:title content="[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용"><meta name=twitter:description content='
1. 전략(Strategy) 패턴이란?
Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다.
 
모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.
2. 전략(Strategy) 패턴의 구조
전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:50666/posts/"},{"@type":"ListItem","position":2,"name":"[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용","item":"http://localhost:50666/posts/87/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용","name":"[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용","description":" 1. 전략(Strategy) 패턴이란? Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 \u0026quot;알고리즘\u0026quot;을 의미한다. 모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.\n2. 전략(Strategy) 패턴의 구조 전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.\n","keywords":["디자인패턴","Strategy"],"articleBody":" 1. 전략(Strategy) 패턴이란? Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 \"알고리즘\"을 의미한다. 모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.\n2. 전략(Strategy) 패턴의 구조 전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.\nStrategy(전략) - 전략을 사용하기 위한 인터페이스를 결정 (예제의 Strategy 인터페이스) ConcreteStrategy(구체적인 전략) - 인터페이스를 실제로 구현, 예제의 WinningStrategy, ProbStrategy 클래스 Context(문맥) - Strategy를 직접사용, ConcreteStrategy의 인스턴스를 가지고 있다가 필요에 따라 사용 (예제의 Player) 3. 예제 (가위 바위 보 게임) 책에서는 컴퓨터로 가위바위보 하는 프로그램을 예제로 들고 있다. 3-1. 구조 3-1-1. 전략\nWinningStrategy - 이기면 다음에도 같은 손을 내는 방식 ProbStrategy - 직전 손에서 다음손을 확률적으로 계산하는 방식 3-1-2. 클래스, 인스턴스\nHand - 가위바위보를 내는 손 클래스 Strategy - 가위바위보 전략 인터페이스 WinningStrategy - 이기면 같은 걸 내는 전략을 타나는 클래스 ProbStrategy - 직전손에서 다음손을 확률적으로 계산하는 클래스 Player - 가위바위보를 하는 플레이어 클래스 3-2. Hand enum 가위바위보를 어떤 걸 내는지를 나타나는 Hand 클래스부터 살펴보자\npublic enum Hand { // 가위 바위 보를 나타내는 세 개의 enum 상수 ROCK(\"바위\", 0), SCISSORS(\"가위\", 1), PAPER(\"보\", 2); // enum이 가진 필드 private String name; // 가위 바위 보 손의 이름 private int handvalue; // 가위 바위 보 손의 값 // 손의 값으로 상수를 얻기 위한 배열 private static Hand[] hands = { ROCK, SCISSORS, PAPER }; // 생성자 private Hand(String name, int handvalue) { this.name = name; this.handvalue = handvalue; } // 손의 값으로 enum 상수를 가져온다 public static Hand getHand(int handvalue) { return hands[handvalue]; } // this가 h보다 강할 때 true public boolean isStrongerThan(Hand h) { return fight(h) == 1; } // this가 h보다 약할 때 true public boolean isWeakerThan(Hand h) { return fight(h) == -1; } // 무승부는 0, this가 이기면 1, h가 이기면 -1 private int fight(Hand h) { if (this == h) { return 0; } else if ((this.handvalue + 1) % 3 == h.handvalue) { return 1; } else { return -1; } } // 가위 바위 보의 문자열 표현 @Override public String toString() { return name; } } Hand - 가위/바위/보를 내는 손 자체를 나타내는 enum으로 각 행위를 enum 상수로 나타내고 getHand 메서드를 사용하여 Hand의 인스턴스를 얻을 수 있다. 예를 들어 가위 바위 보(0,1,2)를 각각 인수로 주면 값에 대응하는 인스턴스가 반환된다. isStrongerThan, isWeakerThan - Hand형인 두 손 객체의 강약을 비교한다. fight - 실제 손의 강약 판정한다. 예제에서는 두 손의 합으로 승패를 구분하는데, 가위 바위 보 가 각각 0/1/2 이기에 합을 3으로 나눈 값을 기준으로 승패를 판별할 수 있다. 3-3. Strategy 인터페이스 가위바위보 전략을 위한 추상 메서드의 집합체이다.\npublic interface Strategy { public abstract Hand nextHand(); public abstract void study(boolean win); } nextHand - 다음에 낼 손을 얻기 위한 메서드 study - 직전에 맨손으로 이겼는지 졌는지를 학습하는 메서드 직전 nextHand 메서드 호출에서 이긴 경우 study(true), 지면 study(false)를 각각 호출한다. 이에 따라 Strategy 인터페이스를 구현하는 클래스는 자신의 내부상태를 변화시키고 \b다음에 낼 nextHand의 반환 값을 결정한다.\n3-4. WinningStrategy 클래스 Strategy 인터페이스를 구현하는 클래스 중 하나로 nextHand, study 두 메서드를 구현한다.\npublic class WinningStrategy implements Strategy { private Random random; private boolean won = false; private Hand prevHand; public WinningStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { if (!won) { prevHand = Hand.getHand(random.nextInt(3)); } return prevHand; } @Override public void study(boolean win) { won = win; } } 이 클래스는 이전 승부가 이겼다면 다음번에 같은 걸 다시 내는 전략을 구현한 클래스이다. 만약 승부에 졌다면 다음은 랜덤 하게 낸다. won필드에는 이전 승부의 결과를 보관하며 이기면 true, 지면 false가 된다. preHand필드에는 이전 승부에서 낸 손 보관한다.\n3-5. ProbStrategy 클래스 Strategy 인터페이스를 구현하는 또 하나의 구체적인 전략 클래스로, nextHand, study 두 메서드를 구현한다.\npublic class ProbStrategy implements Strategy { private Random random; private int prevHandValue = 0; private int currentHandValue = 0; private int[][] history = { { 1, 1, 1, }, { 1, 1, 1, }, { 1, 1, 1, }, }; public ProbStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { int bet = random.nextInt(getSum(currentHandValue)); int handvalue = 0; if (bet \u003c history[currentHandValue][0]) { handvalue = 0; } else if (bet \u003c history[currentHandValue][0] + history[currentHandValue][1]) { handvalue = 1; } else { handvalue = 2; } prevHandValue = currentHandValue; currentHandValue = handvalue; return Hand.getHand(handvalue); } private int getSum(int handvalue) { int sum = 0; for (int i = 0; i \u003c 3; i++) { sum += history[handvalue][i]; } return sum; } @Override public void study(boolean win) { if (win) { history[prevHandValue][currentHandValue]++; } else { history[prevHandValue][(currentHandValue + 1) % 3]++; history[prevHandValue][(currentHandValue + 2) % 3]++; } } } 다음에 낼 손을 난수로 결정하고, 과거의 이기고 진 이력을 활용해서 확률을 바꾸는 전략을 구현한 클래스이다.\nhistory 필드는 과거 승패를 반영한 확률 계산을 위한 2차원 배열이다.\nhistory [직전에 낸 손] [이번에 낼 손] = 승리한 횟수\\\nex) history [0][1] - 바위, 바위를 냈을 때 승수 history [0][0]- 바위, 가위를 냈을 때 승수 ...\n즉, 직전에 바위를 냈다면 history [0]의 배열의 승수를 비율을 통해 서로 다른 비율로 손을 결정한다. 예를 들어 처음 바위를 냈을 때 이긴 승수가 다음과 같다면\nhistory [0][0] = 3\nhistory [0][1] = 2 history [0][2] = 5 전체 승수 10 대비 각 손을 냈을 때의 승률을 기준으로 다음 손을 결정한다. (ex. 바위를 다시 낼 확률 = 3/10)\n3-6. Player 클래스 가위바위보를 하는 사람을 나타내는 클래스로 이름과 전략으로 인스턴스가 생성된다.\npublic class Player { private String name; private Strategy strategy; private int wincount; private int losecount; private int gamecount; // 이름과 전략을 받아서 플레이어를 만든다 public Player(String name, Strategy strategy) { this.name = name; this.strategy = strategy; } // 전략에 따라 다음 손을 결정한다 public Hand nextHand() { return strategy.nextHand(); } // 승리 public void win() { strategy.study(true); wincount++; gamecount++; } // 패배 public void lose() { strategy.study(false); losecount++; gamecount++; } // 무승부 public void even() { gamecount++; } @Override public String toString() { return \"[ + name + \": + gamecount + \" games, + wincount + \" win, + losecount + \" lose + \"]\"; } } nextHand메서드는 자신의 전략을 Strategy에 위임하고 있다. 승부 결과를 다음 승부에 활용하고자 Strategy필드를 통해 study메서드를 호출하고, study 메서드로 전략의 내부상태를 변화시킨다.\n3-7. Main 이제 실제 다른 전략의 플레이들로 가위바위보를 하는 메인 클래스를 생성해 보자\npublic class Main { public static void main(String[] args) { if (args.length != 2) { System.out.println(\"Usage: java Main randomseed1 randomseed2\"); System.out.println(\"Example: java Main 314 15\"); System.exit(0); } int seed1 = Integer.parseInt(args[0]); int seed2 = Integer.parseInt(args[1]); Player player1 = new Player(\"KIM\", new WinningStrategy(seed1)); Player player2 = new Player(\"LEE\", new ProbStrategy(seed2)); for (int i = 0; i \u003c 10000; i++) { Hand nextHand1 = player1.nextHand(); Hand nextHand2 = player2.nextHand(); if (nextHand1.isStrongerThan(nextHand2)) { System.out.println(\"Winner:\" + player1); player1.win(); player2.lose(); } else if (nextHand2.isStrongerThan(nextHand1)) { System.out.println(\"Winner:\" + player2); player1.lose(); player2.win(); } else { System.out.println(\"Even...\"); player1.even(); player2.even(); } } System.out.println(\"Total result:\"); System.out.println(player1); System.out.println(player2); } } 두 명의 플레이어를 각각 다른 Strategy 구현체로 생성한 후 서로 가위바위보를 시키는 클래스이다.\n4. Strategy(전략) 패턴의 장점 및 정리 Strategy 패턴은 알고리즘을 다른 부분과 의도적으로 분리한다. 얼핏 보면 불필요하고 복잡한 구조를 오히려 만드는 것 같지만 그렇지 않다.\n인터페이스만 정의하고 위임을 통해 약한 결합으로 알고리즘을 사용하기에 알고리즘을 용이하게 전환할 수 있고, 알고리즘을 변경해야 하는 경우 ConcreteStrategy만 수정하면 된다. 또한 전략패턴을 사용 시 프로그램을 실행 중에 ConcreteStrategy 역을 전환할 수도 있다. 전략을 캡슐화하고 이를 사용하는 콘텍스트에서 독립적으로 전략을 변경해 줄 수 있기 때문이고, 실행 중인 애플리케이션 내에서 사용자 선택이나 조건에 따라 정렬방식/암호화/난수생성 등의 전략을 바꿀 수 있기 때문에 유연성과 확장성이 올라간다. 참고 : JAVA 언어로 배우는 디자인 패턴 입문 3편\n상세 예제소스는 깃허브에서 확인가능\nhttps://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/strategy\n","wordCount":"1244","inLanguage":"en","datePublished":"2024-04-12T15:42:02Z","dateModified":"2024-04-12T15:42:02Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:50666/posts/87/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:50666/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:50666/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:50666/about/ title=About><span>About</span></a></li><li><a href=http://localhost:50666/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:50666/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:50666/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:50666/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:50666/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:50666/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용</h1><div class=post-meta><span title='2024-04-12 15:42:02 +0000 UTC'>April 12, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=전략strategy-패턴이란 ke-size=size26>1. 전략(Strategy) 패턴이란?<a hidden class=anchor aria-hidden=true href=#전략strategy-패턴이란>#</a></h2><p>Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 "알고리즘"을 의미한다.
 </p><p>모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.</p><h2 id=전략strategy-패턴의-구조 ke-size=size26>2. 전략(Strategy) 패턴의 구조<a hidden class=anchor aria-hidden=true href=#전략strategy-패턴의-구조>#</a></h2><p>전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.</p><p><img loading=lazy src=/images/posts/87/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-12%20%EC%98%A4%ED%9B%84%202.56.27.png></p><ul><li><strong>Strategy(전략) -</strong> 전략을 사용하기 위한 인터페이스를 결정 (예제의 Strategy 인터페이스)</li><li><strong>ConcreteStrategy(구체적인 전략) -</strong> 인터페이스를 실제로 구현, 예제의 WinningStrategy, ProbStrategy 클래스 </li><li><strong>Context(문맥) -</strong> Strategy를 직접사용, ConcreteStrategy의 인스턴스를 가지고 있다가 필요에 따라 사용 (예제의 Player)</li></ul><h2 id=예제-가위-바위-보-게임 ke-size=size26>3. 예제 (가위 바위 보 게임)<a hidden class=anchor aria-hidden=true href=#예제-가위-바위-보-게임>#</a></h2><p>책에서는 컴퓨터로 가위바위보 하는 프로그램을 예제로 들고 있다. </p><h3 id=구조 ke-size=size23>3-1. 구조<a hidden class=anchor aria-hidden=true href=#구조>#</a></h3><p>3-1-1. 전략</p><ul><li>WinningStrategy - 이기면 다음에도 같은 손을 내는 방식</li><li>ProbStrategy - 직전 손에서 다음손을 확률적으로 계산하는 방식</li></ul><p>3-1-2. 클래스, 인스턴스</p><ul><li>Hand - 가위바위보를 내는 손 클래스</li><li>Strategy - 가위바위보 전략 인터페이스</li><li>WinningStrategy - 이기면 같은 걸 내는 전략을 타나는 클래스</li><li>ProbStrategy - 직전손에서 다음손을 확률적으로 계산하는 클래스</li><li>Player - 가위바위보를 하는 플레이어 클래스</li></ul><h3 id=hand-enum ke-size=size23>3-2. Hand enum<a hidden class=anchor aria-hidden=true href=#hand-enum>#</a></h3><p>가위바위보를 어떤 걸 내는지를 나타나는 Hand 클래스부터 살펴보자</p><pre tabindex=0><code>public enum Hand {
    // 가위 바위 보를 나타내는 세 개의 enum 상수
    ROCK(&#34;바위&#34;, 0),
    SCISSORS(&#34;가위&#34;, 1),
    PAPER(&#34;보&#34;, 2);

    // enum이 가진 필드 
    private String name; // 가위 바위 보 손의 이름
    private int handvalue; // 가위 바위 보 손의 값 

    // 손의 값으로 상수를 얻기 위한 배열
    private static Hand[] hands = {
        ROCK, SCISSORS, PAPER
    };

    // 생성자 
    private Hand(String name, int handvalue) {
        this.name = name;
        this.handvalue = handvalue;
    }

    // 손의 값으로 enum 상수를 가져온다 
    public static Hand getHand(int handvalue) {
        return hands[handvalue];
    }

    // this가 h보다 강할 때 true
    public boolean isStrongerThan(Hand h) {
        return fight(h) == 1;
    }

    // this가 h보다 약할 때 true
    public boolean isWeakerThan(Hand h) {
        return fight(h) == -1;
    }

    // 무승부는 0, this가 이기면 1, h가 이기면 -1
    private int fight(Hand h) {
        if (this == h) {
            return 0;
        } else if ((this.handvalue + 1) % 3 == h.handvalue) {
            return 1;
        } else {
            return -1;
        }
    }

    // 가위 바위 보의 문자열 표현
    @Override
    public String toString() {
        return name;
    }
}
</code></pre><ul><li><strong>Hand -</strong> 가위/바위/보를 내는 손 자체를 나타내는 enum으로 각 행위를 enum 상수로 나타내고 getHand 메서드를 사용하여 Hand의 인스턴스를 얻을 수 있다. 예를 들어 가위 바위 보(0,1,2)를 각각 인수로 주면 값에 대응하는 인스턴스가 반환된다.</li><li><strong>isStrongerThan, isWeakerThan -</strong>  Hand형인 두 손 객체의 강약을 비교한다.</li><li><strong>fight -</strong> 실제 손의 강약 판정한다. 예제에서는 두 손의 합으로 승패를 구분하는데, 가위 바위 보 가 각각 0/1/2 이기에 합을 3으로 나눈 값을 기준으로 승패를 판별할 수 있다.</li></ul><h3 id=strategy-인터페이스 ke-size=size23>3-3. Strategy 인터페이스<a hidden class=anchor aria-hidden=true href=#strategy-인터페이스>#</a></h3><p>가위바위보 전략을 위한 추상 메서드의 집합체이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Strategy</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> Hand <span style=color:#a6e22e>nextHand</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>study</span>(<span style=color:#66d9ef>boolean</span> win);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>nextHand - 다음에 낼 손을 얻기 위한 메서드</li><li>study - 직전에 맨손으로 이겼는지 졌는지를 학습하는 메서드</li></ul><p>직전 nextHand 메서드 호출에서 이긴 경우 study(true), 지면 study(false)를 각각 호출한다. 이에 따라 Strategy 인터페이스를 구현하는 클래스는 자신의 내부상태를 변화시키고 다음에 낼 nextHand의 반환 값을 결정한다.</p><h3 id=winningstrategy-클래스 ke-size=size23>3-4. WinningStrategy 클래스<a hidden class=anchor aria-hidden=true href=#winningstrategy-클래스>#</a></h3><p>Strategy 인터페이스를 구현하는 클래스 중 하나로 nextHand, study 두 메서드를 구현한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WinningStrategy</span> <span style=color:#66d9ef>implements</span> Strategy {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Random random;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> won <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Hand prevHand;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>WinningStrategy</span>(<span style=color:#66d9ef>int</span> seed) {
</span></span><span style=display:flex><span>        random <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random(seed);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Hand <span style=color:#a6e22e>nextHand</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>won) {
</span></span><span style=display:flex><span>            prevHand <span style=color:#f92672>=</span> Hand.<span style=color:#a6e22e>getHand</span>(random.<span style=color:#a6e22e>nextInt</span>(3));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prevHand;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>study</span>(<span style=color:#66d9ef>boolean</span> win) {
</span></span><span style=display:flex><span>        won <span style=color:#f92672>=</span> win;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 클래스는 이전 승부가 이겼다면 다음번에 같은 걸 다시 내는 전략을 구현한 클래스이다. 만약 승부에 졌다면 다음은 랜덤 하게 낸다. won필드에는 이전 승부의 결과를 보관하며 이기면 true, 지면 false가 된다. preHand필드에는 이전 승부에서 낸 손 보관한다.</p><h3 id=probstrategy-클래스 ke-size=size23>3-5. ProbStrategy 클래스<a hidden class=anchor aria-hidden=true href=#probstrategy-클래스>#</a></h3><p>Strategy 인터페이스를 구현하는 또 하나의 구체적인 전략 클래스로, nextHand, study 두 메서드를 구현한다.</p><pre tabindex=0><code class=language-angelscript data-lang=angelscript>public class ProbStrategy implements Strategy {
    private Random random;
    private int prevHandValue = 0;
    private int currentHandValue = 0;
    private int[][] history = {
        { 1, 1, 1, },
        { 1, 1, 1, },
        { 1, 1, 1, },
    };

    public ProbStrategy(int seed) {
        random = new Random(seed);
    }

    @Override
    public Hand nextHand() {
        int bet = random.nextInt(getSum(currentHandValue));
        int handvalue = 0;
        if (bet &lt; history[currentHandValue][0]) {
            handvalue = 0;
        } else if (bet &lt; history[currentHandValue][0] + history[currentHandValue][1]) {
            handvalue = 1;
        } else {
            handvalue = 2;
        }
        prevHandValue = currentHandValue;
        currentHandValue = handvalue;
        return Hand.getHand(handvalue);
    }

    private int getSum(int handvalue) {
        int sum = 0;
        for (int i = 0; i &lt; 3; i++) {
            sum += history[handvalue][i];
        }
        return sum;
    }

    @Override
    public void study(boolean win) {
        if (win) {
            history[prevHandValue][currentHandValue]++;
        } else {
            history[prevHandValue][(currentHandValue + 1) % 3]++;
            history[prevHandValue][(currentHandValue + 2) % 3]++;
        }
    }
}
</code></pre><p>다음에 낼 손을 난수로 결정하고, 과거의 이기고 진 이력을 활용해서 확률을 바꾸는 전략을 구현한 클래스이다.</p><p>history 필드는 과거 승패를 반영한 확률 계산을 위한 2차원 배열이다.</p><blockquote><p>history [직전에 낸 손] [이번에 낼 손] = 승리한 횟수\</p><p>ex)
history [0][1] - 바위, 바위를 냈을 때 승수
history [0][0]- 바위, 가위를 냈을 때 승수
...</p></blockquote><p>즉, 직전에 바위를 냈다면 history [0]의 배열의 승수를 비율을 통해 서로 다른 비율로 손을 결정한다. 예를 들어 처음 바위를 냈을 때 이긴 승수가 다음과 같다면</p><blockquote><p>history [0][0] = 3<br>history [0][1] = 2
history [0][2] = 5
 </p></blockquote><p>전체 승수 10 대비 각 손을 냈을 때의 승률을 기준으로 다음 손을 결정한다. (ex. 바위를 다시 낼 확률 = 3/10)</p><h3 id=player-클래스 ke-size=size23>3-6. Player 클래스<a hidden class=anchor aria-hidden=true href=#player-클래스>#</a></h3><p>가위바위보를 하는 사람을 나타내는 클래스로 이름과 전략으로 인스턴스가 생성된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>Player</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>String</span> name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Strategy strategy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> wincount;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> losecount;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> gamecount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 이름과 전략을 받아서 플레이어를 만든다 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Player</span>(<span style=color:#66d9ef>String</span> name, Strategy strategy) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.strategy <span style=color:#f92672>=</span> strategy;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 전략에 따라 다음 손을 결정한다
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> Hand <span style=color:#a6e22e>nextHand</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> strategy.nextHand();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 승리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>win</span>() {
</span></span><span style=display:flex><span>        strategy.study(true);
</span></span><span style=display:flex><span>        wincount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        gamecount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 패배
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lose</span>() {
</span></span><span style=display:flex><span>        strategy.study(false);
</span></span><span style=display:flex><span>        losecount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        gamecount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 무승부 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>even</span>() {
</span></span><span style=display:flex><span>        gamecount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span>Override
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>String</span> toString() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;[</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> gamecount <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; games, </span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> wincount <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; win, </span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> losecount <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; lose</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>nextHand메서드는 자신의 전략을 Strategy에 위임하고 있다. 승부 결과를 다음 승부에 활용하고자 Strategy필드를 통해 study메서드를 호출하고, study 메서드로 전략의 내부상태를 변화시킨다.</p><h3 id=main ke-size=size23>3-7. Main<a hidden class=anchor aria-hidden=true href=#main>#</a></h3><p>이제 실제 다른 전략의 플레이들로 가위바위보를 하는 메인 클래스를 생성해 보자</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-reasonml data-lang=reasonml><span style=display:flex><span>public <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    public static void main<span style=color:#f92672>(</span><span style=color:#a6e22e>String</span>[] args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>args<span style=color:#f92672>.</span>length <span style=color:#f92672>!=</span> 2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Usage: java Main randomseed1 randomseed2&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Example: java Main 314 15&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            System.exit<span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> seed1 <span style=color:#f92672>=</span> Integer.parseInt<span style=color:#f92672>(</span>args<span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> seed2 <span style=color:#f92672>=</span> Integer.parseInt<span style=color:#f92672>(</span>args<span style=color:#f92672>[</span>1<span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Player</span> player1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Player</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;KIM&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>WinningStrategy</span><span style=color:#f92672>(</span>seed1<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Player</span> player2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Player</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;LEE&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ProbStrategy</span><span style=color:#f92672>(</span>seed2<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> 10000<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Hand</span> nextHand1 <span style=color:#f92672>=</span> player1<span style=color:#f92672>.</span>nextHand()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Hand</span> nextHand2 <span style=color:#f92672>=</span> player2<span style=color:#f92672>.</span>nextHand()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nextHand1<span style=color:#f92672>.</span>isStrongerThan<span style=color:#f92672>(</span>nextHand2<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Winner:&#34;</span> <span style=color:#f92672>+</span> player1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                player1<span style=color:#f92672>.</span>win()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                player2<span style=color:#f92672>.</span>lose()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nextHand2<span style=color:#f92672>.</span>isStrongerThan<span style=color:#f92672>(</span>nextHand1<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Winner:&#34;</span> <span style=color:#f92672>+</span> player2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                player1<span style=color:#f92672>.</span>lose()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                player2<span style=color:#f92672>.</span>win()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Even...&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                player1<span style=color:#f92672>.</span>even()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                player2<span style=color:#f92672>.</span>even()<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Total result:&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span>player1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System.out<span style=color:#f92672>.</span>println<span style=color:#f92672>(</span>player2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>두 명의 플레이어를 각각 다른 Strategy 구현체로 생성한 후 서로 가위바위보를 시키는 클래스이다.</p><h2 id=strategy전략-패턴의-장점-및-정리 ke-size=size26>4. Strategy(전략) 패턴의 장점 및 정리<a hidden class=anchor aria-hidden=true href=#strategy전략-패턴의-장점-및-정리>#</a></h2><p>Strategy 패턴은 알고리즘을 다른 부분과 의도적으로 분리한다. 얼핏 보면 불필요하고 복잡한 구조를 오히려 만드는 것 같지만 그렇지 않다.</p><p>인터페이스만 정의하고 위임을 통해 약한 결합으로 알고리즘을 사용하기에 알고리즘을 용이하게 전환할 수 있고, 알고리즘을 변경해야 하는 경우 ConcreteStrategy만 수정하면 된다.
 </p><p>또한 전략패턴을 사용 시 프로그램을 실행 중에 ConcreteStrategy 역을 전환할 수도 있다. 전략을 캡슐화하고 이를 사용하는 콘텍스트에서 독립적으로 전략을 변경해 줄 수 있기 때문이고, 실행 중인 애플리케이션 내에서 사용자 선택이나 조건에 따라 정렬방식/암호화/난수생성 등의 전략을 바꿀 수 있기 때문에 유연성과 확장성이 올라간다.
 </p><ul><li><p>참고 : JAVA 언어로 배우는 디자인 패턴 입문 3편</p></li><li><p>상세 예제소스는 깃허브에서 확인가능</p></li></ul><p><a href=https://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/strategy>https://github.com/junhkang/java-design-pattern/tree/master/src/main/java/com/example/javadesignpattern/strategy</a></p><p> </p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:50666/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/>디자인패턴</a></li><li><a href=http://localhost:50666/tags/strategy/>Strategy</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>