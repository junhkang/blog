<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념 | Jun Kang's Blog</title>
<meta name=keywords content="네트워크,TCP/IP,tcp,소켓,udp"><meta name=description content="
1. 소켓(Socket)이란
소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.
소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.

1-1. 서버 소켓
클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/30/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/30/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/30/"><meta property="og:title" content="[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념 | Jun Kang's Blog"><meta property="og:description" content="
1. 소켓(Socket)이란
소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.
소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.

1-1. 서버 소켓
클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/30/"><meta property="twitter:title" content="[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념 | Jun Kang's Blog"><meta property="twitter:description" content="
1. 소켓(Socket)이란
소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.
소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.

1-1. 서버 소켓
클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/30/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념"><meta property="og:description" content=" 1. 소켓(Socket)이란 소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.
소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.
1-1. 서버 소켓 클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-18T15:32:25+00:00"><meta property="article:modified_time" content="2023-10-18T15:32:25+00:00"><meta property="article:tag" content="네트워크"><meta property="article:tag" content="TCP/IP"><meta property="article:tag" content="Tcp"><meta property="article:tag" content="소켓"><meta property="article:tag" content="Udp"><meta name=twitter:card content="summary"><meta name=twitter:title content="[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념"><meta name=twitter:description content="
1. 소켓(Socket)이란
소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.
소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.

1-1. 서버 소켓
클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념","item":"https://junhkang.com/posts/30/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념","name":"[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념","description":" 1. 소켓(Socket)이란 소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.\n소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.\n1-1. 서버 소켓 클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다.\n","keywords":["네트워크","TCP/IP","tcp","소켓","udp"],"articleBody":" 1. 소켓(Socket)이란 소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.\n소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.\n1-1. 서버 소켓 클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다.\nsocket() - CLOSED 상태의 소켓 인스턴스 생성 bind() - ip, port 할당 (중복, 권한 문제로 주소\u0026 포트 할당에 실패 할 수 있다.) listen() - 서버 소켓 상태는 LISTEN 상태로 변경, 클라이언트 요청을 queue 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정 accept() - 각 클라이언트와 통신에 필요한 새로운 연결된 소켓을 획득, 클라이언트와 연결 send() / recv() - 데이터 송수신 close() - 소켓 닫기 listen상태에서 3-way handshaking을 거쳐 클라이언트, 소켓 연결이 ESTABLISH 상태가 되며, 그 후 accept()~close()를 반복하며 데이터를 송수신한다.\n1-2. 클라이언트 소켓 서버로 연결요청 및 데이터 전송을한다.\nsockect() - CLOSED 상태의 소켓 인스턴스 생성 connect() - 소켓에 남는 local port 자동으로 할당(별도 ip, port를 바인딩도 가능) , 서버 ip, port로 연결 요청- 3-way handshake가 일어난다. (CLOSED-\u003eSYN_SENT-\u003eESTABLISHED 상태로 변경) send() / recv() - 데이터 송수신 close() - 소켓 닫기 서버 소켓이 연결은 맺은 후 \"새로운\" 소켓을 만든다고 표현한 이유는, accept() 할시 기존 listen()하고 있는 소켓은 데이터 송수신에 사용되지 않고, 클라이언트를 연결하기 위해 새로운 소켓을 획득하기 때문이다.\n따라서 accept() 후에는 서버에 대기상태 (LISTENING) 상태의 소켓과 신규 연결된 소켓 (ESTABLISHED) 소켓 2개가 동시에 존재한다.\n2. 3-way handshake 서버가 클라이언트 요청을 기다리며 listen 상태일 때 3-way handshake를 통해 클라이언트-서버 사이 소켓이 연결된다.\nSYN - synchronize의 약자로 처음 주고받을 데이터의 일련번호 ACK - Acknowledgement의 약자로 어떤 번호까지의 데이터를 정상수신 했는지에 대한 데이터 #1. 클라이언트에서 서버 OS에 가상경로 오픈을 의뢰하며 SYN 패킷 전송. 클라이언트는 SYN을 보내고 응답을 기다리는 SYN_SENT 상태로 변경\n#2. 서버는 listen 상태이기에 ACK+SYN 패킷 응답 발송, 클라이언트에서 다시 ACK로 응답하기를 기다리며 SYN_RECEIVED 상태로 변경\n#3. 클라이언트도 다시 ACK패킷으로 응답하며 서버의 새로운 소켓이 생성되며 연결. 서버의 상태가 ESTABLISHED로 변경\n#2이 완료되는 시점에 클라이언트소켓은 send() (데이터송신)이 가능하다.\n서버는 ACK를 받지 못하고 SYN_RCV 상태이지만 클라이언트 소켓은 이미 ESTABLISHED 상태이기 때문이다.\n3. 소켓(Socket)의 종류 3-1. TCP (스트림 소켓) 양방향 바이트 스트림 전송, 연결 지향방식의 소켓 송수신자의 연결을 보장하여 신뢰성 있는 데이터 송신 가능 오류수정, 전송처리, 흐름제어 송신되는 순서에 따라 중복되지 않게 데이터 수신 소량의 데이터보다 대량의 데이터 전송에 적합 3-2. UDP (데이터그램 소켓) 비연결형 소켓 데이터 크기에 제한이 있음 데이터의 순서와 신뢰성을 보장하지 않음 점대점뿐만 아니라 일대다 연결도 가능 확실하게 전달이 보장되지 않음, 데이터가 손실돼도 오류가 발생하지 않음 실시간 멀티미디어 정보를 위해 주로 사용 accept 과정 없이 소켓 생성 후 바로 데이터 송수신 참고\nhttps://devkly.com/network/3-way-handshake-with-c/\nhttps://velog.io/@newdana01/%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-HTTP%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4 ","wordCount":"428","inLanguage":"en","datePublished":"2023-10-18T15:32:25Z","dateModified":"2023-10-18T15:32:25Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/30/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://junhkang.com/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념</h1><div class=post-meta><span title='2023-10-18 15:32:25 +0000 UTC'>October 18, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=소켓socket이란 ke-size=size26>1. 소켓(Socket)이란<a hidden class=anchor aria-hidden=true href=#소켓socket이란>#</a></h2><p>소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.</p><p>소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.</p><p><img loading=lazy src=/images/posts/30/img.png></p><h3 id=서버-소켓 ke-size=size23><strong>1-1. 서버 소켓</strong><a hidden class=anchor aria-hidden=true href=#서버-소켓>#</a></h3><p>클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다.</p><ul><li><strong>socket() -</strong> CLOSED 상태의 소켓 인스턴스 생성</li><li><strong>bind() -</strong> ip, port 할당 (중복, 권한 문제로 주소& 포트 할당에 실패 할 수 있다.)</li><li><strong>listen() -</strong> 서버 소켓 상태는 LISTEN 상태로 변경, 클라이언트 요청을 queue 대기열을 만들어 몇 개의 클라이언트를 대기시킬지 결정</li><li><strong>accept() -</strong> 각 클라이언트와 통신에 필요한 새로운 연결된 소켓을 획득, 클라이언트와 연결</li><li><strong>send() / recv() -</strong> 데이터 송수신</li><li><strong>close() -</strong> 소켓 닫기</li></ul><p>listen상태에서 3-way handshaking을 거쳐 클라이언트, 소켓 연결이 ESTABLISH 상태가 되며, 그 후 accept()~close()를 반복하며 데이터를 송수신한다.</p><h3 id=클라이언트-소켓 ke-size=size23><strong>1-2. 클라이언트 소켓</strong><a hidden class=anchor aria-hidden=true href=#클라이언트-소켓>#</a></h3><p>서버로 연결요청 및 데이터 전송을한다.</p><ul><li><strong>sockect() -</strong> CLOSED 상태의 소켓 인스턴스 생성</li><li><strong>connect() -</strong> 소켓에 남는 local port 자동으로 할당(별도 ip, port를 바인딩도 가능) , 서버 ip, port로 연결 요청- 3-way handshake가 일어난다. (CLOSED->SYN_SENT->ESTABLISHED 상태로 변경)</li><li><strong>send() / recv() -</strong> 데이터 송수신</li><li><strong>close() -</strong> 소켓 닫기</li></ul><p>서버 소켓이 연결은 맺은 후 "새로운" 소켓을 만든다고 표현한 이유는, accept() 할시 기존 listen()하고 있는 소켓은 데이터 송수신에 사용되지 않고, 클라이언트를 연결하기 위해 새로운 소켓을 획득하기 때문이다.</p><p>따라서 accept() 후에는 서버에 대기상태 (LISTENING) 상태의 소켓과 신규 연결된 소켓 (ESTABLISHED) 소켓 2개가 동시에 존재한다.</p><h2 id=way-handshake ke-size=size26>2. 3-way handshake<a hidden class=anchor aria-hidden=true href=#way-handshake>#</a></h2><p><img loading=lazy src=/images/posts/30/img_1.png></p><p>서버가 클라이언트 요청을 기다리며 listen 상태일 때 3-way handshake를 통해 클라이언트-서버 사이 소켓이 연결된다.</p><ul><li>SYN - synchronize의 약자로 처음 주고받을 데이터의 일련번호</li><li>ACK - Acknowledgement의 약자로 어떤 번호까지의 데이터를 정상수신 했는지에 대한 데이터</li></ul><blockquote><p><strong>#1.</strong> 클라이언트에서 서버 OS에 가상경로 오픈을 의뢰하며 SYN 패킷 전송. 클라이언트는 SYN을 보내고 응답을 기다리는 SYN_SENT 상태로 변경<br><strong>#2.</strong> 서버는 listen 상태이기에 ACK+SYN 패킷 응답 발송, 클라이언트에서 다시 ACK로 응답하기를 기다리며 SYN_RECEIVED 상태로 변경<br><strong>#3.</strong> 클라이언트도 다시 ACK패킷으로 응답하며 서버의 새로운 소켓이 생성되며 연결. 서버의 상태가 ESTABLISHED로 변경</p></blockquote><p>#2이 완료되는 시점에 클라이언트소켓은 send() (데이터송신)이 가능하다.</p><p>서버는 ACK를 받지 못하고 SYN_RCV 상태이지만 클라이언트 소켓은 이미 ESTABLISHED 상태이기 때문이다.</p><h2 id=소켓socket의-종류 ke-size=size26>3. 소켓(Socket)의 종류<a hidden class=anchor aria-hidden=true href=#소켓socket의-종류>#</a></h2><h3 id=tcp-스트림-소켓 ke-size=size23><strong>3-1. TCP (스트림 소켓)</strong><a hidden class=anchor aria-hidden=true href=#tcp-스트림-소켓>#</a></h3><p><img loading=lazy src=/images/posts/30/img_2.png></p><ul><li>양방향 바이트 스트림 전송, 연결 지향방식의 소켓</li><li>송수신자의 연결을 보장하여 신뢰성 있는 데이터 송신 가능</li><li>오류수정, 전송처리, 흐름제어</li><li>송신되는 순서에 따라 중복되지 않게 데이터 수신</li><li>소량의 데이터보다 대량의 데이터 전송에 적합</li></ul><h3 id=udp-데이터그램-소켓 ke-size=size23><strong>3-2. UDP (데이터그램 소켓)</strong><a hidden class=anchor aria-hidden=true href=#udp-데이터그램-소켓>#</a></h3><p><img loading=lazy src=/images/posts/30/img_3.png></p><ul><li>비연결형 소켓</li><li>데이터 크기에 제한이 있음</li><li>데이터의 순서와 신뢰성을 보장하지 않음</li><li>점대점뿐만 아니라 일대다 연결도 가능</li><li>확실하게 전달이 보장되지 않음, 데이터가 손실돼도 오류가 발생하지 않음</li><li>실시간 멀티미디어 정보를 위해 주로 사용</li><li>accept 과정 없이 소켓 생성 후 바로 데이터 송수신
 </li></ul><p> </p><p> </p><p> </p><p> </p><p> </p><p>참고</p><ul><li><p><a href=https://devkly.com/network/3-way-handshake-with-c/>https://devkly.com/network/3-way-handshake-with-c/</a></p></li><li><p><a href=https://velog.io/@newdana01/%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-HTTP%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4>https://velog.io/@newdana01/%EC%86%8C%EC%BC%93%EC%9D%B4%EB%9E%80-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%ED%9D%90%EB%A6%84-HTTP%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>
 </p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/>네트워크</a></li><li><a href=https://junhkang.com/tags/tcp/ip/>TCP/IP</a></li><li><a href=https://junhkang.com/tags/tcp/>Tcp</a></li><li><a href=https://junhkang.com/tags/%EC%86%8C%EC%BC%93/>소켓</a></li><li><a href=https://junhkang.com/tags/udp/>Udp</a></li></ul></footer><div class=giscus><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>