<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>333333 | Jun Kang&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Jun Kang">
<link rel="canonical" href="http://localhost:1313/tags/333333/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/333333/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/333333/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Jun Kang&#39;s Blog (Alt + H)">Jun Kang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    333333
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[AWS] Elastic IP (탄력적 IP)의 개념 및 적용
    </h2>
  </header>
  <div class="entry-content">
    <p>EIP(Elastic Ip Address)란 인터넷으로 접속이 가능한 공인 IP를 할당하여, 인스턴스에 탈부착할 수 있는 서비스이다. 인스턴스 혹은 네트워크 인터페이스에 연결이 가능하며 삭제 전까지 해당 IP를 유지할 수 있다.EC2 인스턴스 생성 시 공인 IP 사용 설정을 Enable로 변경 (default는 Disable)할 경우 인스턴스 자체에 공인 IP를 할당받을 수 있는데 왜 굳이 Elastic IP를 사용하는 것일까?![](/images/posts/18/스크린샷 2023-10-09 오후 1.56.51.png)인스턴스가 stop 후 재시작될 경우 공인 IP가 변경되는 경우가 발생한다. 인스턴스 자체의 공인 IP가 변경될 경우 큰 문제로 이어질 수 있어EIP를 인스턴스에 연결함으로써 인스턴스의 공인IP를 고정시켜 준다.## 2. Elastic IP 개념 및 특징- 탄력적 IP 주소는 정적이며 시간이 지남에 따라 변경되지 않는다.- 탄력적 IP 주소는 특정 리전에서만 사용할 수 있으며 다른 리전으로 이전할 수 없다.- IPv4 주소의 Amazon 풀 또는 AWS 계정으로 가져온 사용자 지정 IPv4 주소 풀에서 탄력적 IP 주소를 할당할 수 있다. (3-3. EIP 옵션 설정 시 선택 가능)- 탄력적 IP 주소를 사용하려면 먼저 계정에 주소를 할당한 후 인스턴스 또는 네트워크 인터페이스와 연결해야 한다.(3-6. 인스턴스 할당)- 탄력적 IP 주소는 리소스에서 연결 해제했다가 다른 리소스와 다시 연결할 수 있다. 예기치 않은 동작을 방지하려면 변경하기 전에 기존 연결에 이름이 지정된 리소스에 대한 모든 활성 연결이 닫혀 있는지 확인해야 한다. 탄력적 IP 주소를 다른 리소스에 연결한 후 새로 연결된 리소스에 대한 연결을 다시 열 수 있다.- 연결 해제한 Elastic IP 주소는 명시적으로 릴리스(삭제)할 때까지 계정에 할당되어 있기 때문에 실행 중인 인스턴스와 연결되지 않은 탄력적 IP 주소에 대해서는 소액의 시간당 요금이 부과된다 (2. 요금 항목 참고).- 탄력적 IP 주소를 이전에 퍼블릭 IPv4 주소가 있던 인스턴스와 연결하면 인스턴스의 퍼블릭 DNS 호스트 이름이 탄력적 IP 주소에 맞게 변경된다.- Amazon은 퍼블릭 DNS 호스트 이름을 인스턴스 네트워크 외부에서는 인스턴스의 퍼블릭 IPv4 주소 또는 탄력적 IP 주소로 변환하고, 인스턴스 네트워크 내부에서는 인스턴스의 프라이빗 IPv4 주소로 변환한다.- AWS 계정으로 가져온 IP 주소 풀에서 탄력적 IP 주소를 할당하는 경우 해당 IP 주소는 탄력적 IP 주소 한도에 포함되지 않는다.- 탄력적 IP 주소는 특정 네트워크 경계 그룹에서만 사용할 수 있다.퍼블릭(IPv4) 인터넷 주소는 흔치 않은 퍼블릭 리소스 이기 때문에 지역당 5개로 제한되며, 인스턴스 장애 시 주소를 다른 인스턴스로 다시 매핑하는 기능이 필요할때는 EIP를 주로 사용하고, 다른 모든 노드 간 통신은 DNS 호스트명을 사용하는 것을 권장한다. (사용개수 제한은 AWS에 별도 문의하여 최대 사용량을 증가시킬 수 있다.)## 3. 요금- 실행 중인 인스턴스와 연결된 각 추가 IP 주소에 대해 시간당 0.005 USD(비례 할당으로 계산)- 실행 중인 인스턴스와 연결되지 않은 각 탄력적 IP 주소에 대해 시간당 0.005 USD(비례 할당으로 계산)- 매달 처음 100개의 재매핑에 대해 탄력적 IP 주소 재 매핑당 0.00 USD- 매달 100개 이후의 재매핑에 대해 탄력적 IP 주소 재 매핑당 0.10 USD상세 요금은 다음 공식 링크에서 확인 가능하다.https://aws.amazon.com/ec2/pricing/on-demand/EC2 온디맨드 인스턴스 요금 – Amazon Web Servicesaws.amazon.com4. 적용#### 4-1. EC2 메뉴에서 Elastic IPs 선택![](/images/posts/18/스크린샷 2023-10-09 오후 2.00.56.png)#### 4-2. Allocate Elastic IP address 선택![](/images/posts/18/스크린샷 2023-10-09 오후 2.02.17.png)### 4-3. 네트워크 경계그룹, IP주소 풀 선택 후 “Allocate&#34;선택#### 4-3-1. 네트워크 경계 그룹AWS가 Public 주소를 알리는 가용영역, , Local Zone 또는 Wavelength Zone의 집합이다. Local Zone 및 Wavelength Zone은 AWS 네트워크와 해당 영역의 리소스에 액세스 하는 고객 간의 지연 시간 또는 물리적 거리를 최소화하기 위해 리전의 AZ와 다른 네트워크 경계 그룹을 가질 수 있다.주의 : EIP와 연결될 AWS 리소스는 동일한 네트워크 경계 그룹에 할당되어야 한다.#### 4-3-2. Public IPv4 address pool- [Amazon의 IP 주소 풀(Amazon’s pool of IPv4 addresses)] - 특별한 경우가 아니라면 해당 옵션을 선택하여 공인 IP를 할당받으면 된다. IPv4 주소를 Amazon의 IPv4 주소 풀에서 할당하려는 경우이다.- AWS 계정으로 가져오는 퍼블릭 IPv4 주소 - AWS 계정으로 가져온 IP 주소 풀에서 IPv4 주소를 할당하려는 경우. IP 주소 풀이 없는 경우에는 이 옵션을 사용할 수 없다.- [고객 소유 IPv4 주소 풀(Customer owned pool of IPv4 addresses)] - AWS Outpost를 통해 사용할 온프레미스 네트워크에서 생성된 풀에서 IPv4 주소를 할당하려는 경우. AWS Outposts가 없는 경우 이 옵션이 비활성화된다.![](/images/posts/18/스크린샷 2023-10-09 오후 2.03.46.png)### 4-4. EIP 생성이 완료되면 리스트에서 확인이 가능하며, 인스턴스 할당을 위해서 해당 항목을 클릭하여 상세 페이지로 들아간다.![](/images/posts/18/스크린샷 2023-10-09 오후 2.04.45.png)### 4-5. EIP 상세에서 우측 상단 “Associate Elastic IP address&#34;를 선택한다.### 4-6. AWS 인스턴스와 연결하고 싶다면 인스턴스를 선택, 특정 사설(private) ip와 연결하고 싶다면 IP주소를 입력하면 된다.“Allow this Elastic IP address to be reassociated” 옵션을 선택하면 해당 EIP를 할당 후 다른 인스턴스로 변경이 가능하다.참고https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html#AWS #eip #Elastic IPs
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [AWS] Elastic IP (탄력적 IP)의 개념 및 적용" href="http://localhost:1313/posts/18/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Elastic Search] Elastic Search란? Elastic Search의 개념 및 장단점
    </h2>
  </header>
  <div class="entry-content">
    <p>Apache Lucene에 구축되어 배포된 검색 및 분석 엔진이다. 현재 검색엔진을 넘어 보안, 로그분석, Full-text 분석 등 다양한 영역에서 사용되며, Kibana, Logstash, Beats들과 함께 사용된다. 오픈 소스 프로젝트로 활발히 개발되고 있으며, 유닉스, 자바의 기초지식 필요하다. Apache Lucene의 한계를 보완하기 위한 새로운 검색엔진 프로젝트로 시작되었고 Logstash, Kibana와 함께 사용되어 ELK Stack (ES, Logstash, Kibana)라고 불렸으나 2013년 Logstash, Kibana 프로젝트 정식 흡수되었다.## 2. Elastic Stack이란?ES, Logstash, Kibana를 묶은 ELK 서비스이다. 5.0.0 버전부터 Beats를 포함하며 Elastic Stack 이란 이름으로 서비스가 제공되고 있다. 서버로부터 모든 유형의 데이터를 가져와 실시간 검색, 분석, 시각화를 도와주는 Elastic 오픈 소스 서비스 제품이다.### 2-1. Elastic Search- 아파치 루씬(Apache Lucene) 기반의 Full Text로 검색이 가능한 오픈 소스 분석 엔진- 주로 Rest API로 처리- 대량 데이터를 거의 실시간으로 신속하게 저장, 검색, 분석 가능### 2-2. Logstash- 플러그인을 통해 데이터 집계와 보관, 서버 데이터 처리 담당- ES와 상관없이 독자적으로도 사용 가능- 파이프라인으로 데이터를 수집, 필터를 통해 변환 후 Elastic Search로 전송- 입력 - Beats, CloudWatch, Eventlog 등 다양한 입력 지원, 데이터 수집- 필터 - 형식, 복잡성에 상관없이 데이터를 동적으로 변환- 출력 - ES, Email, ECS, Kafka 등 원하는 저장소에 데이터 전송### 2-3. Kibana- 데이터 시각화 도구- 검색 및 aggregation 집계기능을 통해 ES로부터 문서, 집계 결과등을 가져와 웹도구로 시각화- DIscover, Visualize, Dashboard 3개의 기본 메뉴와 다양한 App 들로 구성- 플러그인을 통해 App 설치 가능### 2-4. Beats- 경량 에이전트로 설치- 데이터를 Logstash 또는 ES로 전송- Logstash 보다 경량화 된 서비스- Filebeat, Metricbeat, Packetbeat, Winlogbeat, Heartbeat 등- Libbeat을 통해 직접 구축 가능## 3. Elastic Search의 특징과 장단점### 3-1. 장점#### → 3-1. 실시간분석- 하둡 시스템과 달리 ES 클러스터가 실행되고 있는 동안에는 계속해서 데이터가 입력 (인덱싱) 되고, 동시에 실시간에 가까운 속도로 색인된 데이터의 집계, 검색이 가능#### → 3-2. Full Text 검색 엔진- Lucene은 기본적으로 역파일 색인 구조로 데이터를 저장하며 이를 사용하는 ES도 동일 방식&gt; 역색인 - 일반적인 색인의 목적은 문서의 위치에 대한 index를 생성하여 그 문서에 빠르게 접근하기 위함이지만, 역색인은 문서 내의 문자와 같은(혹은 유사한) 내용들에 대한 매핑 정보를 색인하는 것이다.- 내부적으로는 역파일 색인이라도 사용자 관점에서는 JSON 형식으로 전달- 쿼리문 또는 쿼리에 결과도 모두 JSON 형태로 반환- key-value 형식이 아닌 문서기반으로 되어있어 복잡한 정보를 포함해도 그대로 저장이 가능하여 직관적- 여러 계층 구조의 문서로 저장이 가능하며, 계층 구조로 된 문서도 한 번의 쿼리로 조회 가능#### → 3-3. RESTFul API- Rest API를 기본으로 지원하여 모든 데이터의 조회, 입력, 삭제를 HTTP 프로토콜을 통해 처리 가능#### → 3-4. multitenancy- ES의 데이터들은 index라는 논리 집합 단위로 구성되며 서로 다른 저장소에 분산-저장된다.- 서로 다른 인덱스들을 별도 커넥션 없이 하나의 쿼리로 묶어서 검색, 하나의 출력 결과를 도출한다. (서로 상이한 인덱스일지라도 검색할 필드명만 같으면 여러 인덱스를 동시에 조회 가능)#### → 3-5. 확장성- 분산 구성이 가능, 분산환경에서 데이터는 shard 단위로 분리- 플러그인을 사용한 기능 확장 가능- AWS, MS Azure 같은 클라우드 서비스, Hadoop 플랫폼들과도 연동 가능#### 3-6. 다양한 알고리즘 제공- 점수 기반의 다양한 정확도 알고리즘, 실시간 분석 등의 구현 가능### 3-2. 단점- 색인된 데이터는 내부 commit, flush 등의 프로세스를 거치기에 1초정도 뒤에 검색이 가능- 클러스터의 성능향상을 위해 비용소모가 큰 트랜잭션 롤백이 지원되지 않는다.- 업데이트 요청시 기존 문서를 삭제 후 신규 문서를 재생성하기에 업데이트 비용이 크다.## 4. Elastic Search 구성#### Index- 데이터 저장공간- 하나의 물리 노드에 여러 개의 논리 인덱스 생성- 하나의 인덱스가 여러 노드에 분산 저장#### Shard- 색인된 문서는 하나의 인덱스와 그 내부의 여러 개의 파티션(샤드)으로 나뉘어 구성#### Type- 인덱스의 논리적 구조- 6.1부터 인덱스당 하나의 타입만 설정 가능#### Document- 인덱스가 저장되는 최소단위- JSON 포멧으로 저장- RDBMS의 ROW와 동일#### Field- 문서를 구성하기 위한 속성- 하나의 필드는 다수의 데이터 타입 정의 가능- RDBMS의 컬럼과 동일#### Mapping- 문서의 필드, 필드 속성을 정의하고 색인 방법을 정의하는 프로세스## 5. Elastic Search와 RDBMS의 관계익숙한 관계형 데이터베이스와의 유사 기능 관계를 통해 이해해 보면참고https://jaemunbro.medium.com/elastic-search-%EA%B8%B0%EC%B4%88-%EC%8A%A4%ED%84%B0%EB%94%94-ff01870094f0https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.htmlhttps://velog.io/@hanblueblue/Elastic-Search-1#Elastic Stack #Elastic search
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Elastic Search] Elastic Search란? Elastic Search의 개념 및 장단점" href="http://localhost:1313/posts/50/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Java] 가상 스레드 (Virtual Threads)란? 자바 21의 가상스레드 (Virtual Thread) 도입
    </h2>
  </header>
  <div class="entry-content">
    <p>2023.09.20 릴리즈 된 자바 21에 추가된 가상 스레드(Virtual Threads)라는 기능을 살펴보자.가상 스레드는 경량 스레드로, 높은 처리량의 동시 어플리케이션을 작성, 유지 및 관찰하는 작업 공수를 크게 줄인다. OS스레드를 그대로 사용하지 않고 JVM 자체적으로 스케쥴링을 통해 사용할 수 있는 경량 스레드이며, 하나의 프로세스가 수십 - 수백만 스레드를 동시에 실행할수 있도록 설계되었다.## 2. 자바의 전통적인 스레드자바 개발자들은 근 30년동안 동시성 서버 어플리케이션의 처리를 위해 스레드에 의존해왔다. 모든 메서드의 구문들은 스레드 내부에서 실행되며, 1개의 요청을 1개의 스레드가 처리한다. 대표적으로 스프링은 멀티스레드 구조이기에, 여러 스레드의 실행이 동시에 발생하며 동시 요청이 많아질수록 스레드의 수 역시 증가한다. 각각의 스레드는 지역 변수를 저장하고 메소드 호출을하는 스택을 제공하며, 문제가 생겼을 때의 Context도 제공하는데, 예를들어 Exception은 동일 스레드 내에서의 메소드에 의해 throw/catch 된다. 그렇기 때문에 개발자는 스레드의 Stack trace로 문제를 추적할 수 있는 것이고, 그 외 Debugger (스레드의 메소드 내에서 구문을 차례로 훑어본다), Profiler(JFR) (여러 스레드의 행동을 시각화하여 스레드의 성능을 이해할 수 있도록 도와준다.)도 모두 스레드 기반으로 되어있다.### 2-1. 전통적인 스레드의 한계점- 기존 JDK의 스레드는 OS 스레드를 Wrapping한 것으로 사용가능한 스레드의 수가 하드웨어 수준보다 훨씬 적게 제한되어있다.- OS 스레드는 생성, 유지 비용이 높고 갯수가 제한적이라 요청량에 비례하여 무한정 늘릴수 없다.- 어플리케이션 코드가 플렛폼 스레드를 사용하면 실제로는 OS스레드를 사용하는 것이며, 이 스레드는 비용이 비싸기 때문에 스레드 풀을 사용하여 접근하는 방식으로 사용한다.- Spring 같은 어플리케이션의 기본 처리방식은 Thread-per-request이다.&gt; [Thread-per-request]서버 어플리케이션은 일반적으로 서로 독립적인 유저의 동시 요청들을 처리하기에, 어플리케이션이 전체 요청기간 동안 스레드를 전담하여 요청을 처리해야한다. 이러한 Thread-per-request 스타일은 플랫폼의 동시성 단위가 곧 어플리케이션의 동시성 단위이기 때문에 이해하기 쉽고, 개발 및 디버그, 프로파일링 하기 쉽다.- Thread-per-request 방식은 요청을 처리하는 스레드에서 I/O 작업시 Blocking이 발생한다.- Blocking 발생시 스레드는 I/O 작업 종료시까지 대기해야하기에 많은 요청을 처리해야 하는 상황이라면 Blocking으로 발생하는 낭비를 줄여야한다.&gt; [Reactive Programming]- Blocking 방식으로 발생하는 낭비를 줄이기 위해 발전하게된 처리량을 높이기 위한 방법, 비동기 방식 프로그래밍이다.- Non-blocking 방식으로 변경하면서 Blocking을 대기하는데 소요된 자원을 다른 요청에서 사용할 수 있다.- 기존 자바 프로그래밍은 스레드를 기반으로하기에 라이브러리들이 모두 Reactive Programming 방식에 맞게 새로 작성되어야하는 문제가 있다.## 3. 가상 스레드의 작동방식가상 스레드는 OS를 Wrapping한 구조가 아니기에 스레드 풀 없이 사용 가능하고, JVM 자체적으로 OS스레드와 연결하는 스케쥴링을 처리하기에 기존 스타일로 코드를 작성하더라도 내부의 가상 스레드가 효율적인 방법으로 스케줄링 해준다. (가상 스레드를 사용하면 Non-blocking에 대한 처리를 JVM단에서 처리해준다.)## 4. 목표공식 문서에 따르면 가상 스레드의 목표와 목표가 아닌 것 (Goals / Non-Goals)을 확인할 수 있다.목표 (Goals)- 기존의 Thread-per-request (요청당 처리) 방식으로 작성된 서버 어플리케이션을 near-optimal(최적화) 하드웨어 사용으로 확장 가능해야한다.- java.lang.Thread API를 사용하는 기존 자바 코드를 최소한의 수정으로 가상 스레드를 채택 가능해야 한다.- 기존 JDK 툴들을 사용하여 가상 스레드의 쉬운 트러블 슈팅, 디버깅 및 프로파일링이 가능해야 한다.목표가 아닌 것 (Non-Goals)- 기존 thread의 사용을 제거하는 것이나 기존 어플리케이션이 가상 스레드를 사용하기 위해 은밀하게 마이그레이션 하는 것이 아니다.- 자바의 기본 동시성 모델을 바꾸는 것이 아니다.- 자바 언어나 자바 라이브러리에 새로운 데이터 병렬구조를 제공하려는 것이 목표가 아니다. Stream API는 큰 데이터를 병렬로 처리하는데 여전히 선호되는 방법이다.가상 스레드는 자바의 기본 동시성 모델을 바꾸거나, 새로운 데이터 흐름의 병렬 구조를 제시하는 것이 아닌 기존 자바 코드를 최소한으로 수정하는 선에서 동시성을 제어하는 어플리케이션이 기존 Thread-per-request 방식 외에 가상 스레드 풀 없이 Reactive Programming이 추구하는 Non-blocking의 효율적인 자원사용을 지원하는데 목표를 두고 있다.참고https://mangkyu.tistory.com/309https://findstar.pe.kr/2023/04/17/java-virtual-threads-1/https://openjdk.org/jeps/444#Java #가상 스레드
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Java] 가상 스레드 (Virtual Threads)란? 자바 21의 가상스레드 (Virtual Thread) 도입" href="http://localhost:1313/posts/37/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Java] 클래스 로딩 과정(Java Class Loading Process)이란?
    </h2>
  </header>
  <div class="entry-content">
    <p>자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (‘java.lang.ClassNotFoundException’과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.## 2. 클래스 로더 3단계 과정클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.&gt; 1. Loading 클래스 파일을 읽어 바이너리 코드로 만들고 JVM의 메모리에 로드2. Linking 클래스파일 사용을 위한 검증코드 내부의 러퍼런스를 연결3. InitializationStatic 변수들의 초기화 및 값 할당## 3. 클래스 로드 시점Loading 시점에서 JVM은 실행 시점에 모든 클래스를 메모리에 올려놓지 않고 필요한 클래스를 동적으로 메모리에 적재하여 효율적으로 관리한다.&gt; 1. 인스턴스 생성시2. Static 변수 할당3. Static 메서드 호출4. Static final 상수 호출 (Static 변수, 메소드 호출과 다르게 Outer 클래스가 로딩되지 않는다, JVM의 Method Area에 Constant Pool에 따로 저장되어 관리되기 때문이다.)## 4. 클래스 로더의 종류JVM을 실행했을 때 각 클래스 로더들은 자신이 호출할 수 있는 클래스들을 호출하여 JVM에 로딩하게 된다.&gt; 1. 부트스트랩 클래스 로더 $JAVA_HOME/jre/lib/rt.jar 에서 rt.jar에 있는 JVM을 실행시키기 위한 최소한의 핵심 클래스들을 로딩한다.-verbose:class JVM 옵션을 주고 자바 애플리케이션을 실행시키면 rt.jar에 있는 파일 로딩되는 것을 확인할 수 있다.Java 9 이후로는 rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 축소되어 정확하게 ClassLoader 내 최상위 클래스들만 로드한다.2. 확장 클래스로더$JAVA_HOME/jre/lib/ext 경로의 자바 확장 클래스들을 로딩한다3. 애플리케이션 클래스 로더자바 프로그램 실행 시$CLASSPATH에 설정된 경로의 클래스들을 로딩하게 된다. 이 시점에 개발된. class파일들이 로딩된다.클래스 로더들은 계층 구조를 가지도록 생성이 가능하고 각 부모 클래스 로더에서 자식클래스 로더를 가지는 형태로 클래스 로더를 만들 수 있다.## 5. 클래스 로더의 작동원칙위임 원칙 (Delegate Load Request)System Loader가 A라는 클래스를 로딩할 때 그 요청은 부모로더들로 거슬러 올라가 부트스트랩 로더에 도착한 후 그 밑으로 로딩 요청을 수행한다. 최상위 클래스 로더에 요청을 위임한 후, 파일을 찾으며 자식 클래스 로더에게 넘기며, 클래스로더 중 하나라도 파일 찾는 데 성공하면 자식 로더에게 넘겨준다.가시성 제약 조건(Have Visibility Constraint)부모 로더에서 찾지 못한 클래스는 자식 로더로 찾지 못하고, 자식로더가 찾지 못한 것은 부모로더에 위임해서 찾을 수 있다언로드 불가 (Cannot unload classes)클래스 로더로 로딩된 클래스들은 JVM 상에서 없앨 수 없다유일성 원칙 (Uniqueness Principle)하위 클래스 로더가 상위 클래스 로더에서 로드한 클래스를 다시 로드하지 않아야 한다.상위 클래스로만 책임을 위임하기에 고유한 클래스를 보장할 수 있게 해주는 원칙이다.참고https://co-no.tistory.com/103https://engkimbs.tistory.com/entry/Java-Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95Java-Class-Loading-Process#Java #jvm #클래스 로더
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Java] 클래스 로딩 과정(Java Class Loading Process)이란?" href="http://localhost:1313/posts/35/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Linux] 스왑 메모리(Swap Memory)의 개념과 적용방법
    </h2>
  </header>
  <div class="entry-content">
    <p>1-1. Swap 메모리 확인swapon -sfree -h![](/images/posts/34/스크린샷 2023-10-23 오후 3.25.49.png)&gt; shared = 하나의 프로세스에서 다른 프로세스의 데이터에 효율적으로 접근하기 위해 사용하는 메모리buff/cache = 버퍼와 캐시를 위해 사용하는 메모리, 커널이 성능향상을 위해 캐시 영역으로 사용되는 메모리buff = 프로세스가 사용하는 메모리 영역이 아닌 시스템 성능향상을 위해 커널이 사용하고 있는 영역cache = 캐시영역의 메모리, I/O 작업을 더 빠르게 하기 위해 커널에서 사용* total - buff/cache - free = 사용중인 메모리* total - used - buff/cache = 실제 사용가능한 메모리### 1-2. Swap 메모리 추가sudo dd if=/dev/zero of=/swapfile bs=1024 count=200000&gt; bs = 포멧 단위 (bs = 1M 로도 사용 가능)count = 블록수, 1kb를 200000번 /dev/zero로 초기화하기에 총 200MB의 공간을 Swap 파일로 포맷한 것으로 메모리 크기를 의미한다. (count=2000000 -&gt; 2GB swap 메모리)![](/images/posts/34/스크린샷 2023-10-23 오후 3.26.38.png)![](/images/posts/34/스크린샷 2023-10-23 오후 3.27.53.png)### 1-3. mkswap으로 Swap 파일로 포멧sudo mkswap swapfilesudo chmod 600 /swapfile![](/images/posts/34/스크린샷 2023-10-23 오후 3.28.23.png)![](/images/posts/34/스크린샷 2023-10-23 오후 3.28.59.png)### 1-4. Swap 메모리 활성화-- 단일 Swap 메모리 onsudo swapon swapfile-- 전체 Swap 메모리 onswapon -aswapon: /swapfile: swapon failed: Device or resource busy에러가 뜬다면 sudo swapoff /swapfile로 Swap 비활성화 후 다시 시도해 주면 된다.![](/images/posts/34/스크린샷 2023-10-23 오후 3.35.11.png)Swap 메모리가 활성된 후에 다시 “1-1. Swap 메모리 확인&#34;을 해보면, 설정값만큼의 Swap 메모리가 활성화된 것을 확인할 수 있다.### 1-5. 시스템 재시작 시에도 Swap 메모리 활성화sudo vi /etc/fstab해당 파일을 열어 맨 아랫줄에/sawpfile swap swap default 0 0를 추가하면 된다.### 1-6. Swap 메모리 비활성화-- 단일 Swap 메모리 offsudo swapoff swapfile-- 전체 Swap 메모리 offswapoff -a### 1-7. Swap 메모리 삭제sudo rm -r swapfileswap out -&gt; swap in 되면서 실제 물리 메모리로 이동한다. (다소 시간이 걸리는 작업이다.)### 1-8. Swap 영역 초기화Swap 파티션 초기화sudo mkswap /dev/{swap partition}Swap 파일 초기화sudo truncate -s 0 /path/to/swapfilesudo chmod 600 /path/to/swapfilesudo mkswap /path/to/swapfileSwap 초기화 시, Swap 영역의 데이터가 모두 삭제된다. Swap 메모리 초기화 시에는해당 파티션, 해당 파일을 원마운트하고 비워야 한다.## 1-9. Swap 영역 다시 활성화Swap 파티션 활성화sudo swapon /dev/{swap partition}Swap 파일 활성화sudo swapon /path/to/swapfile## 2. Swap 메모리란?주 메모리(RAM)가 모두 사용되어 추가 메모리가 필요할 때 디스크 공간을 활용하여 부족한 메모리를 대체할 수 있는 공간이다. 운영 체제는 일부 데이터를 RAM에서 디스크의 Swap 영역(하드디스크의 특정 파티션 혹은 Swap 파일)으로 옮겨 메모리 부족상태를 해결한다. 하드디스크를 사용하는 것이 아니라 속도 측면에선 아주 떨어지지만 시스템 안정성과 성능 유지에 큰 역할을 한다. 실제 메모리보다 큰 프로그램을 실행하거나 동시에 더 많은 프로세스를 실행하는 데 사용된다. 예를 들어 ec2 프리티어의 경우 t2.micro RAM 은 1G 뿐이지만 임시로 swap 메모리를 설정하면, 여러 개 프로세스 띄울 수 있게 된다.그렇다면 RAM이 낮은 인스턴스를 사용하고 Swap메모리를 사용하는 것이 비용적으로 효율적일까?Swap 메모리는 데이터 전송속도가 느리기에 Swap 메모리 초기화 시에는해당 파티션, 해당 파일을 원마운트하고 비워야 한다. 영역으로 데이터를 옮기는 작업이 발생할 때 성능이 저하된다. 빈번한 Swap이 발생할 경우 성능향상을 위해서 RAM을 추가해야 한다.참고https://reakwon.tistory.com/96https://jw910911.tistory.com/122https://serverfault.com/questions/688627/swapon-failed-device-or-resource-busy-on-mounted-disk#Linux #swap memory</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Linux] 스왑 메모리(Swap Memory)의 개념과 적용방법" href="http://localhost:1313/posts/34/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[LLM] Google Cloud Discovery Engine 데이터 스토어 업로드 포맷
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [LLM] Google Cloud Discovery Engine 데이터 스토어 업로드 포맷" href="http://localhost:1313/posts/121/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] BRIN 인덱스의 원리 및 특징
    </h2>
  </header>
  <div class="entry-content">
    <p> ▪ Block range index의 약자▪ Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)▪ 특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)Block range는 테이블 내에서 근접한 물리주소를 가진 page 그룹을 의미한다. 각 Block range 에 대해 일부 요약 정보가 인덱스로 저장된다. 예를 들어 상점의 판매 주문을 저장하는 테이블에는 각 주문이 배치된 날짜 열이 있을 수 있으며 대부분의 경우 이전 주문시점에 맞게 순차적으로 주문정보가 들어갈 것이고, ZIP 코드 열을 저장하는 테이블에는 도시에 대한 모든 코드가 자연스럽게 그룹화되어 있을 것이다.BRIN 인덱스는 정기적인 비트맵 인덱스 검색을 통해 쿼리를 결과를 확인하고, 인덱스에 의해 저장된 요약 정보가 쿼리 조건과 일치하면, 범위 내 모든 페이지의 모든 튜플을 반환한다. 쿼리 실행기는 반환된 튜플을 다시 검사하고, 쿼리 조건과 일치하지 않는 튜플을 폐기한다. (결과가 일치하지 않아 폐기된 인덱스는 손실된다.) BRIN 인덱스는 매우 작기 때문에 인덱스를 스캔하면 순차적 스캔에 비해 오버헤드가 거의 발생하지 않지만, 일치하는 튜플이 없는 것으로 알려진 테이블의 많은 부분을 스캔하는 것은 피할 수 있다.BRIN 인덱스가 저장할 특정 데이터는 인덱스의 각 열에 대해 선택된 연산자 유형에 따라서도 달라진다. 예를 들어 선형 정렬 순서를 갖는 데이터 유형은 각 블록 범위 내에서 최솟값과 최댓값을 저장할 수 있고, 기하학적 유형은 블록 범위의 모든 객체에 대한 경계 정보를 저장할 수도 있다.## 2. BRIN 인덱스 관리Brin 인덱스가 생성될시, 모든 존재하는 heap page를 스캔하고, 각 block range마다 요약 인덱스 tuple을 생성하고 마지막으로 불완전한 block range를 생성한다. 새로운 page가 데이터로 가득 차면, 이미 요약된 block range가 새 튜플의 데이터로 요약 정보가 업데이트된다. 마지막 요약 범위에 속하지 않는 새 페이지가 생성되면 요약 튜플을 자동으로 획득하지 않고 나중에 요약 실행이 호출될 때까지 해당 튜플은 요약되지 않은 상태로 남아 해당 범위에 대한 초기 요약을 만든다. 이 과정을 직접 실행하는 몇 가지 방법이 있다. 테이블을 auto vacuum 하여 요약되지 않은 page ranges를 요약한다. 만약 auto summarize 파라미터가 on이라면(default 아님), autovacuum이 데이터베이스에 실행될 때마다 summarization이 실행된다.--요약 안된 전체 범위 요약brin_summarize_new_values(regclass)--주어진 page만 요약 (요약안됐을 경우에만)brin_summarize_range(regclass, bigint)을 통해 ranges에 summarization 실행 가능하다. 반대로 다음을 통해 요약을 해제 하는것도 가능하다. brin_desummarize_range(regclass, bigint)tuple의 기존값이 변경되어 인덱스 tuple이 더 이상 좋은 결과를 나타내지 못할 때 유용하다.## 3. BRIN VS B-TREE&gt; ▪ BRIN 인덱스는 B-TREE 인덱스보다 쿼리 성능이 좋다.▪ BRIN 인덱스는, B-TREE에서 사용하는 용량의 1%만 사용한다.▪ BRIN이 특정 블록 범위만 다루다 보니, 검색 범위를 이탈할 경우 해당하는 블록 범위 전체를 검사한다.▪ BRIN은 lossy index이므로, 데이터의 hash 값을 저장하는 컬럼에 BRIN을 써도 데이터가 포함된 블록을 정확히 반환하지 못한다.▪ 인덱스 생성 속도가 BRIN이 더 빠르다.## 4. 연산자이름인덱싱 된 데이터 유형인덱싱 가능한 연산자abstime_minmax_opsabstime= &gt;int8_minmax_opsbigint= &gt;bit_minmax_opsbit= &gt;varbit_minmax_opsbit varying= &gt;box_inclusion_opsbox» ~= @&gt; &gt; |&amp;&gt;bytea_minmax_opsbytea= &gt;bpchar_minmax_opscharacter= &gt;char_minmax_ops&#34;char&#34;= &gt;date_minmax_opsdate= &gt;float8_minmax_opsdouble precision= &gt;inet_minmax_opsinet= &gt;network_inclusion_opsinet&amp;&amp; »= &gt;int4_minmax_opsinteger= &gt;interval_minmax_opsinterval= &gt;macaddr_minmax_opsmacaddr= &gt;name_minmax_opsname= &gt;numeric_minmax_opsnumeric= &gt;pg_lsn_minmax_opspg_lsn= &gt;oid_minmax_opsoid= &gt;range_inclusion_opsany range type» @&gt; &gt;=float4_minmax_opsreal= &gt;reltime_minmax_opsreltime= &gt;int2_minmax_opssmallint= &gt;text_minmax_opstext= &gt;tid_minmax_opstid= &gt;timestamp_minmax_opstimestamp without time zone= &gt;timestamptz_minmax_opstimestamp with time zone= &gt;time_minmax_opstime without time zone= &gt;timetz_minmax_opstime with time zone= &gt;uuid_minmax_opsuuid= &gt;참고 :https://bajratech.github.io/2016/09/16/Postgres-BRIN-Index/https://www.postgresql.kr/docs/13/brin-intro.html#brin #Index #PostgreSQL
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] BRIN 인덱스의 원리 및 특징" href="http://localhost:1313/posts/11/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] GIN인덱스의 원리 및 특징
    </h2>
  </header>
  <div class="entry-content">
    <p> Generalized Inverted Index의 약자이다. 이전 포스트인 full text search에서 사용하는 인덱스의 유형. 기본 구조는 B-tree와 유사하지만, 저장 형태가 다르다. 저장된 요소 자제에 대한 검색이 아닌 인덱스 컬럼의 값을 split 한 token인 lexeme 배열에 대해서 검색을 한다. array_ops, tsvector_ops, jsonb_ops, jsonb_path_ops 등 의 built-in operators를 통해 접근이 가능하다.## 2. full text search에서의 적용### 2-1. 샘플 테이블 및 데이터 생성create table ts(doc text, doc_tsv tsvector);insert into ts(doc) values(&#39;Can a sheet slitter slit sheets?&#39;),(&#39;How many sheets could a sheet slitter slit?&#39;),(&#39;I slit a sheet, a sheet I slit.&#39;),(&#39;Upon a slitted sheet I sit.&#39;),(&#39;Whoever slit the sheets is a good sheet slitter.&#39;),(&#39;I am a sheet slitter.&#39;),(&#39;I slit sheets.&#39;),(&#39;I am the sleekest sheet slitter that ever slit sheets.&#39;),(&#39;She slits the sheet she sits on.&#39;);update ts set doc_tsv = to_tsvector(doc);create index on ts using gin(doc_tsv);select doc from ts where doc_tsv @@ to_tsquery(&#39;many &amp; slitter&#39;);### 2-2. 조회 결과 및 플랜 확인 QUERY PLAN---------------------------------------------------------------------Bitmap Heap Scan on tsRecheck Cond: (doc_tsv @@ to_tsquery(&#39;many &amp; slitter&#39;::text))-&gt; Bitmap Index Scan on ts_doc_tsv_idxIndex Cond: (doc_tsv @@ to_tsquery(&#39;many &amp; slitter&#39;::text))(4 rows)`` doc---------------------------------------------How many sheets could a sheet slitter slit?(1 row)### 2-3. 작동 방식&gt; ▪ 먼저 쿼리에서 검색에 사용할 lexeme인 ‘many’와 ‘slitter’를 추출한다. ▪ lexeme B-tree에서 2개의 키를 동시에 찾는다.- mani = (0,2)- slitter = (0,1),(0,2),(1,2),(1,3),(2,2)▪ 마지막으로, 발견된 TID각각에 대해 검색 쿼리에 부합하는지 확인한다.(예제의 쿼리의 경우 and 조건이기에 (0,2)에 해당하는 TID만 리턴하게 된다.)## 3. 특징▪ GIN의 업데이트는 매우 느리다. document는 보통 많은 lexeme을 포함하고, 1개의 document가 업데이트되거나 추가된다고 해도 인덱스 트리 내에서는 많은 업데이트가 진행된다.▪ 반면에, 몇몇의 document가 동시에 업데이트된다면, 중복되는 Lexeme들이 존재할 것이고, 총 인덱스 업데이트량은 개별 업데이트 시보다 줄어들 것이다.▪ GIN인덱스의 또 하나의 특징은 항상 결과를 bitmap으로 리턴한다는 것이다. (TID 자체로 리턴하지 않는다.) 그렇기 때문에 Limit을 통한 결괏값 제한은 그렇게 효율적이지 않다.▪ full text search, array, json 등의 타입 조회에 효율적이다.참고 : https://postgrespro.com/blog/pgsql/4261647#Gin #Index #PostgreSQL
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] GIN인덱스의 원리 및 특징" href="http://localhost:1313/posts/10/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] Visibility Map(가시성 맵)의 개념, 원리, 생명주기 및 정보 확인 방법
    </h2>
  </header>
  <div class="entry-content">
    <p>Visibility Map은 트랜잭션에서 데이터에 접근할 때 어떤 데이터가 가시적인지(모든 트랜잭션에서 읽을 수 있는지), 안정적인지 (동결된 튜플인지) 판별하는데 도움을 준다. 데이터 접근 시 불필요한 I/O작업을 줄여주고, 데이터베이스가 어떤 페이지를 직접 접근할 수 있는지를 빠르게 판단함으로써 시스템의 효율적을 올려주는 역할을 한다.## 2. Visibility Map(가시성 맵)의 데이터 관리Visibility Map은 데이터를 주요 데이터와는 별도의 파일(fork)에 _vm 접미사를 붙여 관리한다. 예를 들어 예를 들어 employees 테이블이 있다고 하면 테이블의 Visibility Map은 별도의 포크에 저장된다. 이 포크의 이름은 파일 노드 번호에 _vm 접미사를 붙여 구성되며, 예를 들어 파일 노드번호가 12345인 경우 VM 파일은 12345_vm으로 저장된다. 데이터에는 해당 테이블의 page가 모든 트랜잭션에 보이는지, 동결된 튜플만을 포함하는지 등의 정보를 저장한다. 데이터베이스가 employees 테이블을 조회할 때, 가시성 맵을 먼저 확인한다. 만약 쿼리가 접근하려는 pages가 모든 트랜잭션에게 보이는 상태라고 확인되면, 시스템은 데이터에 더 빠르게 접근한다. 불필요한 버전검사나 락을 안 해도 되기에 성능이 향상된다.## 3. Visibility Map(가시성 맵)의 원리Visiblity Map은 힙 pages당 2개의 비트를 별도로 저장한다. 첫 번째 비트가 설정되어 있으면, 해당 페이지가 모두 visible(가시적) 한 상태이고, 이는 vacuum이 필요한 튜플을 포함하지 않는다는 뜻이다. 이는 인덱스 영역의 tuple만을 사용하여 index-only-scan으로 쿼리를 조회할 때도 사용된다. index-only-scan은 해당 포스트에서 확인 가능하다.2024.03.13 - [Postgresql] - [PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용[PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용1. Index-Only Scans PostgreSQL의 모든 인덱스는 “보조(Secondary)” 인덱스이다. 각 인덱스는 테이블의 메인 데이터 영역(테이블의 heap 영역)과 분리되어서 저장된다. 그렇기 때문에 일반적인 인덱스 스캔에junhkang.tistory.com두 번째 bit가 설정되어 있다면 모든 pages의 튜플이 frozen(동결된) 상태라는 뜻이다. 이 상태에선 일반적인 vacuum은 물론 anti-wraparound vacuum도 동작시킬 필요가 없다.anti-wraparound-vacuum - 전체 데이터베이스를 검사하여 트랜잭션 ID가 안전한 범위 내에 있는지 확인하여, 필요에 따라 조정하며 트랜잭션 ID의 오버플로우를 방지한다. 트랜잭션 ID에 대한 상세 내용은 해당 포스트에서 확인 가능하다.2024.03.08 - [Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 작동원리[PostgreSQL] 트랜잭션(Transaction)의 작동원리1. 기본 트랜잭션의 개념 및 원리 트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다. 2023.10.10 - [Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용 [PostgreSQL] 트랜잭션(Tjunhkang.tistory.comVisiblity Map의 2가지 비트는 최대한 보수적으로 해석된다. 1, 2 번째 비트가 설정되어 있을 경우에는 무조건 참이지만, 비트가 설정되지 않을 경우에는 참 일수도 거짓일 수도 있다.## 4. Visibility Map(가시성 맵)의 생명주기Visiblity Map의 비트는 vacuum에 의해서만 설정된다. 데이터베이스 내의 pages에 vacuum 작업이 수행되면 관련 Visiblity Map의 비트가 설정이 되고, 해당 pages가 모든 트랜잭션에서 완전히 가시적임을 표시하며, 더 이상 vacuum 안 해도 됨을 나타낸다. 그 후에 pages의 데이터가 하나라도 수정(update, insert, delete 등) 될 경우, VM의 비트는 초기화된다. 데이터의 상태가 변경되었기에 vacuum 작업 대상에 포함시켜야 함을 나타낸다.## 5. Visibility Map(가시성 맵) 정보 확인pg_visibility 함수를 사용해서 vm에 저장된 정보를 확인할 수 있다.- pg_visibility_map(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen OUT boolean) returns record- 해당 테이블, 해당 블록의 모든 VM의 visible, frozen 비트 조회- pg_visibility(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen OUT boolean, pd_all_visible OUT boolean) returns record - 해당 테이블, 해당 블록의 모든 VM의 visible, frozen 비트 조회 &#43; PD_ALL_VISIBLE 비트- pg_visibility_map(relation regclass, blkno OUT bigint, all_visible OUT boolean, all_frozen OUT boolean) returns setof record - 해당 테이블의 모든 블록의 VM의 visible, frozen 비트 조회- pg_visibility(relation regclass, blkno OUT bigint, all_visible OUT boolean, all_frozen OUT boolean, pd_all_visible OUT boolean) returns setof record - 해당 테이블의 모든 블록의 VM의 visible, frozen 비트 조회 &#43; PD_ALL_VISIBLE 비트- pg_visibility_map_summary(relation regclass, all_visible OUT bigint, all_frozen OUT bigint) returns record - VM에 연관 있는 테이블의 visible 페이지 수량, frozen 페이지 수량 확인- pg_check_frozen(relation regclass, t_ctid OUT tid) returns setof tid - VM에 frozen으로 마킹되어 있는 pages 중 non-frozen 튜플의 TID, 존재해서는 안 되는 경우로, 뭔가 조회가 된다면 VM에 문제가 있는 것- pg_check_visible(relation regclass, t_ctid OUT tid) returns setof tid - VM에 visible으로 마킹되어 있는 pages 중 non-visible 튜플의 TID, 존재해서는 안 되는 경우로, 뭔가 조회가 된다면 VM에 문제가 있는 것- pg_truncate_visibility_map(relation regclass) returns void - 해당 테이블의 VM을 truncate 한다. VM에 문제가 있는 경우 강제로 재설정이 필요할 때 사용. 해당 테이블의 첫 번째 vacuum이 실행될 때 재생성되며, 그전까지는 모든 VM이 모두 0 값으로 유지참고https://www.postgresql.org/docs/16/storage-vm.htmlhttps://www.postgresql.org/docs/16/pgvisibility.html#PostgreSQL #Visibility Map #가시성 맵
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] Visibility Map(가시성 맵)의 개념, 원리, 생명주기 및 정보 확인 방법" href="http://localhost:1313/posts/79/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] 날짜 형태 검증하기 (ERROR: date/time field value out of range)
    </h2>
  </header>
  <div class="entry-content">
    <p>데이터 베이스에서 날짜형태로 형 변환을 하는 것은 다음과 같은 방법으로 쉽게 가능하다.-- Unix타임(int)형 변환SELECT to_timestamp(1658792421)-- varchar 타입 변환SELECT to_timestamp(&#39;20231026&#39;,&#39;yyyymmdd&#39;)-- 날짜형을 char로 변환SELECT to_char(to_timestamp(1658792421), &#39;DD-MM-YYYY&#39;)2. 유효한 날짜형태 검증데이터 정제가 완료되지 않아 조회하려는 데이터에 날짜유형에서 벗어난 데이터 (‘20231301’,202301’, ‘20231232’ 등)가 하나라도 있을 경우 조회 자체가 안된다. 그럴 경우 날짜 규격에 맞지 않는 데이터를 보정 후 연산해야 하는 경우가 있는데 단순 월별 케이스문으로 분리하여 날짜 유형에 어긋나는 경우를 찾을 수도 있지만 row마다 날짜 유형이 다르거나 윤달을 체크할 수 없다.그래서 날짜 형태자체를 변환시도하고 성공 여부에 따라 결과값을 추출하는 함수를 생성해야 한다.CREATE OR REPLACE FUNCTION VALIDATE_DATE(S VARCHAR) RETURNS INT AS$$BEGINIF COALESCE(S, &#39;-&#39;) = &#39;-&#39; THENRETURN -1;END IF;PERFORM S::DATE;RETURN 0;EXCEPTIONWHEN OTHERS THENRETURN 1;END;$$ LANGUAGE PLPGSQL;이제 VALIDATE_DATE() 함수를 실행시키면, 날짜유형, 윤달에 상관없이 해당 데이터가 유효한 날짜라면 0, 유효하지 않은 데이터라면 1, null이라면 -1을 리턴하게 된다.다음과 같이 유효한 날짜 유형의 데이터만 조회하거나SELECT date_column from tableWHERE VALIDATE_DATE(date_column) = 0;날짜 유형에 어긋나는 데이터들을 일괄 null 업데이트하여 처리할 수 있다.UPDATE table SET date_column = NULLWHERE VALIDATE_DATE(date_column) = 1#PostgreSQL
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] 날짜 형태 검증하기 (ERROR: date/time field value out of range)" href="http://localhost:1313/posts/38/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/tags/333333/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Jun Kang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
