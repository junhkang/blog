<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[WEB] JWT 토큰 인증의 개념과 장단점 | Jun Kang's Blog</title>
<meta name=keywords content="web,JWT"><meta name=description content="
1. JWT의 개념
JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 
보통 Authorization HTTP 헤더를 Bearer <토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 
2. JWT 구조
header, payload, signature가 각각 . 으로 구분되어 있다"><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/41/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/41/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/41/"><meta property="og:title" content="[WEB] JWT 토큰 인증의 개념과 장단점 | Jun Kang's Blog"><meta property="og:description" content="
1. JWT의 개념
JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 
보통 Authorization HTTP 헤더를 Bearer <토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 
2. JWT 구조
header, payload, signature가 각각 . 으로 구분되어 있다"><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/41/"><meta property="twitter:title" content="[WEB] JWT 토큰 인증의 개념과 장단점 | Jun Kang's Blog"><meta property="twitter:description" content="
1. JWT의 개념
JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 
보통 Authorization HTTP 헤더를 Bearer <토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 
2. JWT 구조
header, payload, signature가 각각 . 으로 구분되어 있다"><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/41/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[WEB] JWT 토큰 인증의 개념과 장단점"><meta property="og:description" content=" 1. JWT의 개념 JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다. 보통 Authorization HTTP 헤더를 Bearer <토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다. 2. JWT 구조 header, payload, signature가 각각 . 으로 구분되어 있다"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-01T18:47:24+00:00"><meta property="article:modified_time" content="2023-11-01T18:47:24+00:00"><meta property="article:tag" content="Web"><meta property="article:tag" content="JWT"><meta name=twitter:card content="summary"><meta name=twitter:title content="[WEB] JWT 토큰 인증의 개념과 장단점"><meta name=twitter:description content="
1. JWT의 개념
JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 
보통 Authorization HTTP 헤더를 Bearer <토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 
2. JWT 구조
header, payload, signature가 각각 . 으로 구분되어 있다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[WEB] JWT 토큰 인증의 개념과 장단점","item":"https://junhkang.com/posts/41/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[WEB] JWT 토큰 인증의 개념과 장단점","name":"[WEB] JWT 토큰 인증의 개념과 장단점","description":" 1. JWT의 개념 JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다. 보통 Authorization HTTP 헤더를 Bearer \u0026lt;토큰\u0026gt; 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다. 2. JWT 구조 header, payload, signature가 각각 . 으로 구분되어 있다\n","keywords":["web","JWT"],"articleBody":" 1. JWT의 개념 JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다. 보통 Authorization HTTP 헤더를 Bearer \u003c토큰\u003e 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다. 2. JWT 구조 header, payload, signature가 각각 . 으로 구분되어 있다\n.. header - 토큰의 타입, 서명 알고리즘 이 저장 { \"alg\": \"HS256\", \"typ\": \"JWT } payload - 사용자의 인증 / 인가 정보를 key-value 형태로 저장 { \"sub\": \"1234567890\", \"name\": \"Ado Kukic\", \"admin\": true, \"iat\": 1464297885 } signature - header와 payload가 비밀키로 서명되어 저장, header를 디코딩한 값, payload를 디코딩한 값을 합치고 서버의 개인키로 암호화를 한 값 3. JWT 표준 스펙 payload의 key의 값은 자유롭게 설정이 가능하지만, 네트워크 상으로 전송되기에 크기가 작아야 유리하기에 JSON 형태로 데이터를 저장할 때 키를 3글자로 줄이는 관행이 있다. 다음은 JWT key의 표준 스펙이다.\nsub(subject) - 인증주체 iss(issue) - 토큰 발급처 typ(type) - 토큰유형 alg(algorithm) - 서명 알고리즘 iat(issued at) - 발급 시각 exp(expiration time) - 만료 시각 aud(audience) - 클라이언트 jti(JWT Id) - JWT 토큰 식별자, iss가 여러 명일 때 구분하기 위한 값 4. JWT를 통한 인증 JWT는 OAuth, OIDC 프로토콜과 함께 API 인증 및 인가를 위해 주로 사용된다. 보통 클라이언트가 서비스 인가 서버를 통해 로그인을 성공하면 JWT 토큰을 획득하고 클라이언트는 해당 서비스의 API를 호출할 때 JWT토큰을 보내서 원하는 자원에 접근하거나 허용된 작업을 수행할 수 있게 된다. 5. 장점 토큰 검증만을 통해 사용자 정보를 확인가능 하여 추가 검증 로직이 필요 없다. 매번 세션이나 데이터베이스 같은 인증 저장소가 필요 없다. 사용자가 늘어나더라도 사용자 인증을 위한 추가 리소스 비용이 없다. 다른 서비스에 공통 스펙으로 사용이 가능하여 확장성이 높다. 6. 한계 base64 인코딩 정보를 전달하기에 전달량이 많다. 토큰이 탈취당할 시 만료될 때까지 대처가 불가능하다. Payload부분은 누구든 디코딩하여 확인할 수 있다. 위의 세 가지 예시로 JWT 토큰을 생성하면 다음과 같다.\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbyBLdWtpYyIsImFkbWluIjp0cnVlLCJpYXQiOjE0NjQyOTc4ODV9.XRt6GrUEcSJiGRIU0jScszrjunhot3l75g6x8ZCbpV0 토큰 자체는 암호화되어있지 않기에 jwt.io 등을 통해 디코딩할 경우 데이터를 바로 확인이 가능하다.\n7. 주의사항 JWT토큰은 누구나 열람이 가능하기에 민감한 사용자 정보를 토큰에 그대로 저장하면 안 된다. 토큰에는 사용자를 식별할 수 있는 ID정도만 저장해야 하며 꼭 사용해야 하는 경우에도 민감 사용자 정보는 반드시 별도 암호화하여 토큰을 디코딩한 후에도 식별 불가하게 해야 한다. JWT토큰을 탈취당할 경우 대처가 힘들기에 만료기간을 적절히 짧게 사용해야 하지만 JWT토큰 유효시간 무작정 짧게 설정 시 사용 편의성이 떨어질 수 있다. 이 경우에는 다음과 같은 방식을 통해 짧은 유효기간을 보완할 수 있다. sliding session - 특정서비스를 계속 사용하는 유저에게 만료 시간을 연장 refresh token - 기존 access 토큰에 추가로 더 긴 만료기간의 refresh 토큰을 발급하여, access토큰 만료시 refresh토큰을 사용하여 새로운 access토큰을 발급 참고\nhttps://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC\nhttps://dzone.com/articles/cookies-vs-tokens-the-definitive-guide\nhttps://brunch.co.kr/@jinyoungchoi95/1\nhttps://www.daleseo.com/jwt/#:~:text=JWT(Json%20Web%20Token)%EB%8A%94,%EC%A3%BC%EA%B3%A0%20%EB%B0%9B%EA%B8%B0%20%EC%9C%84%ED%95%B4%EC%84%9C%20%EC%82%AC%EC%9A%A9%EB%90%A9%EB%8B%88%EB%8B%A4. ","wordCount":"430","inLanguage":"en","datePublished":"2023-11-01T18:47:24Z","dateModified":"2023-11-01T18:47:24Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/41/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[WEB] JWT 토큰 인증의 개념과 장단점</h1><div class=post-meta><span title='2023-11-01 18:47:24 +0000 UTC'>November 1, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=jwt의-개념 ke-size=size26>1. JWT의 개념<a hidden class=anchor aria-hidden=true href=#jwt의-개념>#</a></h2><p>JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 </p><p>보통 Authorization HTTP 헤더를 Bearer &lt;토큰> 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 </p><h2 id=2-jwt-구조>2. JWT 구조<a hidden class=anchor aria-hidden=true href=#2-jwt-구조>#</a></h2><p>header, payload, signature가 각각 . 으로 구분되어 있다</p><pre tabindex=0><code>&lt;header&gt;.&lt;payload&gt;.&lt;signature&gt;
</code></pre><ul><li><strong>header -</strong> 토큰의 타입, 서명 알고리즘 이 저장</li></ul><pre tabindex=0><code>{
  &#34;alg&#34;: &#34;HS256&#34;,
  &#34;typ&#34;: &#34;JWT
}
</code></pre><p> </p><ul><li><strong>payload -</strong> 사용자의 인증 / 인가 정보를 key-value 형태로 저장</li></ul><pre tabindex=0><code>{
  &#34;sub&#34;: &#34;1234567890&#34;,
  &#34;name&#34;: &#34;Ado Kukic&#34;,
  &#34;admin&#34;: true,
  &#34;iat&#34;: 1464297885
}
</code></pre><ul><li><strong>signature -</strong> header와 payload가 비밀키로 서명되어 저장, header를 디코딩한 값, payload를 디코딩한 값을 합치고 서버의 개인키로 암호화를 한 값</li></ul><p><img loading=lazy src=/images/posts/41/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-01%20%EC%98%A4%ED%9B%84%206.04.05.png></p><h2 id=jwt-표준-스펙 ke-size=size26>3. JWT 표준 스펙<a hidden class=anchor aria-hidden=true href=#jwt-표준-스펙>#</a></h2><p>payload의 key의 값은 자유롭게 설정이 가능하지만, 네트워크 상으로 전송되기에 크기가 작아야 유리하기에 JSON 형태로 데이터를 저장할 때 키를 3글자로 줄이는 관행이 있다. 다음은 JWT key의 표준 스펙이다.</p><ul><li><strong>sub(subject) -</strong> 인증주체</li><li><strong>iss(issue) -</strong> 토큰 발급처 </li><li><strong>typ(type) -</strong> 토큰유형</li><li><strong>alg(algorithm) -</strong> 서명 알고리즘 </li><li><strong>iat(issued at) -</strong> 발급 시각 </li><li><strong>exp(expiration time) -</strong> 만료 시각 </li><li><strong>aud(audience) -</strong> 클라이언트 </li><li><strong>jti(JWT Id) -</strong> JWT 토큰 식별자, iss가 여러 명일 때 구분하기 위한 값</li></ul><h2 id=jwt를-통한-인증 ke-size=size26>4. JWT를 통한 인증<a hidden class=anchor aria-hidden=true href=#jwt를-통한-인증>#</a></h2><p><img loading=lazy src=/images/posts/41/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-01%20%EC%98%A4%ED%9B%84%206.25.46.png></p><p>JWT는 OAuth, OIDC 프로토콜과 함께 API 인증 및 인가를 위해 주로 사용된다. 보통 클라이언트가 서비스 인가 서버를 통해 로그인을 성공하면 JWT 토큰을 획득하고 클라이언트는 해당 서비스의 API를 호출할 때 JWT토큰을 보내서 원하는 자원에 접근하거나 허용된 작업을 수행할 수 있게 된다.
 </p><h2 id=5-장점>5. 장점<a hidden class=anchor aria-hidden=true href=#5-장점>#</a></h2><ul><li>토큰 검증만을 통해 사용자 정보를 확인가능 하여 추가 검증 로직이 필요 없다.</li><li>매번 세션이나 데이터베이스 같은 인증 저장소가 필요 없다.</li><li>사용자가 늘어나더라도 사용자 인증을 위한 추가 리소스 비용이 없다.</li><li>다른 서비스에 공통 스펙으로 사용이 가능하여 확장성이 높다.</li></ul><h2 id=한계 ke-size=size26>6. 한계<a hidden class=anchor aria-hidden=true href=#한계>#</a></h2><ul><li>base64 인코딩 정보를 전달하기에 전달량이 많다.</li><li>토큰이 탈취당할 시 만료될 때까지 대처가 불가능하다.</li><li>Payload부분은 누구든 디코딩하여 확인할 수 있다.</li></ul><p>위의 세 가지 예시로 JWT 토큰을 생성하면 다음과 같다.</p><pre tabindex=0><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbyBLdWtpYyIsImFkbWluIjp0cnVlLCJpYXQiOjE0NjQyOTc4ODV9.XRt6GrUEcSJiGRIU0jScszrjunhot3l75g6x8ZCbpV0
</code></pre><p>토큰 자체는 암호화되어있지 않기에 jwt.io 등을 통해 디코딩할 경우 데이터를 바로 확인이 가능하다.</p><p><img loading=lazy src=/images/posts/41/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-01%20%EC%98%A4%ED%9B%84%206.14.12.png></p><h2 id=주의사항 ke-size=size26>7. 주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h2><ul><li>JWT토큰은 누구나 열람이 가능하기에 민감한 사용자 정보를 토큰에 그대로 저장하면 안 된다.</li><li>토큰에는 사용자를 식별할 수 있는 ID정도만 저장해야 하며 꼭 사용해야 하는 경우에도 민감 사용자 정보는 반드시 별도  암호화하여 토큰을 디코딩한 후에도 식별 불가하게 해야 한다.</li><li>JWT토큰을 탈취당할 경우 대처가 힘들기에 만료기간을 적절히 짧게 사용해야 하지만 JWT토큰 유효시간 무작정 짧게 설정 시 사용 편의성이 떨어질 수 있다. 이 경우에는 다음과 같은 방식을 통해 짧은 유효기간을 보완할 수 있다.<ul><li><strong>sliding session -</strong> 특정서비스를 계속 사용하는 유저에게 만료 시간을 연장</li><li><strong>refresh token -</strong> 기존 access 토큰에 추가로 더 긴 만료기간의 refresh 토큰을 발급하여, access토큰 만료시 refresh토큰을 사용하여 새로운 access토큰을 발급
 </li></ul></li></ul><p> </p><p> </p><p><strong>참고</strong></p><ul><li><p><a href=https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC>https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC</a></p></li><li><p><a href=https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide>https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide</a></p></li><li><p><a href=https://brunch.co.kr/@jinyoungchoi95/1>https://brunch.co.kr/@jinyoungchoi95/1</a></p></li><li><p><a href=https://www.daleseo.com/jwt/#>https://www.daleseo.com/jwt/#</a>:~:text=JWT(Json%20Web%20Token)%EB%8A%94,%EC%A3%BC%EA%B3%A0%20%EB%B0%9B%EA%B8%B0%20%EC%9C%84%ED%95%B4%EC%84%9C%20%EC%82%AC%EC%9A%A9%EB%90%A9%EB%8B%88%EB%8B%A4.
 </p></li></ul><p> </p><p> </p><p> </p><p> </p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/web/>Web</a></li><li><a href=https://junhkang.com/tags/jwt/>JWT</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>