<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] B-tree 인덱스의 원리 및 특징 | Jun Kang's Blog</title>
<meta name=keywords content="Index,PostgreSQL,B-Tree"><meta name=description content="
PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.
그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.
1. B-tree 인덱스란?

▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조
▪ B-tree는 Binary 가 아닌 Balanced의 약자
▪ 컬럼의 기존 데이터를 변형하지 않음
▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지
2. B-tree 인덱스의 원리
▪ B-tree 인덱스의 자료구조 형태
"><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/posts/6/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="http://localhost:1313/posts/6/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] B-tree 인덱스의 원리 및 특징"><meta property="og:description" content=" PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.
그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.
1. B-tree 인덱스란? ▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조
▪ B-tree는 Binary 가 아닌 Balanced의 약자
▪ 컬럼의 기존 데이터를 변형하지 않음
▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지
2. B-tree 인덱스의 원리 ▪ B-tree 인덱스의 자료구조 형태 "><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-12T19:12:12+00:00"><meta property="article:modified_time" content="2023-09-12T19:12:12+00:00"><meta property="article:tag" content="Index"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="B-Tree"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] B-tree 인덱스의 원리 및 특징"><meta name=twitter:description content="
PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.
그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.
1. B-tree 인덱스란?

▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조
▪ B-tree는 Binary 가 아닌 Balanced의 약자
▪ 컬럼의 기존 데이터를 변형하지 않음
▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지
2. B-tree 인덱스의 원리
▪ B-tree 인덱스의 자료구조 형태
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] B-tree 인덱스의 원리 및 특징","item":"http://localhost:1313/posts/6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] B-tree 인덱스의 원리 및 특징","name":"[PostgreSQL] B-tree 인덱스의 원리 및 특징","description":" PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.\n그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.\n1. B-tree 인덱스란? ▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조\n▪ B-tree는 Binary 가 아닌 Balanced의 약자\n▪ 컬럼의 기존 데이터를 변형하지 않음\n▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지\n2. B-tree 인덱스의 원리 ▪ B-tree 인덱스의 자료구조 형태 ","keywords":["Index","PostgreSQL","B-Tree"],"articleBody":" PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.\n그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.\n1. B-tree 인덱스란? ▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조\n▪ B-tree는 Binary 가 아닌 Balanced의 약자\n▪ 컬럼의 기존 데이터를 변형하지 않음\n▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지\n2. B-tree 인덱스의 원리 ▪ B-tree 인덱스의 자료구조 형태 최상위 Root를 Meta page, 최하위 노드를 Leaf page라고 한다. Root page에서 leaf page들 간의 내부 page 수가 항상 같기에, 어떤 value를 검색하여도 동일한 시간이 걸린다. 데이터는 non-decreasing order로 정렬되어 있고, 동일 레벨의 page들끼리는 양방향으로 연결되어 있기에 (ex. 그림의 25 \u003c-\u003e32) 순차적 데이터를 root를 확인할 필요 없이 한 번에 찾을 수 있다.\n▪ 정확히 일치하는 데이터를 찾기 위해 데이터를 탐색하는 순서 (\"indexed-field = *expression\") 인덱스 컬럼에 동일 데이터가 너무 많이 분포되어있어 한 page에 넘치게 데이터가 들어있을 수 있기에, 내부 페이지에서 정확히 일치하는 page를 찾게 되면 왼쪽으로 한 page를 이동하여 left to right 방향으로 인덱스를 조회한다.\n▪ 불일치에 해당하는 데이터를 찾기 위해 데이터를 탐색하는 순서 (\"indexed-field ≤ expression\" (or \"indexed-field ≥ expression\")), 다음의 경우, 먼저 일치하는 leaf page 를 찾은 후 leaf page 간의 이동으로 조회한다.\n▪ 범위로 조회할 경우 데이터를 탐색하는 순서 (\"indexed-field ≤ expression\" and \"indexed-field ≥ expression\"), A\u003c indexed-field \u003c B 일경우 A에 해당하는 leaf page를 찾은 후 B의 조건에 맞는 범주 내의 데이터까지 leaf page 간의 이동으로 조회한다. 혹은 반대 방향으로, B부터 조건에 맞는 데이터 범주까지 leaf page 간 이동하여 조회한다. 3. B-tree 인덱스의 특징 인덱스 자체의 특징 및 설계방법은 이전 포스트 (https://junhkang.tistory.com/5) 에서 다루고 있으니 참고, B-tree 인덱스만의 특징은 다음과 같다.\n▪ 데이터가 동일한지, 특정 범주에 있는 데이터인지 여부로 조회할 때 사용\n▪ Postgresql 옵티마이저는 “\u003c \u003c= = \u003e= \u003e“와 같은 수식을 사용할때 B-tree 인덱스를 고려 ▪ 수식의 조합인 IN\u0026\u0026 Between도 고려\n▪ IS NULL, IS NOT NULL 조건도 인덱스 사용 가능\n▪ 패턴매칭 (like)도 문자열의 시작에 매칭을 사용하지 않으면 적용 가능 ( ’test%’, ’test^’)\n▪ Ilike, ~* 에는 패턴이 알파벳 외의 문자(대/소문자 영향을 안 받는 문자로 시작하는 경우)로 시작할 때만 사용 가능 참고\nhttps://postgrespro.com/blog/pgsql/4161516 ","wordCount":"335","inLanguage":"en","datePublished":"2023-09-12T19:12:12Z","dateModified":"2023-09-12T19:12:12Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/6/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] B-tree 인덱스의 원리 및 특징</h1><div class=post-meta><span title='2023-09-12 19:12:12 +0000 UTC'>September 12, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p>PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.</p><p>그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.</p><h2 id=b-tree-인덱스란 ke-size=size26>1. B-tree 인덱스란?<a hidden class=anchor aria-hidden=true href=#b-tree-인덱스란>#</a></h2><blockquote><p>▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조<br>▪ B-tree는 Binary 가 아닌 Balanced의 약자<br>▪ 컬럼의 기존 데이터를 변형하지 않음<br>▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지</p></blockquote><h2 id=b-tree-인덱스의-원리 ke-size=size26>2. B-tree 인덱스의 원리<a hidden class=anchor aria-hidden=true href=#b-tree-인덱스의-원리>#</a></h2><h3 id=b-tree-인덱스의-자료구조-형태 ke-size=size23>▪ B-tree 인덱스의 자료구조 형태<a hidden class=anchor aria-hidden=true href=#b-tree-인덱스의-자료구조-형태>#</a></h3><p><img loading=lazy src=/images/posts/6/img.png></p><p>최상위 Root를 Meta page, 최하위 노드를 Leaf page라고 한다. Root page에서 leaf page들 간의 내부 page 수가 항상 같기에, 어떤 value를 검색하여도 동일한 시간이 걸린다. 데이터는 non-decreasing order로 정렬되어 있고, 동일 레벨의 page들끼리는 양방향으로 연결되어 있기에 (ex. 그림의 25 &lt;->32) 순차적 데이터를 root를 확인할 필요 없이 한 번에 찾을 수 있다.</p><h3 id=정확히-일치하는-데이터를-찾기-위해-데이터를-탐색하는-순서-indexed-field-expression ke-size=size23>▪ 정확히 일치하는 데이터를 찾기 위해 데이터를 탐색하는 순서 ("<em>indexed-field</em> = *expression")<a hidden class=anchor aria-hidden=true href=#정확히-일치하는-데이터를-찾기-위해-데이터를-탐색하는-순서-indexed-field-expression>#</a></h3><p><img loading=lazy src=/images/posts/6/img_1.png></p><p>인덱스 컬럼에 동일 데이터가 너무 많이 분포되어있어 한 page에 넘치게 데이터가 들어있을 수 있기에, 내부 페이지에서 정확히 일치하는 page를 찾게 되면 왼쪽으로 한 page를 이동하여 left to right 방향으로 인덱스를 조회한다.</p><h3 id=불일치에-해당하는-데이터를-찾기-위해-데이터를-탐색하는-순서-indexed-field-expression-or-indexed-field-expression ke-size=size23>▪ 불일치에 해당하는 데이터를 찾기 위해 데이터를 탐색하는 순서 ("<em>indexed-field</em> ≤ <em>expression</em>" (or "<em>indexed-field</em> ≥ <em>expression</em>")),<a hidden class=anchor aria-hidden=true href=#불일치에-해당하는-데이터를-찾기-위해-데이터를-탐색하는-순서-indexed-field-expression-or-indexed-field-expression>#</a></h3><p><img loading=lazy src=/images/posts/6/img_2.png></p><p>다음의 경우, 먼저 일치하는 leaf page 를 찾은 후 leaf page 간의 이동으로 조회한다.</p><h3 id=범위로-조회할-경우-데이터를-탐색하는-순서-indexed-field-expression-and-indexed-field-expression ke-size=size23>▪ 범위로 조회할 경우 데이터를 탐색하는 순서 ("<em>indexed-field</em> ≤ <em>expression</em>" and "<em>indexed-field</em> ≥ <em>expression</em>"),<a hidden class=anchor aria-hidden=true href=#범위로-조회할-경우-데이터를-탐색하는-순서-indexed-field-expression-and-indexed-field-expression>#</a></h3><p><img loading=lazy src=/images/posts/6/img_3.png></p><p>A&lt; indexed-field &lt; B 일경우 A에 해당하는 leaf page를 찾은 후 B의 조건에 맞는 범주 내의 데이터까지 leaf page 간의 이동으로 조회한다. 혹은 반대 방향으로, B부터 조건에 맞는 데이터 범주까지 leaf page 간 이동하여 조회한다.
 </p><h2 id=b-tree-인덱스의-특징 ke-size=size26>3. B-tree 인덱스의 특징<a hidden class=anchor aria-hidden=true href=#b-tree-인덱스의-특징>#</a></h2><p>인덱스 자체의 특징 및 설계방법은 이전 포스트 (<a href=https://junhkang.tistory.com/5>https://junhkang.tistory.com/5</a>) 에서 다루고 있으니 참고, B-tree 인덱스만의 특징은 다음과 같다.</p><blockquote><p>▪ 데이터가 동일한지, 특정 범주에 있는 데이터인지 여부로 조회할 때 사용<br>▪ Postgresql 옵티마이저는 &ldquo;&lt; &lt;= = >= >&ldquo;와 같은 수식을 사용할때 B-tree 인덱스를 고려<br>▪ 수식의 조합인 IN&& Between도 고려<br>▪ IS NULL, IS NOT NULL 조건도 인덱스 사용 가능<br>▪ 패턴매칭 (like)도 문자열의 시작에 매칭을 사용하지 않으면 적용 가능 ( &rsquo;test%&rsquo;, &rsquo;test^&rsquo;)<br>▪ Ilike, ~* 에는 패턴이 알파벳 외의 문자(대/소문자 영향을 안 받는 문자로 시작하는 경우)로 시작할 때만 사용 가능
 </p></blockquote><p>참고</p><ul><li><a href=https://postgrespro.com/blog/pgsql/4161516>https://postgrespro.com/blog/pgsql/4161516</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/index/>Index</a></li><li><a href=http://localhost:1313/tags/postgresql/>PostgreSQL</a></li><li><a href=http://localhost:1313/tags/b-tree/>B-Tree</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>