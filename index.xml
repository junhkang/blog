<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jun Kang&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jun Kang&#39;s Blog</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>ko</language>
    <lastBuildDate>Thu, 30 Jan 2025 16:50:24 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Spring] 스프링부트와 HikariCP를 활용한 Connection Pool 설정 및 최적화</title>
      <link>http://localhost:1313/posts/125/</link>
      <pubDate>Thu, 30 Jan 2025 16:50:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/125/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;몇 년 전 운영 프로젝트 설정 시 자세하게 봤던 내용이지만, 트래픽이 대폭 증가하고, DBMS에 연결된 프로젝트와 모듈이 늘어남에 따라 재설정을 위해 개념을 다시 정리하게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;기본적인-데이터베이스-연결과정&#34; ke-size=&#34;size23&#34;&gt;1. 기본적인 데이터베이스 연결과정&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DB Connection 열기&lt;/strong&gt;- 데이터베이스 드라이버를 사용하여 데이터베이스 서버와의 연결&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP 소켓 열기&lt;/strong&gt; - 데이터베이스 전송을 위해 TCP 소켓을 생성하고 데이터베이스 서버와 통신채널을 설정&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 통신 수행&lt;/strong&gt; - 생성된 소켓을 통해 SQL 쿼리를 전송하고 데이터를 Read / Write&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DB연결 닫기&lt;/strong&gt; - 데이터 통신이 완료되면 데이터베이스와의 연결을 종료&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP 소켓 닫기&lt;/strong&gt; - 사용한 TCP 소켓을 닫아 통신 채널 해제&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;웹 어플리케이션은 클라이언트의 HTTP 요청이 들어오면 스레드를 생성한다. 각 요청 시 DB서버로부터 데이터를 얻기 위해서 DB에 지속적으로 접근하는 작업이 필요하다. 스프링부트를 예로 들면, DB에 직접 연결하는 경우, JDBC 드라이버는 애플리케이션 시작 시 한번 로드되고, 사용자 요청 시마다 새로운 connection 객체 생성하여 데이터베이스에 연결한 후 종료되어야 한다. 이렇게 사용자 요청 시 매번 connection 객체를 생성/연결/종료해야 한다면 굉장히 비효율적이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[LINUX] SFTP 초기화 오류 : Failed to connect and initialize SSH connection. Message: [Failed to connect SFTP channel</title>
      <link>http://localhost:1313/posts/124/</link>
      <pubDate>Fri, 03 Jan 2025 15:38:03 +0000</pubDate>
      <guid>http://localhost:1313/posts/124/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;jenkins.plugins.publish_over.BapPublisherException: Failed to connect and initialize SSH connection. Message: [Failed to connect SFTP channel. Message [4: Received message is too long: 458961709]]&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;문제상황&#34; ke-size=&#34;size23&#34;&gt;1. 문제상황&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/124/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-01-03%20%EC%98%A4%ED%9B%84%203.32.21.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;기존에 잘 작동하던 SFTP를 활용한 CI/CD가 갑자기 작동하지 않는다. 에러 메시지에 따르면 약 438mb의 메시지를 받은 상황인데, 파일을 실제로 업로드하는 시점이 아닌 SFTP연결 시도를 하는 순간(SSH연결을 설정하고 초기화하는 부분)에도 이렇게 큰 응답을 받는 상황이었다.&lt;/p&gt;
&lt;h3 id=&#34;원인파악&#34; ke-size=&#34;size23&#34;&gt;2. 원인파악&lt;/h3&gt;
&lt;p&gt;SSH 접속시, 서버 간 구분을 주기 위해 ~/. bashrc의 설정을 통해 웰컴메시지를 출력하는 부분이 문제였다. (다음 포스트에서 진행한 서버별 웰컴 메시지 등록 부분에서 작업과정 확인 가능)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[AWS] Bastion 서버 설정 및 서버 접속 상태 한눈에 구분하기</title>
      <link>http://localhost:1313/posts/123/</link>
      <pubDate>Tue, 31 Dec 2024 12:30:05 +0000</pubDate>
      <guid>http://localhost:1313/posts/123/</guid>
      <description>&lt;hr&gt;
&lt;h3 id=&#34;bastion-서버란&#34; ke-size=&#34;size23&#34;&gt;1. Bastion 서버란?&lt;/h3&gt;
&lt;p&gt;Bastion 서버란 클라우드 환경, 네트워크 환경에서 보안 게이트웨이 역할을 하는 서버로, 외부 네트워크에서 private 서버로 접속할 때 보안을 강화해 주고 접근제어를 구현해 준다. 외부 사용자가 특정 IP에서만 Bastion 서버에 접속하도록 설정할 수 있으며, private 서버들은 Bastion 서버를 통해서 트래픽을 철저하게 관리할 수 있다. 이번 포스트에선 Bastion서버의 설정 방법과, 다중 서버를 Bastion 서버에서 관리할 시 접속상태를 한눈에 구분할 수 있는 방법에 대해 알아보자.&lt;/p&gt;
&lt;h3 id=&#34;bastion-서버-설정-방법&#34; ke-size=&#34;size23&#34;&gt;2. Bastion 서버 설정 방법&lt;/h3&gt;
&lt;h4 id=&#34;aws-인스턴스-생성&#34; ke-size=&#34;size20&#34;&gt;2-1.aws 인스턴스 생성 &lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;t2 micro~t3 micro - 소규모 개발팀&lt;/li&gt;
&lt;li&gt;t3 small  - 중간 규모팀&lt;/li&gt;
&lt;li&gt;T3.medium, M5.large - 대규모팀 (다수 개발자, 운영팀)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/123/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-12-31%20%EC%98%A4%ED%9B%84%2012.14.14.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[LLM] Quota discoveryengine.googleapis.com/documents exceeded.</title>
      <link>http://localhost:1313/posts/122/</link>
      <pubDate>Tue, 17 Dec 2024 23:02:31 +0000</pubDate>
      <guid>http://localhost:1313/posts/122/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/122/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-12-17%20%EC%98%A4%ED%9B%84%2010.49.42.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;문제-발생&#34; ke-size=&#34;size23&#34;&gt;1. 문제 발생&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Quota discoveryengine.googleapis.com/documents exceeded.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;GCP에서 MLOps를 구축 중, RAG를 위한 Discovery engine의 데이터 최대 수량이 초과되었다는 경고를 받게 되었다.&lt;/p&gt;
&lt;p&gt;기본 리밋은 100만건이지만 더 많은 데이터를 저장하기 위해서는 할당량 수정 요청이 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;할당량-수정-요청&#34; ke-size=&#34;size23&#34;&gt;2. 할당량 수정 요청&lt;/h3&gt;
&lt;h4 id=&#34;iam-관리자---할당량-및-시스템-한도&#34; ke-size=&#34;size20&#34;&gt;2-1. IAM &amp;amp; 관리자 -&amp;gt; 할당량 및 시스템 한도&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/122/img.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;초과된-항목-선택&#34; ke-size=&#34;size20&#34;&gt;2-2. 초과된 항목 선택&lt;/h4&gt;
&lt;p&gt;할당량 수정을 원하는 항목의 맨 오른쪽 메뉴 탭에서 할당량 변경을 선택할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[LLM] Google Cloud Discovery Engine 데이터 스토어 업로드 포맷</title>
      <link>http://localhost:1313/posts/121/</link>
      <pubDate>Mon, 16 Dec 2024 22:47:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/121/</guid>
      <description>&lt;hr&gt;
&lt;h3 id=&#34;google-cloud-discovery-engine이란&#34; ke-size=&#34;size23&#34;&gt;1. Google Cloud Discovery Engine이란?&lt;/h3&gt;
&lt;p&gt;Google Cloud Discovery Engine은 구글 클라우드 플랫폼에서 제공하는 검색 및 추천 서비스로, 웹사이트나 앱 내에서 사용자가 원하는 정보를 쉽고 빠르게 찾을 수 있도록 도와주는 서비스로 다음과 같은 특징을 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;고급 검색 기능&lt;/strong&gt; : 단순 키워드 검색이 아닌, 사용자의 의도에 맞춰 의미를 파악하고 관련 콘텐츠를 제안하는 자연어 처리(NLP) 기반 검색을 지원&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;개인화된 추천&lt;/strong&gt; : 머신러닝 기반 추천엔진을 활용, 취향과 행동 패턴에 맞춘 추천 콘텐츠 제공&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장 가능성&lt;/strong&gt; : 다양한 규모와 범위의 콘텐츠에 대해 빠른 검색 및 추천 성능유지&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문제상황&#34; ke-size=&#34;size23&#34;&gt;2. 문제상황&lt;/h3&gt;
&lt;p&gt;Google cloud discovery engine을 활용해 rag를 고도화 시도하던 중, 기존 데이터베이스의 단순 question, answer 필드구조를 csv형태로 업로드하던 방식을 벗어나 metadata, description 필드를 구성하고자 하였다. content필드를 만족하는 데이터 구조를 구성하기 위해 기존 데이터셋을 discovery engine이 요구하는 특정 struct_value, string_value 타입의 jsonl 포맷으로 변환하는 과정에서 여러 에러를 만나게 되었다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 테스트 4 - 얼마나 깊게 테스트 코드를 작성해야 하는가?</title>
      <link>http://localhost:1313/posts/99/</link>
      <pubDate>Sun, 22 Sep 2024 17:59:07 +0000</pubDate>
      <guid>http://localhost:1313/posts/99/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;how-deep---얼마나-깊게-테스트-코드를-작성해야-하는가&#34; ke-size=&#34;size26&#34;&gt;4. HOW DEEP - 얼마나 깊게 테스트 코드를 작성해야 하는가?&lt;/h2&gt;
&lt;h3 id=&#34;테스트-깊이를-결정하는-기준&#34; ke-size=&#34;size23&#34;&gt;4.1 테스트 깊이를 결정하는 기준&lt;/h3&gt;
&lt;p&gt;테스트 깊이를 설정할 때는 다음과 같은 기준을 고려해야 합니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;테스트 피라미드(Test Pyramid)&lt;/strong&gt;: 테스트 피라미드는 테스트 종류에 따른 계층 구조를 보여줍니다. 일반적으로 단위 테스트가 가장 많고, 그다음으로 통합 테스트, 시스템 또는 E2E(End-to-End) 테스트가 위치합니다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;단위 테스트(Unit Tests)&lt;/strong&gt;: 가장 많은 비중을 차지하며, 작은 코드 단위를 독립적으로 테스트합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;통합 테스트(Integration Tests)&lt;/strong&gt;: 여러 모듈이 상호작용하는지 테스트합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E2E 테스트(End-to-End Tests)&lt;/strong&gt;: 실제 사용자 관점에서 전체 시스템이 잘 작동하는지 확인합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;위험 기반 테스트(Risk-Based Testing)&lt;/strong&gt;: 비즈니스 중요도와 잠재적 위험 요소에 따라 테스트 우선순위를 설정합니다. 비즈니스에 중요한 기능이나 리스크가 높은 부분에 대한 테스트는 더 깊이 있게 수행합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유스 케이스 기반 테스트&lt;/strong&gt;: 핵심 사용자 흐름과 엣지 케이스를 기반으로 테스트를 작성합니다. 실제로 사용자가 자주 사용하는 기능이나 예외적인 상황에서의 동작을 검증하는 것이 중요합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;현실적인 제약과 팀 역량 고려&lt;/strong&gt;: 모든 부분을 깊이 테스트하는 것은 시간과 리소스 측면에서 비효율적일 수 있습니다. 팀의 역량과 프로젝트 일정 등을 고려하여 테스트 깊이를 조정하는 것이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/99/img.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 테스트 3 - 언제 테스트 코드를 적용해야 하는가?</title>
      <link>http://localhost:1313/posts/98/</link>
      <pubDate>Sun, 22 Sep 2024 17:57:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/98/</guid>
      <description>&lt;hr&gt;
&lt;h1 id=&#34;3-when---언제-테스트-코드를-적용해야-하는가&#34;&gt;3. WHEN - 언제 테스트 코드를 적용해야 하는가?&lt;/h1&gt;
&lt;h2 id=&#34;tdd와-bdd의-개념-및-적용-시점&#34; ke-size=&#34;size26&#34;&gt;3.1 TDD와 BDD의 개념 및 적용 시점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TDD (Test-Driven Development)&lt;/strong&gt;: TDD는 테스트를 먼저 작성하고, 그 테스트를 통과할 수 있는 최소한의 코드를 작성하며 개발을 진행하는 방법론입니다. TDD는 테스트를 통해 명확한 요구사항을 확인하고 코드 품질을 보장하는 방법으로 활용됩니다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;레드-그린-리팩터 사이클&lt;/strong&gt;: TDD의 기본 개발 사이클은 &lt;code&gt;레드 단계&lt;/code&gt; (실패하는 테스트 작성) → &lt;code&gt;그린 단계&lt;/code&gt; (테스트를 통과하기 위한 코드 작성) → &lt;code&gt;리팩터 단계&lt;/code&gt; (코드 정리 및 최적화)로 이루어집니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;적용 시점&lt;/strong&gt;: 새로운 기능을 개발하거나 기존 코드를 리팩터링 할 때, TDD를 통해 코드의 안정성과 유지보수성을 높일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/98/img.png&#34;&gt;
이미지출처: &lt;a href=&#34;https://medium.com/pilar-2020/applying-test-driven-development-6d6d3af186cbApplying&#34;&gt;https://medium.com/pilar-2020/applying-test-driven-development-6d6d3af186cbApplying&lt;/a&gt;\ Test-Driven\ Development&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 테스트 2 - 테스트 코드를 어떻게 작성해야 하는가?</title>
      <link>http://localhost:1313/posts/97/</link>
      <pubDate>Sun, 22 Sep 2024 17:55:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/97/</guid>
      <description>&lt;hr&gt;
&lt;h1 id=&#34;2-how---테스트-코드를-어떻게-작성해야-하는가&#34;&gt;2. HOW - 테스트 코드를 어떻게 작성해야 하는가?&lt;/h1&gt;
&lt;h2 id=&#34;테스트-케이스-선택-방법&#34; ke-size=&#34;size26&#34;&gt;2.1 테스트 케이스 선택 방법&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;첫 번째 테스트의 중요성&lt;/strong&gt;: 구현하기 가장 쉬운 테스트부터 시작하는 것이 좋습니다. 예외적인 상황이나 가장 빠르게 개발할 수 있는 테스트 케이스를 먼저 작성하고, 점차 확장해 나갑니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;점진적 확장&lt;/strong&gt;: 쉬운 테스트부터 시작해 점차 복잡한 테스트로 나아가면서 시스템의 안정성을 검증합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tdd-test-driven-development-방법론&#34; ke-size=&#34;size26&#34;&gt;2.2 TDD (Test-Driven Development) 방법론&lt;/h2&gt;
&lt;p&gt;TDD는 테스트 주도 개발 방식으로, 테스트 코드를 먼저 작성하고 이를 기반으로 프로덕션 코드를 작성하는 방식입니다. TDD는 다음과 같은 세 단계를 따릅니다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 테스트 1 - 왜 테스트 코드를 작성해야 하는가?</title>
      <link>http://localhost:1313/posts/96/</link>
      <pubDate>Sun, 22 Sep 2024 17:50:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/96/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/96/img.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-why---왜-테스트를-작성해야-하는가&#34;&gt;1. WHY - 왜 테스트를 작성해야 하는가?&lt;/h1&gt;
&lt;h2 id=&#34;테스트-코드의-중요성&#34; ke-size=&#34;size26&#34;&gt;1.1 테스트 코드의 중요성&lt;/h2&gt;
&lt;p&gt;테스트 코드는 소프트웨어 개발에서 매우 중요한 역할을 합니다. 기능을 수정하거나 새로운 기능을 추가할 때 코드가 안정적으로 작동하는지 확인할 수 있는 수단이 바로 테스트 코드입니다. 이를 통해 예상하지 못한 버그를 방지하고, 코드 품질을 높일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;테스트-코드-작성의-장점&#34; ke-size=&#34;size26&#34;&gt;1.2 테스트 코드 작성의 장점&lt;/h2&gt;
&lt;h3 id=&#34;안정적인-개발-환경-구축&#34; ke-size=&#34;size23&#34;&gt;1.2.1 안정적인 개발 환경 구축&lt;/h3&gt;
&lt;p&gt;테스트 코드는 코드의 변경이 다른 기능에 미치는 영향을 최소화하는 데 도움을 줍니다. 개발자는 자신 있게 코드를 수정하거나 리팩터링 할 수 있으며, 기존 기능이 예상대로 작동하는지 검증할 수 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] Caused by: java.lang.IllegalArgumentException: 이름이 {fragment}인, 둘 이상의 fragment들이 발견되었습니다.</title>
      <link>http://localhost:1313/posts/95/</link>
      <pubDate>Tue, 20 Aug 2024 10:41:57 +0000</pubDate>
      <guid>http://localhost:1313/posts/95/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/95/img.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Caused by: java.lang.IllegalArgumentException: 이름이 {fragment}인, 둘 이상의 fragment들이 발견되었습니다. 이는 상대적 순서배열에서 불허됩니다. 상세 정보는 서블릿 스펙 8.2.2 2c 장을 참조하십시오. 절대적 순서배열을 사용하는 것을 고려해 보십시오.]
 &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Spring MVC가 포함되어 있는 상태에서 중복된 디펜던시를 추가하면서 발생한 에러이다. 라이브러리 버전업, 혹은 신규 라이브러리 추가 시 주로 발생하는 현상으로, 메이븐 클린을 통해 메이븐 리포지토리를 정리하면 된다.
 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;메이븐 클린(프로젝트 우클릭 &amp;gt; maven &amp;gt; maven clean)
 &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;그래도 안된다면 실제로 중복된 라이브러리를 정렬 혹은 정리가 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표</title>
      <link>http://localhost:1313/posts/94/</link>
      <pubDate>Wed, 14 Aug 2024 17:49:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/94/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;rds에서의-쿼리-성능-분석-pg_stat_statements란&#34; ke-size=&#34;size26&#34;&gt;1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?&lt;/h2&gt;
&lt;p&gt;RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 &lt;/p&gt;
&lt;p&gt;pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿼리빈도&lt;/li&gt;
&lt;li&gt;쿼리 실행시간&lt;/li&gt;
&lt;li&gt;쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)&lt;/li&gt;
&lt;li&gt;쿼리 텍스트 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설치&#34; ke-size=&#34;size26&#34;&gt;2. 설치 &lt;/h2&gt;
&lt;p&gt;설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[디자인패턴] 빌더(Builder) 패턴의 개념, 예제, 장단점, 활용</title>
      <link>http://localhost:1313/posts/93/</link>
      <pubDate>Mon, 29 Jul 2024 14:45:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/93/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;빌더builder-패턴이란&#34; ke-size=&#34;size26&#34;&gt;1. 빌더(Builder) 패턴이란?&lt;/h2&gt;
&lt;p&gt;일반적으로 구조를 갖춘 큰 구조물을 건축, 구축하는 것을 build라고 한다&lt;/p&gt;
&lt;p&gt;예를 들어 빌딩을 지을 때 지반다지기, 뼈대 만들기 등의 과정을 거치며 아래에서 위로 순차적으로 만들어간다. 복잡한 구조물을 단숨에 완성하기는 어렵기에, 구성하는 각 부분을 만들고 단계를 밟아가며 만들게 된다. Builder 패턴은 이처럼 구조를 가진 복잡한 인스턴스를 조립해 가는 패턴이다. &lt;/p&gt;
&lt;h2 id=&#34;빌더-패턴의-구조&#34; ke-size=&#34;size26&#34;&gt;2. 빌더 패턴의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/93/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-07-29%20%EC%98%A4%ED%9B%84%202.34.00.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;빌더패턴 예제 클래스 다이어그램&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Builder 역&lt;/strong&gt; - 인스턴스를 결정, 인스턴스 각 부분을 만드는 메서드를 정의. 예제에서는 Builder 클래스가 역할을 맡음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteBuilder 역&lt;/strong&gt; - 인터페이스를 구현, 실제 인스턴스 생성으로 호출되는 메서드가 여기에서 정의 TextBuilder, HTMLBuilder 클래스가 역할을 맡음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Director 역&lt;/strong&gt;- Builder의 인터페이스를 사용하여 인스턴스 생성한다. Concrete Builder역에 의존하지 않으며, ConcreteBuilder에 상관없이 작동하도록 Builder의 메서드만 활용한다. 예제에서는 Director클래스가 역할을 맡음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;예제&#34; ke-size=&#34;size26&#34;&gt;3. 예제&lt;/h2&gt;
&lt;p&gt;빌더 패턴을 사용하여 문서 작성하는 프로그램을 구현해보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection, 데이터베이스 접속 에러</title>
      <link>http://localhost:1313/posts/92/</link>
      <pubDate>Thu, 25 Jul 2024 13:29:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/92/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/92/img.png&#34;&gt;
 &lt;/p&gt;
&lt;p&gt;Amazon RDS and Amazon Aurora SSL/TLS 인증서를 업데이트 후 별다른 설정 변경을 하지 않았지만, 오랜만에 빌드하는 스프링부트 프로젝트의 데이터베이스 연결이 되지 않는 현상 발생하였다.
 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[### Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.postgresql.util.PSQLException: FATAL: no pg_hba.conf entry for host &amp;ldquo;{host}&amp;rdquo;, user &amp;ldquo;{user}&amp;rdquo;, database &amp;ldquo;{database}&amp;rdquo;, no encryption ]
 &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;RDS 인증서 업데이트 작업 후 SSL 요구설정이 활성화된 것으로, 해당 에러가 나며 접속이 안된다면 다음과 같이 조치할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] SUBSTRING, SUBSTR, 문자열 자르기</title>
      <link>http://localhost:1313/posts/91/</link>
      <pubDate>Wed, 24 Jul 2024 13:19:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/91/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;PostgreSQL에서 문자열을 다루는 다양한 방법이 있다. 그중 문자열을 원하는 방식대로 자를 수 있는 함수들에 대해 알아보자. 먼저, 가장 많이 쓰이는 SUBSTRING, SUBSTR의 기본 사용 법 및 응용, 성능에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;substring-기본-사용법&#34; ke-size=&#34;size26&#34;&gt;1. Substring 기본 사용법&lt;/h2&gt;
&lt;p&gt;Substring과 Substr은 시작 위치(n), 길이(l)를 기준으로 문자열을 자를 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT substring(&amp;#39;문자열&amp;#39; FROM n FOR l); -- from, for 구문은 substring만 지원
SELECT substring(&amp;#39;문자열&amp;#39;, n, l);
SELECT substr(&amp;#39;문자열&amp;#39;, n, l);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;구문을 활용하여  PostgreSQL Tutorial 문자열에서 첫번째 위치인 P부터 10개의 문자열만을 추출하는 예제를 확인해 보면 동일한 결과를 확인할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라</title>
      <link>http://localhost:1313/posts/90/</link>
      <pubDate>Sat, 29 Jun 2024 18:13:10 +0000</pubDate>
      <guid>http://localhost:1313/posts/90/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;개념&#34; ke-size=&#34;size26&#34;&gt;1. 개념&lt;/h2&gt;
&lt;p&gt;equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.&lt;/p&gt;
&lt;h2 id=&#34;equals를-재정의하는-경우와-재정의하지-말아야-하는-경우&#34; ke-size=&#34;size26&#34;&gt;2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우&lt;/h2&gt;
&lt;h3 id=&#34;equals를-재정의하지-말아야-할-경우&#34; ke-size=&#34;size23&#34;&gt;2-1. equals를 재정의하지 말아야 할 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스&lt;/strong&gt;: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;논리적 동치성 검사가 필요 없는 경우&lt;/strong&gt;: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우&lt;/strong&gt;: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;접근이 제한된 클래스&lt;/strong&gt;: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;equals를-재정의해야-할-경우&#34; ke-size=&#34;size23&#34;&gt;2-2. equals를 재정의해야 할 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;논리적 동치성 비교가 필요한 경우&lt;/strong&gt;: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;equals-메서드의-규약&#34; ke-size=&#34;size26&#34;&gt;3. equals 메서드의 규약&lt;/h2&gt;
&lt;p&gt;Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>[GitHub] 민감한 정보 완전 삭제와 PR 히스토리 정리</title>
      <link>http://localhost:1313/posts/89/</link>
      <pubDate>Wed, 19 Jun 2024 10:48:11 +0000</pubDate>
      <guid>http://localhost:1313/posts/89/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;GitHub 리포지토리에 보안정책에 위반되거나 민감한 정보를 실수로 업로드하는 경우가 있다. 해당 브랜치를 지우거나 커밋 히스토리를 밀어버려도 이미 머지된 Pull Request라면, 깃허브 UI의 closed request 탭에서 파일 히스토리를 확인하면 해당 내용이 그대로 남아 있어 별도의 조치가 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;민감정보-파일-완전-삭제-리포지토리-복제-및-재생성&#34; ke-size=&#34;size26&#34;&gt;1. 민감정보 파일 완전 삭제 (리포지토리 복제 및 재생성)&lt;/h2&gt;
&lt;h3 id=&#34;기존-리포지토리-클론-및-민감-정보-제거&#34; ke-size=&#34;size23&#34;&gt;1-1. 기존 리포지토리 클론 및 민감 정보 제거&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone --mirror https://github.com/username/repo.git
cd repo.git

# BFG Repo-Cleaner 다운로드
curl -L -o bfg.jar https://repo1.maven.org/maven2/com/madgag/bfg/1.13.0/bfg-1.13.0.jar

# 민감한 파일 깃 히스토리에서 완전 제거
java -jar bfg.jar --delete-files &amp;#39;test.properties(삭제파일명)&amp;#39;

# Git Garbage Collection 수행 ( Git reflog를 만료 시키고, 쓰지 않는 객체 삭제 )
git reflog expire --expire=now --all
git gc --prune=now --aggressive
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;기존-리포지토리에-클린-된-히스토리-강제-푸시&#34; ke-size=&#34;size23&#34;&gt;1-2. 기존 리포지토리에 클린 된 히스토리 강제 푸시&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git push --force --all
git push --force --tags
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 문자열에서 날짜/시간 변환 및 처리 과정</title>
      <link>http://localhost:1313/posts/88/</link>
      <pubDate>Thu, 02 May 2024 17:53:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/88/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문자열에서-날짜시간으로의-변환&#34; ke-size=&#34;size26&#34;&gt;1. 문자열에서 날짜/시간으로의 변환&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 날짜형태의 칼럼을 조회할 때, 종종 정확한 날짜 형태를 사용하는 것이 아닌, 문자열, 혹은 숫자 형태로 간편하게 조회하는 경우가 있다. 예를 들어 2024/05/02 이후의 값을 조회할 때 다음 두 가지 조회 방법을 사용할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date_column &amp;gt; &#39;20240502&#39;&lt;br&gt;
date_column &amp;gt; TO_DATE(&#39;20240502&#39;, &#39;YYYYMMDD&#39;)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;예제와 같이 PostgreSQL은 일련의 문자/숫자열을 조건에 맞는 날짜형으로 자동으로 디코딩을 해주는데,  문자열을 인식하는 상세 과정을 순서대로 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;문자열에서-날짜시간으로의-디코딩-과정&#34; ke-size=&#34;size26&#34;&gt;2. 문자열에서 날짜/시간으로의 디코딩 과정&lt;/h2&gt;
&lt;h3 id=&#34;문자열을-토큰으로-분리하고-각-토큰을-시간-시간대-또는-숫자로-분류한다.&#34; ke-size=&#34;size23&#34;&gt;2-1. 문자열을 토큰으로 분리하고 각 토큰을 시간, 시간대, 또는 숫자로 분류한다.&lt;/h3&gt;
&lt;p&gt;예제들에서는 정상적으로 날짜 및 시간이 변환되는지 확인하기 위해 강제로 TIMESTAMP 및 DATE로 형 변환을 하였지만, 날짜 형태의 데이터와 문자열 그대로를 비교하여도 날짜 및 시간 비교가 가능하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[디자인패턴] 전략(Strategy) 패턴의 개념, 예제, 장단점, 활용</title>
      <link>http://localhost:1313/posts/87/</link>
      <pubDate>Fri, 12 Apr 2024 15:42:02 +0000</pubDate>
      <guid>http://localhost:1313/posts/87/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;전략strategy-패턴이란&#34; ke-size=&#34;size26&#34;&gt;1. 전략(Strategy) 패턴이란?&lt;/h2&gt;
&lt;p&gt;Strategy는 전략이라는 뜻으로 적을 해치우는 작전, 게임을 이기는 전략, 문제를 풀어나가는 방법 등의 의미가 있고, 특히 프로그래밍에서는 문제를 해결하는 방식인 &amp;quot;알고리즘&amp;quot;을 의미한다.
 &lt;/p&gt;
&lt;p&gt;모든 프로그램은 문제를 해결하기 위해 존재하며, 특정 알고리즘으로 구현된다. Strategy 패턴에서는 이미 구현한 알고리즘을 쉽게 모두 교체할 수 있다. 즉, 스위치를 누르듯 쉽게 알고리즘을 바꿔서 같은 문제를 다른 방법으로 해결하기 쉽게 만들어주는 패턴이 Strategy 패턴이다.&lt;/p&gt;
&lt;h2 id=&#34;전략strategy-패턴의-구조&#34; ke-size=&#34;size26&#34;&gt;2. 전략(Strategy) 패턴의 구조&lt;/h2&gt;
&lt;p&gt;전략 패턴의 구조와 예제에서 각 요소가 어떤 역할을 하는지 간단하게 먼저 살펴보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] ROWNUM 사용과 순번 부여하기 - ROW_NUMBER(), RANK(), DENSE_RANK()</title>
      <link>http://localhost:1313/posts/86/</link>
      <pubDate>Thu, 11 Apr 2024 14:12:42 +0000</pubDate>
      <guid>http://localhost:1313/posts/86/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;순번-부여하기&#34; ke-size=&#34;size26&#34;&gt;1. 순번 부여하기 &lt;/h2&gt;
&lt;p&gt;PostgreSQL에서는 각 데이터에 의미 있는 순번을 부여하기 위해 ROW_NUMBER(), RANK(), DENSE_RANK() 함수를 제공한다. &lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ROW_NUMBER() OVER(PARTITION BY * ORDER BY * )

RANK() OVER(PARTITION BY * ORDER BY * )

DENSE_RANK() OVER(PARTITION BY * ORDER BY * )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;
&lt;p&gt;예제를 통해 자세한 사용법을 알아보자. (2. 테스트 테이블 &amp;amp; 데이터 생성 참고)&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/86/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-11%20%EC%98%A4%ED%9B%84%201.56.30.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;예제에서 사용할 데이터&lt;/p&gt;
&lt;h3 id=&#34;row_number&#34; ke-size=&#34;size23&#34;&gt;1-1. ROW_NUMBER()&lt;/h3&gt;
&lt;h4 id=&#34;단일-그룹-순번-부여&#34; ke-size=&#34;size20&#34;&gt;          1-1-1. 단일 그룹 순번 부여&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT ROW_NUMBER() OVER (ORDER BY BRAND) AS ROWNUM, *
FROM TEST_COMPLEX_GROUP;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/86/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-11%20%EC%98%A4%ED%9B%84%201.57.20.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 버전 확인: 필요성과 4가지 방법</title>
      <link>http://localhost:1313/posts/85/</link>
      <pubDate>Thu, 11 Apr 2024 13:31:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/85/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;버전-확인이-왜-필요한가&#34; ke-size=&#34;size26&#34;&gt;1. 버전 확인이 왜 필요한가&lt;/h2&gt;
&lt;p&gt;PostgreSQL를 안정적으로 운영하기 위해서는 보안 패치와 업데이트를 최신 상태로 유지하는 것이 중요하다. 또한 특정 기능이나 호환성 요구 사항을 충족하기 위해서도 버전 정보를 알고 있어야 한다. 이를 위해 현재 버전 및 공식 문서의 버전 관리 내용을 주기적으로 확인해주어야 한다. &lt;/p&gt;
&lt;h2 id=&#34;postgresql-버전-확인-방법&#34; ke-size=&#34;size26&#34;&gt;2. PostgreSQL 버전 확인 방법&lt;/h2&gt;
&lt;h3 id=&#34;sql-쿼리-실행-version&#34; ke-size=&#34;size23&#34;&gt;2-1. SQL 쿼리 실행: VERSION()&lt;/h3&gt;
&lt;p&gt;PostgreSQL 쿼리로 가장 간단하게 버전 정보를 얻을 수 있는 방법이다. 서버의 버전정보를 포함한 상세정보를 확인할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 고급 GROUPING 전략 : SETS, CUBE, ROLLUP의 개념, 효과적인 사용법 및 주의사항</title>
      <link>http://localhost:1313/posts/84/</link>
      <pubDate>Tue, 09 Apr 2024 16:24:14 +0000</pubDate>
      <guid>http://localhost:1313/posts/84/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;sets-cube-rollup의-개념-및-사용법&#34; ke-size=&#34;size26&#34;&gt;1. SETS, CUBE, ROLLUP의 개념 및 사용법&lt;/h2&gt;
&lt;p&gt;고급 &amp;quot;GROUP BY&amp;quot;의 기능들로 PostgreSQL에서는 &lt;strong&gt;SETS, CUBE, ROLLUP&lt;/strong&gt; 기능을 제공한다. 기본적인 콘셉트는 일반 GROUP BY와 동일하게 FROM / WHERE 절에서 선택된 데이터는 각각 지정된 그룹으로 GROUP BY 되고, 각 그룹에 대해 집계가 계산된 후, 결과가 반환된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 테스트로 사용할 테이블 정보이다. (마지막 장의 4. 테이블 &amp;amp; 데이터 생성 참고)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/84/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-09%20%EC%98%A4%ED%9B%84%202.20.01.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;group-by-sets의-개념-및-사용법&#34; ke-size=&#34;size23&#34;&gt;1-1. GROUP BY SETS의 개념 및 사용법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GROUPING SETS&lt;/strong&gt;의 각 하위 요소(subsets)들은 하나 이상의 열 혹은 표현식을 지정할 수 있으며 조합에 맞게 집계 결과를 별도로 계산한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항</title>
      <link>http://localhost:1313/posts/83/</link>
      <pubDate>Mon, 08 Apr 2024 16:04:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/83/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;union-intersect-except를-통한-쿼리-결합&#34; ke-size=&#34;size26&#34;&gt;1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합&lt;/h2&gt;
&lt;p&gt;UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;union&#34; ke-size=&#34;size26&#34;&gt;2. UNION&lt;/h2&gt;
&lt;p&gt;query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.&lt;/p&gt;
&lt;h3 id=&#34;union-단일-사용&#34; ke-size=&#34;size23&#34;&gt;2-1. UNION 단일 사용&lt;/h3&gt;
&lt;p&gt;1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 페이징 : OFFSET과 LIMIT의 올바른 사용과 주의점</title>
      <link>http://localhost:1313/posts/82/</link>
      <pubDate>Mon, 08 Apr 2024 15:08:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/82/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/82/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;limit과-offset의-개념-및-사용법&#34; ke-size=&#34;size26&#34;&gt;1. Limit과 Offset의 개념 및 사용법&lt;/h2&gt;
&lt;p&gt;Limit과 Offset은 쿼리 결과 중 특정 부분의 ROW만을 조회하게 해주는 기능이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT select_list
    FROM table_expression
    [ ORDER BY ... ]
    [ LIMIT { number | ALL } ] [ OFFSET number ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;예를 들어 ID순서로 정렬된 결과 셋에서 21번째부터 30번째의 ROWS를 반환하고 싶다면 다음과 같이 사용하면 된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 21~30번째 열 조회
SELECT * FROM TEST_EXPLAIN 
ORDER BY ID
LIMIT 10 OFFSET 20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/82/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-04-08%20%EC%98%A4%ED%9B%84%202.54.59.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LIMIT을 지정하면 해당 값만큼의 결과만 출력되며 총 결과 값이 더 적을 경우 있는 만큼만 출력한다.&lt;/li&gt;
&lt;li&gt;LIMIT ALL, LIMIT NULL은 LIMIT을 설정하지 않은 것 (전체 ROWS 리턴)과 동일하다.&lt;/li&gt;
&lt;li&gt;OFFSET은 리턴되는 ROWS의 시작점을 지정한다.&lt;/li&gt;
&lt;li&gt;OFFSET 0, OFFSET NULL은 OFFSET을 설정하지 않은 것 (첫 ROW부터 리턴)과 동일하다.&lt;/li&gt;
&lt;li&gt;OFFSET과 LIMIT을 둘 다 사용할 경우, LIMIT 카운트를 세기 전에 OFFSET만큼의 ROWS가  앞에서 생략된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;주의점&#34; ke-size=&#34;size26&#34;&gt;2. 주의점&lt;/h2&gt;
&lt;p&gt;LIMIT을 사용할 경우 결과 ROWS의 순서를 유니크하게 만들어주는 ORDER BY와 함께 쓰는 것이 중요하다. 그게 아니라면 예상하지 못한 부분 집합을 조회하게 될 수 있다. 앞의 예시 쿼리에서 ORDER BY를 뺀다면, 10~20 번째를 가져오려고 해도, 어떤 순서에서의 10~20 번째인지 알 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 9. try-finally 보다는 try-with-resources를 사용하라</title>
      <link>http://localhost:1313/posts/81/</link>
      <pubDate>Sat, 06 Apr 2024 19:32:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/81/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;개념&#34; ke-size=&#34;size26&#34;&gt;1. 개념&lt;/h2&gt;
&lt;p&gt;자바 라이브러리에는 close 메서드를 직접 호출해서 닫아줘야 하는 자원이 많다. 대표적으로 InputStream, ouputStream java.sql.connection 등이 있으며 해당 자원들은 클라이언트에서 놓치기 쉬워 예측할 수 없는 성능 문제로 이어지곤 한다. 이중 상당 수가 finalizer를 안정망으로 사용하여 문제에 대비하고 있긴 하지만, 완전히 안전하다고 할 수 없다. (해당 내용은 다음 포스트에서 확인 가능)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/80&#34;&gt;[이펙티브 자바] - [이펙티브 자바] 8. finalizer와 cleaner 사용을 피하라&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;흔히 사용하는 try-finally를 사용한 예외처리를 확인해보자&lt;/p&gt;
&lt;h2 id=&#34;try-finally&#34; ke-size=&#34;size26&#34;&gt;2. try-finally&lt;/h2&gt;
&lt;h3 id=&#34;자원을-1개-사용하는-try-finally-메서드&#34; ke-size=&#34;size23&#34;&gt;2-1. 자원을 1개 사용하는 try-finally 메서드&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static String firstLineOfFile(String path) throws IOException    {
       BufferdReader br = new BufferedReader(new FileReader(Path));
       try {
           return br.readLine();
       }    finally {
           br.close();
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 8. finalizer 와 cleaner 사용을 피하라</title>
      <link>http://localhost:1313/posts/80/</link>
      <pubDate>Sun, 31 Mar 2024 17:15:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/80/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;finalizer와-cleaner란&#34; ke-size=&#34;size26&#34;&gt;1. finalizer와 cleaner란?&lt;/h2&gt;
&lt;p&gt;finalizer와 cleaner는 자바의 2가지 객체 소멸자이다. finalizer는 &lt;strong&gt;Object.finalize()&lt;/strong&gt; 메서드를 오버라이딩 함으로써 사용된다. 작동 여부 및 시점을 예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요하며, 기능의 잘못된 동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다. 기본적으로는 사용하면 안 되고, 자바 9에서는 finalizer를 deprecated API로 지정하고, &lt;strong&gt;java.lang.ref.Cleaner&lt;/strong&gt; 클래스를 사용하여 구현된 cleaner를 대안으로 제시하였으나, cleaner 또한 finalizer보다는 덜 위험 하지만 여전히 예측불가하고 성능이 좋지 않아 일반적으로 불필요하다. &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Visibility Map(가시성 맵)의 개념, 원리, 생명주기 및 정보 확인 방법</title>
      <link>http://localhost:1313/posts/79/</link>
      <pubDate>Thu, 28 Mar 2024 15:54:02 +0000</pubDate>
      <guid>http://localhost:1313/posts/79/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/79/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visibility-map가시성-맵란&#34; ke-size=&#34;size26&#34;&gt;1. Visibility Map(가시성 맵)란?&lt;/h2&gt;
&lt;p&gt;Visibility Map은 트랜잭션에서 데이터에 접근할 때 어떤 데이터가 가시적인지(&lt;strong&gt;모든 트랜잭션에서 읽을 수 있는지&lt;/strong&gt;), 안정적인지 (&lt;strong&gt;동결된 튜플인지&lt;/strong&gt;) 판별하는데 도움을 준다. 데이터 접근 시 불필요한 I/O작업을 줄여주고, 데이터베이스가 어떤 페이지를 직접 접근할 수 있는지를 빠르게 판단함으로써 시스템의 효율적을 올려주는 역할을 한다.&lt;/p&gt;
&lt;h2 id=&#34;visibility-map가시성-맵의-데이터-관리&#34; ke-size=&#34;size26&#34;&gt;2. Visibility Map(가시성 맵)의 데이터 관리&lt;/h2&gt;
&lt;p&gt;Visibility Map은 데이터를 주요 데이터와는 별도의 파일(fork)에 _vm 접미사를 붙여 관리한다. 예를 들어 예를 들어 employees 테이블이 있다고 하면 테이블의 Visibility Map은 별도의 포크에 저장된다. 이 포크의 이름은 파일 노드 번호에 _vm 접미사를 붙여 구성되며, 예를 들어 파일 노드번호가 12345인 경우 VM 파일은 12345_vm으로 저장된다. 데이터에는 해당 테이블의 page가 모든 트랜잭션에 보이는지, 동결된 튜플만을 포함하는지 등의 정보를 저장한다. 데이터베이스가 employees 테이블을 조회할 때, 가시성 맵을 먼저 확인한다. 만약 쿼리가 접근하려는 pages가 모든 트랜잭션에게 보이는 상태라고 확인되면, 시스템은 데이터에 더 빠르게 접근한다. 불필요한 버전검사나 락을 안 해도 되기에 성능이 향상된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 7. 다 쓴 객체 참조를 해제하라</title>
      <link>http://localhost:1313/posts/78/</link>
      <pubDate>Wed, 27 Mar 2024 17:04:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/78/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/78/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;메모리-관리&#34; ke-size=&#34;size26&#34;&gt;1. 메모리 관리&lt;/h2&gt;
&lt;p&gt;자바에선 가비지 컬렉터가 다 쓴 객체를 알아서 회수해 가기에 편리하고 효율적으로 메모리를 관리할 수 있다. 하지만 메모리 관리에 신경 쓰지 않아도 된다는 말은 절대 아니다. 메모리를 적절하게 관리하지 못하면 메모리 누수가 발생하고 심하면 프로그램이 종료될 수 있다.
 &lt;/p&gt;
&lt;p&gt;메모리를 적절하게 관리하지 못하는 경우의 예제를 살펴보자. 다음은 스택을 간단하게 구현한 자바 코드이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-arduino&#34; data-lang=&#34;arduino&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;class &lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; Object[] elements;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Object[DEFAULT_INITIAL_CAPACITY];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(Object e)  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ensureCapacity();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        elements[&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; e;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object &lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; EmptyStackException();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; elements[&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ensureCapacity&lt;/span&gt;()   {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (elements.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Arrays.copyOf(elements, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이대로 사용하여도 기능상으로는 전혀 문제가 없을 것이고, 어떤 테스트도 훌륭하게 통과하겠지만, 이 스택을 사용하는 프로그램을 오래 실행시킬 경우 가비지 컬렉션과 메모리 사용량이 늘어나 결국 성능이 저하될 것이다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 6. 불필요한 객체 생성을 피하라</title>
      <link>http://localhost:1313/posts/77/</link>
      <pubDate>Tue, 26 Mar 2024 18:25:25 +0000</pubDate>
      <guid>http://localhost:1313/posts/77/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/77/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;객체의-재사용&#34; style=&#34;color: #000000;&#34; ke-size=&#34;size26&#34;&gt;1. 객체의 재사용&lt;/h2&gt;
&lt;p&gt;똑같은 객체를 매번 새로 생성하는 것보다 하나를 생성 후 재사용하는 것이 훨씬 효율적이다. 특히 불변 객체는 언제든 재사용이 가능하다. 다음은 객체 생성 시 사용하면 안 되는 극단적인 예이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String s = new String(&amp;#34;bikini&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;보기만 해도 불편한 이 생성방식은 실행될 때마다 String 객체를 새로 생성한다. 이후에 기능적으로는 동일하게 사용되지만 큰 반복문이나 자주 호출되는 메서드 안에 있다면 쓸모없는 인스턴스가 여러 개 생성될 것이다. 개선된 객체 생성 방식을 확인해 보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</title>
      <link>http://localhost:1313/posts/76/</link>
      <pubDate>Mon, 25 Mar 2024 14:36:42 +0000</pubDate>
      <guid>http://localhost:1313/posts/76/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/76/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;개념&#34; ke-size=&#34;size26&#34;&gt;1. 개념&lt;/h2&gt;
&lt;p&gt;한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/42&#34;&gt;IoC(제어의 역전) &amp;amp; DI(의존성 주입)의 개념&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이펙티브 자바 책에서는 &amp;quot;맞춤법 검사기 (SpellChecker)&amp;quot; 클레스에서 &amp;quot;사전 (Dictionary)&amp;quot; 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] TOAST (The Oversized-Attribute Storage Technique)의 개념, PostgreSQL의 대용량 속성 저장 기법</title>
      <link>http://localhost:1313/posts/75/</link>
      <pubDate>Sat, 23 Mar 2024 21:01:58 +0000</pubDate>
      <guid>http://localhost:1313/posts/75/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/75/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;toast-the-oversized-attribute-storage-technique란&#34; ke-size=&#34;size26&#34;&gt;1. TOAST (The Oversized-Attribute Storage Technique)란?&lt;/h2&gt;
&lt;p&gt;데이터베이스의 대용량 속성을 효율적으로 저장하고 관리하기 위한 기법으로, 데이터를 효율적으로 처리하고, 저장공간을 최적화하며 데이터 접근시간을 개선하기 위해 사용된다. PostgreSQL의 각 page영역은 일반적으로 8kb의 고정된 크기로 되어있고 각 tuple이 여러 페이지에 나뉘어 존재할 수 없다. (매우 큰 값을 바로 저장할 수 없다.) 이 한계를 극복하기 위해서, 큰 필드 값은 압축되어 저장되거나 여러 개의 물리적 ROWS로 분할되어 저장된다. 이 과정은 보통 개발자가 별도의 처리로직을 구현할 필요 없이 데이터베이스 백앤드에서 자동으로 이루어진다. 이 기법을 TOAST (The Oversized-Attribute Storage Technique)라고 하며 PostgreSQL에서 큰 데이터 값을 메모리 내에서 효율적으로 처리하는 데에 사용된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jun Kang</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>&lt;p&gt;안녕하세요. &lt;a href=&#34;https://www.sankun.com&#34;&gt;산업의 역군&lt;/a&gt;의 &lt;strong&gt;Jun Kang&lt;/strong&gt;입니다.
&lt;strong&gt;AI와 빅데이터&lt;/strong&gt;를 활용하여 건설업계의 디지털 혁신을 이끌고, 데이터 기반의 의사결정을 통해 더 공정한 기회를 제공하고자 합니다.&lt;/p&gt;
&lt;p&gt;개발적으로는 빅데이터 처리, 데이터베이스 성능 최적화, 효율적인 개발 실천에 깊은 관심을 가지고 있습니다. 새로운 기술을 배우고 적용하는 데 열정을 가지고 있으며, 현재는 &lt;strong&gt;산업의 역군&lt;/strong&gt; 개발팀의 건강하고 지속 가능한 성장 문화를 구축하는 데 힘쓰고 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>첫 번째 글 제목</title>
      <link>http://localhost:1313/sankun/1/</link>
      <pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sankun/1/</guid>
      <description>글에 대한 간단한 설명을 여기에 작성합니다</description>
    </item>
    <item>
      <title>[PostgreSQL] DISK(디스크) 사용량 모니터링</title>
      <link>http://localhost:1313/posts/74/</link>
      <pubDate>Tue, 19 Mar 2024 16:31:20 +0000</pubDate>
      <guid>http://localhost:1313/posts/74/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;disk-영역&#34; ke-size=&#34;size26&#34;&gt;1. Disk 영역&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 저장 영역은 크게 Heap, Index, Toast 3개로 나뉜다. 각 테이블의 대부분의 데이터를 메인 heap 영역에 저장한고, 테이블 칼럼 중 매우 큰 데이터를 받을 수 있는 칼럼은 TOAST 영역에 별도 저장한다. TOAST 테이블에는 실제 데이터를 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. TOAST 테이블의 유효한 인덱스는 1개뿐이고, 기준 테이블에는 더 많은 인덱스가 존재할 수 있다. 테이블과 인덱스는 각각의 디스크파일에 저장 되며 각 파일이 1G가 넘으면 별도 파일로 분리된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[디자인패턴] 데코레이터(Decorator) 패턴의 개념, 예제, 장단점, 활용</title>
      <link>http://localhost:1313/posts/73/</link>
      <pubDate>Mon, 18 Mar 2024 17:23:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/73/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;데코레이터decorator-패턴이란&#34; ke-size=&#34;size26&#34;&gt;1. 데코레이터(Decorator) 패턴이란?&lt;/h2&gt;
&lt;p&gt;중심이 되는 객체가 있고, 장식이 되는 기능을 하나씩 추가하여 목적에 더 맞는 객체로 만들어가는 디자인 패턴을 Decorator 패턴이라고 한다. decorator 란 &amp;quot;장식하는 사람&amp;quot;이라는 뜻이다. 예제를 통해 상세 개념을 확인해 보자. (Java언어로 배우는 디자인 패턴 입문, 3편의 예제를 그대로 사용하였다.) 적용할 예제는, 문자열 주위에 &amp;quot;장식틀&amp;quot;을 붙여 표현하는 것이다. 예를 들어 Hello World라는 기본 문구에 장식틀을 붙여 중첩 장식을 한 후 출력하는 예제이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-asciidoc&#34; data-lang=&#34;asciidoc&#34;&gt;+=============+
|Hello, world|
+=============+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;사용될 클래스는 각각 다음과 같다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] PostgreSQL의 물리적 한계치</title>
      <link>http://localhost:1313/posts/72/</link>
      <pubDate>Mon, 18 Mar 2024 15:00:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/72/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/72/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postresql의-물리적-한계치&#34; ke-size=&#34;size26&#34;&gt;1. PostreSQL의 물리적 한계치&lt;/h2&gt;
&lt;p&gt;물론 사용 가능한 disk 용량, 성능 이슈 등 실직적인 제한이 먼저 적용되겠지만, 모든 자원이 충분하다고 가정할 때 물리적인 limit이다.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;항목&lt;/th&gt;
          &lt;th&gt;최대치&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 사이즈&lt;/td&gt;
          &lt;td&gt;무제한&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 수량&lt;/td&gt;
          &lt;td&gt;4,294,950,911&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 당 Relations(테이블, 뷰, 인덱스 등의 테이블 객체)수량 &lt;/td&gt;
          &lt;td&gt;1,431,650,303&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Relations 사이즈&lt;/td&gt;
          &lt;td&gt;32TB &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 ROW 수량&lt;/td&gt;
          &lt;td&gt;4,294,967,295 pages영역의 크기에 해당하는 ROW&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 COL 수량&lt;/td&gt;
          &lt;td&gt;1,600&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;결과셋의 COL 수량&lt;/td&gt;
          &lt;td&gt;1,664&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;COL 사이즈&lt;/td&gt;
          &lt;td&gt;1GB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 인덱스 수량&lt;/td&gt;
          &lt;td&gt;무제한&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;인덱스 당 컬럼&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;파티션 키&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;식별자 키 (ex, 테이블, ROW, COL 등의 명칭)&lt;/td&gt;
          &lt;td&gt;63 bytes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;function의 매개변수&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;쿼리파라미터&lt;/td&gt;
          &lt;td&gt;65,535&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;테이블당 ROW 수량은 4,294,967,295개의 pages 영역에 저장 가능한 ROWS로 제한되어 있는데, 4,294,967,295는 2^32 - 1로 32비트 시스템에서 사용가능한 최대 정수이다.  데이터베이스에서 최대로 관리할 수 있는 pages의 수며, 각 페이지에는 여러 튜플이 저장될 수 있다.&lt;/li&gt;
&lt;li&gt;테이블 당 인덱스의 수량은 이론상은 &amp;ldquo;무제한&amp;quot;이제만, 실제로는 데이터베이스가 관리할 수 있는 최대 Relations (테이블, 뷰, 인덱스 등의 테이블 객체)에 의해 제한된다. &lt;/li&gt;
&lt;li&gt;위 표의 인덱스 당 칼럼 수, 파티션 키 수량, 식별자 키, 함수 매개변수 최대 수량은 기본값이며 설정값을 변경하여 증가시킬 수 있다.&lt;/li&gt;
&lt;li&gt;테이블 당 최대 칼럼 수는 1600개이지만, 저장되는 튜플이 8192바이트의 힙 페이지에 fit 해야 한다는 조건 때문에 더 줄어들 수 있다. 예를 들어 튜플 헤더를 제외하고,
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1600개의 int칼럼 투플 -&lt;/strong&gt; 6400 bytes로 힙페이지에 정상 저장 가능 (6400 &amp;lt; 8192)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1600의 bigint칼럼 투플 -&lt;/strong&gt; 12800 bytes로 heap page를 초과 (12800 &amp;lt; 8192)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;text, varchar, char같이 길이 변경이 가능한 필드의 경우 값이 크면 TOAST 테이블 영역이라 불리는 주 저장공간 외부영역에 값을 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. &lt;/li&gt;
&lt;li&gt;테이블에서 삭제된 칼럼들도 최대 칼럼 개수에 포함된다. &lt;/li&gt;
&lt;li&gt;삭제된 칼럼에 대해 새로 생성된 ROW도 내부적으로는 null 표시되지만, 추적을 위해 여전히 공간을 차지하여 최대 개수에 영향을 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론&#34; ke-size=&#34;size26&#34;&gt;2. 결론&lt;/h2&gt;
&lt;p&gt;운영 단계에서 1억 개 이상의 테이블을 생성하거나 1000개가 넘는 칼럼의 테이블을 생성하는 일은 없을 것이고, 이러한 물리적 제약보다 자원의 한계 (용량 및 성능이슈)를 먼저 만날 것이기에 정확한 수치를 정확히 외울 필요는 없겠지만, 삭제된 칼럼들과 그 이후 생성된 ROW들이 내부적으로는 추적을 위해 해당 컬럼을 NULL로 저장하며, 이 과정에서 사용되는 NULL비트맵이 공간을 차지하기에 최대 카운트에 영향을 준다는 것 운영 시에 유의해야 할 내용이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Planner, Optimizer (플래너, 옵티마이저)란? Planner, Optimizer (플래너, 옵티마이저)의 개념과 작동방식</title>
      <link>http://localhost:1313/posts/71/</link>
      <pubDate>Thu, 14 Mar 2024 18:51:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/71/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/71/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;planner-optimizer-플래너-옵티마이저-란&#34; ke-size=&#34;size26&#34;&gt;1. Planner / Optimizer (플래너 / 옵티마이저) 란?&lt;/h2&gt;
&lt;p&gt;Planner / Optimizer는 쿼리의 최적화된 실행 계획을 만들어낸다. 한 개의 SQL 쿼리도 결과는 같지만, 다양한 방법과 순서로 실행될 수 있다. Planner / Optimizer (이후는 Planner로 명칭)는 실행 가능한 각각의 플랜을 검사하여 궁극적으로 가장 빠르게 실행 &amp;quot;기대&amp;quot;되는 플랜을 선택한다. &lt;/p&gt;
&lt;h3 id=&#34;genetic-query-optimize&#34; ke-size=&#34;size23&#34;&gt;1-1. Genetic Query Optimize&lt;/h3&gt;
&lt;p&gt;가끔 쿼리의 실행 가능한 방식들을 검사하는 데만도 굉장히 큰 시간과 메모리가 소모된다. (특히, 많은 양의 join을 포함한 쿼리를 실행할 때 발생) 합리적인 쿼리 플랜(최고일 필요는 없다)을 합리적인 시간 내에 찾기 위해, PostgreSQL은 join수량이 임계치를 초과하면 Genetic Query Optimizer를 사용한다. Genetic Query Optimize는 최적의 조인 순서를 찾기 위해, 일부 조인 순서를 시도 후 적합성 함수를 통해 조인 순서의 적합성을 평가하여 최적의 plan을 선택한다. 메모리와 시간을 절약할 수 있지만, 항상 최선의 답을 찾는 것은 아니기에 효율성을 보장하지 못한다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용</title>
      <link>http://localhost:1313/posts/70/</link>
      <pubDate>Wed, 13 Mar 2024 18:52:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/70/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;1-index-only-scans&#34;&gt;1. Index-Only Scans&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 모든 인덱스는 &lt;strong&gt;&amp;quot;보조(Secondary)&amp;quot;&lt;/strong&gt; 인덱스이다. 각 인덱스는 테이블의 메인 데이터 영역(테이블의 &lt;strong&gt;heap&lt;/strong&gt; 영역)과 분리되어서 저장된다. 그렇기 때문에 일반적인 인덱스 스캔에서 각 ROW를 찾기 위해서는, index와 heap 영역 모두에 접근하여 데이터를 탐색해야 한다. 보통 WHERE 절 조건에 부합하는 데이터들은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인덱스 영역 -&lt;/strong&gt; 서로 가까이 존재하여 정렬된 순서로 빠르게 접근할 수 있다. (인덱스 테이블은 정렬된 상태로 생성)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap 영역 -&lt;/strong&gt;  특별한 규칙 없이 어디에서든 분포할 수 있기에 heap 영역을 스캔할 때는 무작위로 접근하게 되어 속도가 느리다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 퍼포먼스 문제를 해결하기 위해 PostgreSQL은 힙 영역에 대한 접근 없이 인덱스 내에서만 데이터를 조회하는 &lt;strong&gt;Index-only&lt;/strong&gt; 스캔을 지원한다. 기본 개념은 말 그대로 heap 영역의 참조 없이 index 항목에서 바로 값을 반환하는 것으로 매우 효율적으로 보이지만 몇 가지 제한사항이 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 인덱스(INDEX)와 오더바이(ORDER BY), ORDER BY 성능개선, 효율적인 인덱스 적용</title>
      <link>http://localhost:1313/posts/69/</link>
      <pubDate>Tue, 12 Mar 2024 18:59:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/69/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;인덱스index와-오더바이order-by&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스(INDEX)와 오더바이(ORDER BY)&lt;/h2&gt;
&lt;p&gt;인덱스는 쿼리의 결과로 특정 row를 찾는 것뿐만 아니라, 특정 순서로 데이터를 정렬하는데도 효율적일 수 있다. ORDER BY와 인덱스를 효율적으로 사용하면 별도의 정렬 과정 없이 ORDER BY를 수행할 수 있다. PostgreSQL에서 현재 지원하는 인덱스 타입 중에서는 B-tree 인덱스만이 정렬 결과로 인덱스를 생성할 수 있다. 다른 인덱스 유형은 특정되지 않은 순서로, 실행 때마다 다른 순서로 열을 반환한다.&lt;/p&gt;
&lt;p&gt;* 상세한 B-tree 인덱스의 개념은 다음 글을 참고 - &lt;a href=&#34;https://junhkang.tistory.com/6&#34;&gt;[Postgresql] - [PostgreSQL] B-tree 인덱스의 원리 및 특징&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 2단계 커밋 프로토콜(Two-Phase Commit Protocol), Prepare transaction</title>
      <link>http://localhost:1313/posts/68/</link>
      <pubDate>Fri, 08 Mar 2024 16:26:45 +0000</pubDate>
      <guid>http://localhost:1313/posts/68/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/68/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;단계-커밋-프로토콜two-phase-commit-2pc&#34; ke-size=&#34;size26&#34;&gt;1. 2단계 커밋 프로토콜([two-phase commit (2PC))&lt;/h2&gt;
&lt;p&gt;PostgreSQL은 two-phase commit (2PC) 프로토콜을 지원한다. 다수의 분산 시스템 환경에서 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜로 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을 보장한다. PostgreSQL의 2단계 트랜잭션은 외부 트랜잭션 관리 시스템에서 사용하기 위해 존재하며 X/Open XA 표준에서 제안된 특징과 모델을 따른다. (사용빈도가 낮은 일부 기능은 구현되지 않았다.) 2단계 커밋은 다음 스탭에 따라 작동된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Coordinator                                         Cohort
                              QUERY TO COMMIT
                --------------------------------&amp;gt;
                              VOTE YES/NO           prepare*/abort*
                &amp;lt;-------------------------------
commit*/abort*                COMMIT/ROLLBACK
                --------------------------------&amp;gt;
                              ACKNOWLEDGMENT        commit*/abort*
                &amp;lt;--------------------------------  
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 트랜잭션(Transaction)의 작동원리</title>
      <link>http://localhost:1313/posts/67/</link>
      <pubDate>Fri, 08 Mar 2024 15:27:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/67/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/67/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;기본-트랜잭션의-개념-및-원리&#34; ke-size=&#34;size26&#34;&gt;1. 기본 트랜잭션의 개념 및 원리&lt;/h2&gt;
&lt;p&gt;트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/20&#34;&gt;[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션과-식별자-transactions-and-identifiers&#34; ke-size=&#34;size26&#34;&gt;2. 트랜잭션과 식별자 (Transactions and Identifiers)&lt;/h2&gt;
&lt;p&gt;기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점</title>
      <link>http://localhost:1313/posts/66/</link>
      <pubDate>Mon, 26 Feb 2024 18:04:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/66/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/66/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;wal-write-ahead-logging-아카이브-모드-백업archive-mode-backup이란&#34; ke-size=&#34;size26&#34;&gt;1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?&lt;/h2&gt;
&lt;p&gt;아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 대량 데이터 인서트 시 성능 개선 및 주의 사항</title>
      <link>http://localhost:1313/posts/65/</link>
      <pubDate>Mon, 26 Feb 2024 14:31:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/65/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/65/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;대량-데이터-인서트-시-성능-개선&#34; ke-size=&#34;size26&#34;&gt;대량 데이터 인서트 시 성능 개선&lt;/h2&gt;
&lt;p&gt;최초 서비스 배포나 데이터 마이그레이션을 할 때 대량의 데이터를 한 번에 인서트 하는 경우가 있다. PostgreSQL 공식문서에서는 대량 인서트 시에 효율적으로 진행할 수 있는 방법을 제시해 준다. (대량 데이터를 인서트 할 때 효율적인 설정이지 데이터베이스 조회나 업데이트 등실제 운영 시에 사용할 방법은 아니다.)&lt;/p&gt;
&lt;h2 id=&#34;autocommit-옵션-해제&#34; style=&#34;color: #333333; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. Autocommit 옵션 해제&lt;/h2&gt;
&lt;p&gt;대량의 인서트 실행 시, Autocommit 옵션을 해제하고 한 트랜잭션에서 작업 후에 커밋을 진행해야 한다(일반적으로 SQL를 실행 시에 자동으로 시작 시 BEGIN, 끝날 때 COMMIT으로 트랜잭션 처리가 되지만, 확실히 되고 있는지 확인필요하다.). 대량 데이터 인서트의 각각을 별도로 commit 한다면, PostgreSQL은 인서트 되는 각 열에 대해 너무 많은 작업을 수행하게 된다. 또한 모든 인서트를 한 트랜잭션에 처리할 경우에는 한 INSERT가 실패할 경우 그 시점까지 인서트 된 모든 작업이 취소되기에 실패 작업에 대한 부분 보완 및 무결성을 고려하지 않아도 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 외래키(Foreign Keys) 개념, 사용법, 장단점, 적용검토</title>
      <link>http://localhost:1313/posts/64/</link>
      <pubDate>Thu, 22 Feb 2024 18:28:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/64/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/64/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;foreign-key-외래키란&#34; ke-size=&#34;size26&#34;&gt;1. Foreign Key 외래키란?&lt;/h2&gt;
&lt;p&gt;Foreign key constraint 외래키 제약은 특정 칼럼 혹은 칼럼들의 값이 다른 테이블의 특정 row와 매칭되어야 하는 제약조건이다. 이를 두 관련 테이블 사이의 참조 무결성 (referential integrity)를 유지한다고 말한다. 그렇게 복잡한 개념은 아니니 바로 사용법을 확인해 보도록 하자&lt;/p&gt;
&lt;h2 id=&#34;예제&#34; ke-size=&#34;size26&#34;&gt;2. 예제&lt;/h2&gt;
&lt;h3 id=&#34;기본-외래키foreign-keys-생성&#34; ke-size=&#34;size23&#34;&gt;2-1. 기본 외래키(Foreign Keys) 생성&lt;/h3&gt;
&lt;p&gt;products 테이블은 물품의 이름, 가격 정보 테이블이고, orders 테이블은 존재하는 물품 각각에 대한 순서 정보가 들어있는 테이블이다. orders, products 테이블의 product_no에 외래키 제약을 적용하는 예제이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[디자인패턴] 컴포지트(Composite) 패턴의 개념, 예제, 장단점, 활용</title>
      <link>http://localhost:1313/posts/63/</link>
      <pubDate>Tue, 20 Feb 2024 18:08:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/63/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;컴포지트composite-패턴이란&#34; ke-size=&#34;size26&#34;&gt;1. 컴포지트(Composite) 패턴이란?&lt;/h2&gt;
&lt;p&gt;Composite는 혼합물, 복합물이란 뜻으로 중첩된 구조, 재귀적인 구조를 만드는 패턴이다. 대표적인 예로 윈도우 디렉터리와 파일을 들 수 있다. 디렉터리, 파일은 엄연히 다른 속성이지만 둘 다 디렉터리 안에 넣을 수 있다는 공통점이 있다. 디렉터리 내에는 또 다른 디렉터리가 있을 수 있기에 중첩, 재귀적인 구조를 만들어낸다.
 &lt;/p&gt;
&lt;p&gt;디렉터리와 파일을 합쳐 디렉터리 엔트리라고 부르기도 한다. 두 속성을 같은 종류로 간주하는 것이다. 어떤 디렉터리 안에 무엇이 있는지 차례대로 조사할 때 조사하는 것이 디렉터리일 수도, 파일일 수도 있다, 한마디로 디렉터리 엔트리를 차례로 조사한다는 것이다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</title>
      <link>http://localhost:1313/posts/62/</link>
      <pubDate>Sun, 18 Feb 2024 15:44:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/62/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/62/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;개념&#34; ke-size=&#34;size26&#34;&gt;1. 개념&lt;/h2&gt;
&lt;p&gt;단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다.
 &lt;/p&gt;
&lt;p&gt;단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays&lt;/li&gt;
&lt;li&gt;특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections&lt;/li&gt;
&lt;li&gt;final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[디자인패턴] 추상 팩터리(Abstract Factory) 패턴의 개념, 예제, 장단점, 활용</title>
      <link>http://localhost:1313/posts/61/</link>
      <pubDate>Fri, 16 Feb 2024 17:20:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/61/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;추상-팩토리abstract-factory-패턴-이란&#34; ke-size=&#34;size26&#34;&gt;1. 추상 팩토리(Abstract Factory) 패턴 이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;추상 - 구체적으로 어떻게 구현되는지 생각하지 않고 인터페이스(API)에만 주목하는 상태&lt;br&gt;
공장 - 부품을 조립하여 제품 완성
 &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;추상 + 공장 패턴 :&lt;/strong&gt; 추상적인 공장에서 추상적인 부품을 조합하여 추상적인 제품을 만든다. 부품의 구체적인 구현에 집중하지 않고 인터페이스에 주목, 인터페이스만 사용하여 부품을 조립하고 제품으로 완성한다.
 &lt;/p&gt;
&lt;p&gt;다음 표를 보면 추상 팩토리가 어떤 구조로 이루어졌는지 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/61/img.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Abstract Factory :&lt;/strong&gt; 최상위 공장, 메서드들을 추상화한다. AbstractProduct의 인스턴스를 만들기 위한 인터페이스를 결정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Concrete Factory :&lt;/strong&gt; 서브 공장 클래스, 유형에 맞는 객체를 반환하도록 메서드들을 재정의한다. AbstractFactory의 인터페이스를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Abstract Product :&lt;/strong&gt; 타입의 제품을 추상화한 인터페이스이다. AbstractFactory에 의해 만들어지는 추상적인 부품이나 제품의 인터페이스(API)를 결정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteProduct :&lt;/strong&gt; 각 유형의 구현체, 팩토리 객체로부터 생성한다. AbstractProduct의 인터페이스를 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;예제&#34; ke-size=&#34;size26&#34;&gt;2. 예제&lt;/h2&gt;
&lt;p&gt;사용할 예제는 계층 구조로 된 링크 페이지를 HTML파일로 바꾸는 코드이다. (&amp;quot;JAVA 언어로 배우는 디자인 패턴 입문 3편&amp;quot;의 예제 활용) HTML 계층 구조를 추상 팩토리 패턴을 통해 구현한 것으로 2개의 패키지로 분리된 클래스군으로 구성되어 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Linux] JDK 여러 버전 적용하기, 여러개의 패키지 관리하기 (update-alternatives)</title>
      <link>http://localhost:1313/posts/60/</link>
      <pubDate>Mon, 05 Feb 2024 18:08:28 +0000</pubDate>
      <guid>http://localhost:1313/posts/60/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문제-상황&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. 문제 상황&lt;/h2&gt;
&lt;p&gt;JDK21을 서버에 적용하면서, 기존 버전과 동시에 사용해야 하는 상황 발생&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 해결&lt;/h2&gt;
&lt;p&gt;물론 빌드할 때마다 자바 홈 경로를 바꿔서 적용하거나, 각 톰캣의 catalina.sh에 &lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo JAVA_HOME=개별 JAVA경로
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;혹은 startup.sh 스크립트 상단에 개별 JAVA_HOME을 명시하는 방법도 있지만, 심볼릭 링크를 통해 여러 패키지를 관리하는 방식인 &lt;strong&gt;update-alternatives&lt;/strong&gt;를 통해 적용하였다.
 &lt;/p&gt;
&lt;p&gt;개념은 심볼릭링크 (상세 내용은 아래 링크 참고)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/16&#34;&gt;[Linux] - [Linux] 심볼릭 링크 (Symbolic link) 설정하기&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링부트 3, 스프링 시큐리티 6, 로그인 세션 유지, 로그인 풀림</title>
      <link>http://localhost:1313/posts/59/</link>
      <pubDate>Fri, 02 Feb 2024 12:33:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/59/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문제-상황&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. 문제 상황&lt;/h2&gt;
&lt;p&gt;스프링 부트 3, 스프링 시큐리티 6 업데이트가 되며 기존에 사용 중인 WebSecurityConfigurerAdapter를 더 이상 지원하지 않기에&lt;/p&gt;
&lt;p&gt;기존의 WebSecurityConfigurerAdapter를 상속받아 기능을 구현하는 대신 컴포넌트화 시켜서 구현해야한다.&lt;/p&gt;
&lt;p&gt;SecurityFilterChain으로 스프링 시큐리티를 구현 중&lt;/p&gt;
&lt;p&gt;(antMacher -&amp;gt; requestMacher, dispatcherTypeMatcher설정 등 기본 Spring Security6.0 &lt;a href=&#34;https://docs.spring.io/spring-security/reference/5.8/migration/index.html&#34;&gt;마이그레이션 가이드&lt;/a&gt;는 적용 완료
)&lt;/p&gt;
&lt;p&gt;SecurityContext에 로그인 시도 시 정상적으로 인증정보를 바인딩하고 있으나, 페이지 이동 시 인증정보가 없어지는 현상 발생&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 해결&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ebnf&#34; data-lang=&#34;ebnf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SecurityContextPersistenceFilter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SecurityContext의 영속성을 컨트롤하는 SecurityContextPersistenceFilter의 설정이 누락되어 있었다. &lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링부트 3 jstl 적용(maven), (절대 URI인 [http://java.sun.com/jsp/jstl/core]을(를), web.xml 또는 이 애플리케이션과 함께 배치된 JAR 파일 내에서 찾을 수 없습니다.)</title>
      <link>http://localhost:1313/posts/58/</link>
      <pubDate>Wed, 31 Jan 2024 16:40:43 +0000</pubDate>
      <guid>http://localhost:1313/posts/58/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문제-상황&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. 문제 상황&lt;/h2&gt;
&lt;p&gt;스프링부트 3 버전 업데이트 중 jstl URI / 라이브러리를 찾지 못하는 현상 발생&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://java.sun.com/jsp/jstl/core&#34;&gt;http://java.sun.com/jsp/jstl/core&lt;/a&gt;]을(를), web.xml 또는 이 애플리케이션과 함께 배치된 JAR 파일 내에서 찾을 수 없습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;해결&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 해결&lt;/h2&gt;
&lt;p&gt;타 라이브러리와 동일하게 javax -&amp;gt; jakarta 기반 jstl maven dependency를 추가해주면 된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;jakarta.servlet.jsp.jstl&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jakarta.servlet.jsp.jstl-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;jakarta.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jakarta.servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;6.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;jakarta.servlet.jsp&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jakarta.servlet.jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;jakarta.el&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jakarta.el-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.glassfish.web&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jakarta.servlet.jsp.jstl&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>[Spring] Java 21 롬복(lombok) 버전 설정 (java: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field &#39;com.sun.tools.javac.tree.JCTree qualid&#39;)</title>
      <link>http://localhost:1313/posts/57/</link>
      <pubDate>Wed, 31 Jan 2024 10:35:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/57/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문제-상황&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. 문제 상황&lt;/h2&gt;
&lt;p&gt;JDK21 버전 업 중 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field &#39;com.sun.tools.javac.tree.JCTree qualid&#39;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;라는 에러와 함께 빌드 실패&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; style=&#34;color: #3a4954; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 해결&lt;/h2&gt;
&lt;p&gt;JDK21과 호환되지 않는 롬복(lombok) 버전 문제로 확인, (JDK21과 호환되는 최소 롬복(lombok) 버전은 &lt;strong&gt;1.18.30이다.)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt;
&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.18.30&amp;lt;/version&amp;gt;
          &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;
&lt;p&gt;기존 사용 중인 구버전 롬복(lombok)을 작성일 기준 최신버전이자 JDK21 호환 최소 버전인 1.18.30으로 변경해 주면 정상적으로 빌드가 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Java] 자바 스트림(Streams)의 개념과 사용 방법</title>
      <link>http://localhost:1313/posts/56/</link>
      <pubDate>Tue, 30 Jan 2024 21:41:20 +0000</pubDate>
      <guid>http://localhost:1313/posts/56/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/56/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;자바-스트림streams이란&#34; ke-size=&#34;size26&#34;&gt;1. 자바 스트림(Streams)이란?&lt;/h2&gt;
&lt;p&gt;기존의 배열 또는 컬렉션 인스턴스는 for, foreach 같은 반복문을 통해 하나씩 핸들링하는 방식이었기에 로직이 복잡할수록 코드양도 많아지고 루프를 여러 번 도는 경우도 발생하였다. 그에 비해 자바 8에서 추가된 스트림(Streams)은 람다를 사용할 수 있는 기술 중 하나로 다음과 같은 특징을 가지고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스트림은 데이터의 흐름이라는 뜻으로 컬렉션에 저장되어 있는 요소들을 하나씩 순회하면서 처리할 수 있는 코드패턴이다.&lt;/li&gt;
&lt;li&gt;함수형 프로그래밍 언어에서 일반적으로 지원하는 연산관 데이터베이스와 비슷한 연산을 지원한다.&lt;/li&gt;
&lt;li&gt;배열/컬렉션의 함수 여러 개를 조합하여 원하는 결과를 필터링, 가공된 결과 추출 가능하며 람다식으로 코드를 간결하게 표현할 수 있다.&lt;/li&gt;
&lt;li&gt;하나의 작업을 둘 이상 작업으로 잘게 쪼개 동시에 처리하며 스레드를 이용하여 많은 요소들을 빠르게 처리 가능한다. &lt;/li&gt;
&lt;li&gt;컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조인데 비해, 스트림은 요청할 때만 요소를 계산하는 고정된 자료 구조이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스트림에 사용에 대한 상세한 내용은 다음 3가지로 나눌 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라</title>
      <link>http://localhost:1313/posts/55/</link>
      <pubDate>Wed, 24 Jan 2024 13:04:41 +0000</pubDate>
      <guid>http://localhost:1313/posts/55/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/55/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다.
 &lt;/p&gt;
&lt;p&gt;싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 2. 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>http://localhost:1313/posts/54/</link>
      <pubDate>Tue, 23 Jan 2024 15:38:26 +0000</pubDate>
      <guid>http://localhost:1313/posts/54/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/54/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;정적팩토리와 생성자에는 매개변수가 많을 경우 대응이 힘들다는 동일한 제약이 있다. 특히 매개변수가 굉장히 많은데 대부분이 고정값인 경우 일반적인 방법으로는 깔끔한 대응이 힘들다. 유연한 대응을 위해 보통 점층적 생성자패턴, 자바 빈즈 패턴, 빌더 패턴을 사용하는데, 이번 챕터에서는 빌더 패턴의 장점을 강조하고 있다. 각 패턴의 장단점을 자세히 살펴보고 빌더 패턴의 장점을 알아보자&lt;/p&gt;
&lt;h2 id=&#34;점층적-생성자-패턴&#34; ke-size=&#34;size26&#34;&gt;1. 점층적 생성자 패턴&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;필수 매개변수만 받는 생성자&lt;br&gt;
필수 매개변수와 선택 매개변수 1개를 받는 생성자,
필수 매개변수와 선택 매개변수 2개를 받는 생성자,
필수 매개변수와 선택 매개변수 3개를 받는 생성자,
...&lt;/p&gt;</description>
    </item>
    <item>
      <title>[이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라</title>
      <link>http://localhost:1313/posts/53/</link>
      <pubDate>Thu, 18 Jan 2024 15:51:04 +0000</pubDate>
      <guid>http://localhost:1313/posts/53/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;생성자-대신-정적-팩토리-메서드를-고려하라&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;생성자 대신 정적 팩토리 메서드를 고려하라&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 클래스 인스턴스를 얻는 방법에는 전통적인 방법 중 하나는  public이다. 하지만 &lt;strong&gt;정적 팩터리 메서드&lt;/strong&gt;(&lt;strong&gt;static factory method&lt;/strong&gt;)도 꼭 알아두어야한다.&lt;/p&gt;
&lt;h2 id=&#34;정적-팩터리-메서드란&#34; ke-size=&#34;size26&#34;&gt;1. 정적 팩터리 메서드란?&lt;/h2&gt;
&lt;p&gt;그렇다면 정적 팩터리 메서드는 무엇일까? 간단히 말해 객체 생성의 역할을 하는 클래스 메서드로, static 메서드를 통해 인스턴스를 생성하는 것이다. 다음은 java의 기본 Boolean 클래스 내 정적 팩토리 메서드의 간단한 예시이다. &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/53/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-01-17%20%EC%98%A4%ED%9B%84%205.02.29.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이팩티브 자바에서는 정적 팩토리 메서드를 사용할 시의 5가지 장점과 2가지 단점에 대해 서술하고 있어 자세한 비교를 통해 하나하나 알아보려 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] Java 21 외장 톰캣 버전 설정</title>
      <link>http://localhost:1313/posts/52/</link>
      <pubDate>Mon, 18 Dec 2023 14:13:48 +0000</pubDate>
      <guid>http://localhost:1313/posts/52/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문제-상황&#34; ke-size=&#34;size26&#34;&gt;1. 문제 상황&lt;/h2&gt;
&lt;p&gt;Java21 버전 업 중, 인텔리제이 내장 톰캣으로는 정상적으로 실행되지만, 커스텀 옵션을 사용 중인 외장톰캣을 그대로 사용 시 정상적으로 구동되지 않는 현상이 발견되었다.&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; ke-size=&#34;size26&#34;&gt;2. 해결&lt;/h2&gt;
&lt;p&gt;먼저, 빌드 및 path 등 기존 설정들은 문제가 없는 것을 확인하였고, 로컬 톰캣에서 정상적으로 구동됨을 확인하였기에 다른 부분을 추가로 확인해 보았다. 버전업 영향도 파악기간 중 기존에 톰캣 8.5 버전과 호환되는 것을 확인하였으나, 공식 홈페이지에서 재확인해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/52/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;톰캣 8.5 버전의 자바 지원버전을 보면 &amp;quot;7 and later&amp;quot;로 되어있어 7 이후 버전을 다 사용 가능한 것으로 이해했었으나, 다른 버전을 시도.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] Spring Security6 filterchain 사용시 jsp 뷰 렌더링 설정</title>
      <link>http://localhost:1313/posts/51/</link>
      <pubDate>Mon, 18 Dec 2023 13:09:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/51/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;현상&#34; ke-size=&#34;size26&#34;&gt;1. 현상&lt;/h2&gt;
&lt;p&gt;스프링부트 3.*.* 버전 업을 하며 Spring Security6으로 업데이트 중이다.&lt;/p&gt;
&lt;p&gt;더 이상 지원하지 않는 WebSecurityConfigurerAdapter를 SecurityFilterChain으로 변경 시 포워딩되는 jsp 파일 경로가 필터에 걸려 노출되지 않는 현상이 발생하였다.&lt;/p&gt;
&lt;h3 id=&#34;기존-샘플-소스&#34; ke-size=&#34;size23&#34;&gt;1-1. 기존 샘플 소스&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Configuration
public class SecurityConfig  {
    @Bean
    public SecurityFilterChain config(HttpSecurity http) throws Exception {
       http.authorizeHttpRequests((auth) -&amp;gt; auth
          .requestMatchers(&amp;#34;/&amp;#34;).permitAll()
          .anyRequest().authenticated()
      );

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;
&lt;p&gt;기존과 같이 &amp;ldquo;/&amp;rdquo; 경로에 대한 권한을 부여하였지만, jsp 경로에 대한 권한부족으로 페이지 접근에 실패하였다.&lt;/p&gt;
&lt;h2 id=&#34;원인&#34; ke-size=&#34;size26&#34;&gt;2. 원인 &lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Security 5.8 and earlier only&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Elastic Search] Elastic Search란? Elastic Search의 개념 및 장단점</title>
      <link>http://localhost:1313/posts/50/</link>
      <pubDate>Fri, 08 Dec 2023 14:57:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/50/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;elastic-search란&#34; ke-size=&#34;size26&#34;&gt;1. Elastic Search란?&lt;/h2&gt;
&lt;p&gt;Apache Lucene에 구축되어 배포된 검색 및 분석 엔진이다. 현재 검색엔진을 넘어 보안, 로그분석, Full-text 분석 등 다양한 영역에서 사용되며, Kibana, Logstash, Beats들과 함께 사용된다. 오픈 소스 프로젝트로 활발히 개발되고 있으며, 유닉스, 자바의 기초지식 필요하다. Apache Lucene의 한계를 보완하기 위한 새로운 검색엔진 프로젝트로 시작되었고 Logstash, Kibana와 함께 사용되어 ELK Stack (ES, Logstash, Kibana)라고 불렸으나 2013년 Logstash, Kibana 프로젝트 정식 흡수되었다.&lt;/p&gt;
&lt;h2 id=&#34;elastic-stack이란&#34; ke-size=&#34;size26&#34;&gt;2. Elastic Stack이란?&lt;/h2&gt;
&lt;p&gt;ES, Logstash, Kibana를 묶은 ELK 서비스이다. 5.0.0 버전부터 Beats를 포함하며 Elastic Stack 이란 이름으로 서비스가 제공되고 있다. 서버로부터 모든 유형의 데이터를 가져와 실시간 검색, 분석, 시각화를 도와주는 Elastic 오픈 소스 서비스 제품이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[WEB] SSR(Server Side Rendering) 과 CSR(Client Side Rendering)의 개념 및 차이</title>
      <link>http://localhost:1313/posts/49/</link>
      <pubDate>Tue, 28 Nov 2023 12:33:47 +0000</pubDate>
      <guid>http://localhost:1313/posts/49/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;ssr-server-side-rendering&#34; ke-size=&#34;size26&#34;&gt;1. SSR (Server Side Rendering)&lt;/h2&gt;
&lt;p&gt;서버에서 렌더링 준비를 마친 상태로 클라이언트에 자원을 전달한다.&lt;/p&gt;
&lt;h3 id=&#34;ssr-작동-방식&#34; style=&#34;color: #000000; text-align: start;&#34; ke-size=&#34;size23&#34;&gt;1-1. SSR 작동 방식&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/49/img.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유저가 웹사이트 자원을 요청&lt;/li&gt;
&lt;li&gt;서버에서 &amp;ldquo;렌더링 가능한&amp;rdquo; HTML 파일 생성 (리소스 체크, 컴파일 후 완성된 HTML 콘텐츠 생성)&lt;/li&gt;
&lt;li&gt;브라우저는 즉시 HTML 렌더링, 사이트 조작 불가 상태&lt;/li&gt;
&lt;li&gt;클라이언트가 자바스크립트를 다운받는다.&lt;/li&gt;
&lt;li&gt;다운로드하여지고 있는 사이 콘텐츠는 볼 수 있지만 조작은 불가, 이 기간 동안 유저의 액션을 기억&lt;/li&gt;
&lt;li&gt;브라우저가 자바스크립트 프레임워크를 실행&lt;/li&gt;
&lt;li&gt;자바스크립트가 컴파일된 후 기억하고 있던 유저 액션을 실행시킨다.&lt;/li&gt;
&lt;li&gt;서버에서 렌더링 가능한 상태로 이미 전달되기에 자바스크립트를 받는 동안 특정 자원을 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssr-장점&#34; ke-size=&#34;size23&#34;&gt;1-2. SSR 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;초기 페이지의 로딩속도가 빠르다. &lt;/li&gt;
&lt;li&gt;서버에서 컴파일되어 클라이언트로 넘어오기에 클롤러 대응에 용이하여 SEO 친화적이다.&lt;/li&gt;
&lt;li&gt;클라이언트 하드웨어 및 소프트웨어 성능에 영향을 덜 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssr-선택-기준&#34; ke-size=&#34;size23&#34;&gt;1-3. SSR 선택 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크가 느릴 때 (페이지마다 나눠서 불러오기 때문)&lt;/li&gt;
&lt;li&gt;검색엔진 최적화가 필요할 때&lt;/li&gt;
&lt;li&gt;최초 로딩이 빨라야 할 때&lt;/li&gt;
&lt;li&gt;메인 스크립트가 크고 로딩이 느릴 때&lt;/li&gt;
&lt;li&gt;웹사이트 상호작용이 별로 없을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;csr-client-side-rendering&#34; ke-size=&#34;size26&#34;&gt;2. CSR (Client Side Rendering)&lt;/h2&gt;
&lt;p&gt;렌더링이 클라이언트에서 일어난다. 서버에선 HTML과 JS를 보내고, 클라이언트에서 렌더링을 시작한다. 모든 로직, 데이터, 템플릿, 라우팅은 클라이언트에서 실행된다. 자바스크립트 번들 크기의 영향을 많이 받기에 코드 분할을 고려해야 하며, 적시 적소에 필요한 기능만을 제공해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[네트워크] REST, RESTful API의 개념 및 설계 가이드</title>
      <link>http://localhost:1313/posts/48/</link>
      <pubDate>Tue, 21 Nov 2023 17:36:52 +0000</pubDate>
      <guid>http://localhost:1313/posts/48/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/48/img.png&#34;&gt;
 &lt;/p&gt;
&lt;h2 id=&#34;1-rest란&#34;&gt;1. REST란?&lt;/h2&gt;
&lt;p&gt;REST란 Representational State Transfer의 약자로 자원을 이름으로 구분하여 자원의 상태를 주고받는 것을 의미한다. HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 행위를 적용한다.&lt;/p&gt;
&lt;h3 id=&#34;rest-구성요소&#34; ke-size=&#34;size23&#34;&gt;1-1. REST 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;자원(Resource) :&lt;/strong&gt; HTTP URI - 서버는 고유한 리소스 식별자로 각 리소스를 식별&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;행위(Verb) :&lt;/strong&gt; HTTP Method (GET, POST, PUT, DELETE)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;내용(Representations) :&lt;/strong&gt; HTTP Message Pay Load - 하나의 자원은 JSON,XML, TEST, RSS 등 여러 형태의 Representaion으로 나타내어질 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-특징&#34; ke-size=&#34;size23&#34;&gt;1-2. REST의 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stateless (무상태성) -&lt;/strong&gt; 서버가 이전의 모든 요청과 독립적으로 클라이언트 요청을 완료함을 의미&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cacheable(캐쉬 가능성)&lt;/strong&gt; - 일부 응답을 저장하는 프로세스인 캐싱을 지원함을 의미&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Layered System (계층화)&lt;/strong&gt; - 클라이언트는 REST API Server만 호출하지만, 클라이언트 요청을 이행하기 위해 함께 작동하는 비즈니스 로직(보안, 암호화 등)을 여러 계층으로 실행될 수 있도록 유연하게 설계 가능함을 의미&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Uniform Interface (균일한 인터페이스)&lt;/strong&gt; - 서버가 표준 형식으로 정보를 전송함을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점&#34; ke-size=&#34;size23&#34;&gt;1-3. 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 프로토콜을 그대로 사용하기에 별도 인프라를 구축할 필요가 없음&lt;/li&gt;
&lt;li&gt;HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능&lt;/li&gt;
&lt;li&gt;API의 의도를 쉽고 명확하게 파악 가능&lt;/li&gt;
&lt;li&gt;클라이언트, 서버를 완전히 분리하기에 각 부분이 독립적으로 발전 가능&lt;/li&gt;
&lt;li&gt;사용되는 기술과 독립적이기에 API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 작성이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34; ke-size=&#34;size23&#34;&gt;1-4. 단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;표준이 존재하지 않아 정의가 필요함&lt;/li&gt;
&lt;li&gt;HTTP Method 형태가 제한적&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;restful-api란&#34; ke-size=&#34;size26&#34;&gt;2. RESTful API란?&lt;/h2&gt;
&lt;p&gt;REST 아키텍쳐를 따르는 API를 RESTful API (Representaional state transfer API)라고 하며 REST 아키텍처를 구현하는 웹서비스를 RESTful 웹 서비스라고 한다. REST는 복잡한 네트워크에서 통신을 관리하기 위한 지침으로 만들어 졌으며, 대규모의 고성능 통신을 안정적으로 지원할 수 있고 쉽게 구현 및 수정할 수 있어 파악에 용이하고 여러 시스템에서 사용이 가능하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 순환참조란? The dependencies of some of the beans in the application context form a cycle</title>
      <link>http://localhost:1313/posts/47/</link>
      <pubDate>Fri, 17 Nov 2023 14:36:15 +0000</pubDate>
      <guid>http://localhost:1313/posts/47/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/47/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;순환참조란&#34; ke-size=&#34;size26&#34;&gt;1. 순환참조란?&lt;/h2&gt;
&lt;p&gt;순환참조는 맞물린 의존성 주입 (DI) 상태에서 어떤 빈을 먼저 생성할지 결정하지 못해서 생기에 발생한다. BeanA에서 BeanB를 참조(BeanA-&amp;gt;BeanB) 일 경우 스프링은 BeanB를 먼저 생성 후 BeanA를 생성하기에, BeanB에서 다시 BeanA를 참조할 경우 (BeanA-&amp;gt;BeanB-&amp;gt;BeanA) 순환 참조가 발생하게된다. &lt;/p&gt;
&lt;h2 id=&#34;의존성-주입&#34; ke-size=&#34;size26&#34;&gt;2. 의존성 주입 &lt;/h2&gt;
&lt;p&gt;의존성 주입의 3가지 상황 (생성자 주입방식, 필드 주입방식, Setter주입)에서 순환참조가 발생할수 있다. 다음 포스트 각각의 상세 내용을 확인할 수 있고, 이번 포스트에서는 각각의 경우에 순환참조가 발생하면 어떤 차이점이 있는지 확인해 보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 함수(Function)의 정의 및 상세 사용법 (다양한 예제)</title>
      <link>http://localhost:1313/posts/46/</link>
      <pubDate>Wed, 15 Nov 2023 17:12:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/46/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/46/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postgresql-function이란&#34; ke-size=&#34;size26&#34;&gt;1. PostgreSQL Function이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SQL 함수는 임의의 SQL문들을 실행하고 마지막 쿼리의 결과를 반환한다. 단순한 형태의 함수는 마지막 쿼리의 첫 번째 row가 리턴된다. (order by 를 사용하지 않는 경우 다중 row의 첫 번째 행은 별도 정의되지 않기에 결과 row가 매번 다를 수 있다.)&lt;/li&gt;
&lt;li&gt;마지막 쿼리가 row를 하나도 반환하지 않을 경우 null이 리턴된다.&lt;/li&gt;
&lt;li&gt;SQL 함수는 함수의 리턴 유형을 특정 타입의 집합 (SET)으로 선언하거나, 테이블로 선언하여 반환할 수 있다. 이 경우에는 마지막 쿼리의 모든 ROW가 리턴된다.&lt;/li&gt;
&lt;li&gt;SQL함수의 body는 세미콜론(;)으로 구분된 SQL구문의 집합이어야만 한다.&lt;/li&gt;
&lt;li&gt;마지막 구문 뒤의 세미콜론(;)은 생략하여도된다.&lt;/li&gt;
&lt;li&gt;함수가 void를 리턴하는 것으로 선언되지 않았다면, 마지막 구문은 반환절이 존재하는 select, insert, update, delete 여야만 한다.&lt;/li&gt;
&lt;li&gt;모든 종류의 SQL 언어의 명령 모음은 패키징 되어 함수로 정의될 수 있다.&lt;/li&gt;
&lt;li&gt;select쿼리 외에도 insert, update, delete, merge 등의 데이터 수정쿼리 및 기타 SQL을 포함할 수 있지만, 트랜잭션 제어 명령( ex. commit, savepoint) 및 vacutaion 등의 일부 유틸리티 명령은 사용할 수 없다.&lt;/li&gt;
&lt;li&gt;SQL이 작동은 하지만 특정 값을 리턴하지 않는 SQL 함수를 정의하고 싶다면, void를 리턴하는 것으로 정의할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;function-간단-예시&#34; ke-size=&#34;size23&#34;&gt;▶ 1-1. Function 간단 예시&lt;/h3&gt;
&lt;p&gt;다음은 emp 테이블에서 음수의 salary를 삭제하는 함수이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법</title>
      <link>http://localhost:1313/posts/45/</link>
      <pubDate>Tue, 14 Nov 2023 15:36:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/45/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/45/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;단위-테스트&#34; style=&#34;color: #000000; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. 단위 테스트&lt;/h2&gt;
&lt;p&gt;하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Fast -&lt;/strong&gt; 빠르게 동작하여 자주 돌릴 수 있어야 한다.&lt;br&gt;
&lt;strong&gt;Independent -&lt;/strong&gt; 테스트는 독립적이며 서로 의존해서는 안된다.&lt;br&gt;
&lt;strong&gt;Repeatable -&lt;/strong&gt;  어느 환경에서도 반복이 가능해야 한다.&lt;br&gt;
&lt;strong&gt;Self-validating -&lt;/strong&gt; 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.&lt;br&gt;
&lt;strong&gt;Timely -&lt;/strong&gt; 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 명시적 JOIN 절로 플래너(Planner) 제어, 성능 향상</title>
      <link>http://localhost:1313/posts/44/</link>
      <pubDate>Wed, 08 Nov 2023 16:53:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/44/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/44/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;개요&#34; ke-size=&#34;size26&#34;&gt;1. 개요&lt;/h2&gt;
&lt;p&gt;PostgreSQL은 쿼리 Planner가 가장 효율적인 쿼리 플랜을 세워 쿼리를 실행시킨다. 이번 포스트는 쿼리 Planner가 플랜을 검색하는 과정을 의도적으로 제한하여 플랜 검색 시간을 단축시키는 방법에 대한 내용이다. 쿼리 선택지를 제한함으로써 시간을 줄이지만, 그만큼 모든 경우를 비교하는 것이기 아니라서 최고의 플랜을 찾을 수 없기에, 테이블 scan 방식 및 인덱스 등 쿼리의 작동방식을 명확히 이해한 후 설정이 필요하며, 설정전 성능비교, 설정 후의 데이터 증감에 따른 지속적인 모니터링이 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;플래너의-작동&#34; ke-size=&#34;size26&#34;&gt;2. 플래너의 작동&lt;/h2&gt;
&lt;h3 id=&#34;join&#34; ke-size=&#34;size23&#34;&gt;2-1. JOIN&lt;/h3&gt;
&lt;p&gt;Planner의 작동방식을 보기 위해 간단한 조인 쿼리를 확인해 보자&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링 컨테이너(Spring container)의 개념</title>
      <link>http://localhost:1313/posts/43/</link>
      <pubDate>Tue, 07 Nov 2023 16:45:10 +0000</pubDate>
      <guid>http://localhost:1313/posts/43/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;스프링-컨테이너spring-container란&#34; ke-size=&#34;size26&#34;&gt;1. 스프링 컨테이너(Spring container)란?&lt;/h2&gt;
&lt;p&gt;스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 생명주기 관리&lt;/li&gt;
&lt;li&gt;생성된 객체들의 추가적인 기능 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는
 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[수동]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Configuration -&lt;/strong&gt; 어플리케이션 구성정보를 등록&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Bean -&lt;/strong&gt; 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록
 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[자동]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@ComponentScan -&lt;/strong&gt; 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] IoC(제어의 역전) &amp; DI(의존성 주입)의 개념</title>
      <link>http://localhost:1313/posts/42/</link>
      <pubDate>Mon, 06 Nov 2023 14:20:06 +0000</pubDate>
      <guid>http://localhost:1313/posts/42/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;ioc-inversion-of-control-제어의-역전&#34; ke-size=&#34;size26&#34;&gt;1. IoC (Inversion of Control) 제어의 역전&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/42/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
 &lt;/p&gt;
&lt;p&gt;이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[WEB] JWT 토큰 인증의 개념과 장단점</title>
      <link>http://localhost:1313/posts/41/</link>
      <pubDate>Wed, 01 Nov 2023 18:47:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/41/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;jwt의-개념&#34; ke-size=&#34;size26&#34;&gt;1. JWT의 개념&lt;/h2&gt;
&lt;p&gt;JWT는 웹에서 사용자 인증/인가에 사용하는 토큰으로 Json Web Token의 줄임말이다. 웹에서 사용되는 JSON 형태의 토큰 표준 규격이며 쿠키와 유사하지만, 서명된 토큰이라는 차이점이 있다. 공개키, 개인키의 쌍으로 사용할 경우 서명된 토큰은 개인키를 보유한 서버에서만 복호화가 가능하다.
 &lt;/p&gt;
&lt;p&gt;보통 Authorization HTTP 헤더를 Bearer &amp;lt;토큰&amp;gt; 형태로 설정하여 클라이언트에서 서버로 전송한다. 서버에서는 토큰에 포함되어 있는 서명정보로 위변조를 검증하며 토큰은 Base64 인코딩 되어있다.
 &lt;/p&gt;
&lt;h2 id=&#34;2-jwt-구조&#34;&gt;2. JWT 구조&lt;/h2&gt;
&lt;p&gt;header, payload, signature가 각각 . 으로 구분되어 있다&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 윈도우 함수(Window Functions)의 개념, 성능 및 사용법 (over, sum/rank/ntitle/cume_dist 등...)</title>
      <link>http://localhost:1313/posts/40/</link>
      <pubDate>Tue, 31 Oct 2023 13:58:57 +0000</pubDate>
      <guid>http://localhost:1313/posts/40/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/40/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;윈도우-함수-window-functions란&#34; ke-size=&#34;size26&#34;&gt;1. 윈도우 함수 (Window Functions)란?&lt;/h2&gt;
&lt;p&gt;윈도우 함수는 행과 행 간의 관계를 쉽게 정의하기 위해 만든 함수이다. 이 기능은 일반 집계함수의 연산과 유사하지만, 일반 집계함수가 행 각각을 단일 그룹화해서 출력하는 반면에, 윈도우 함수는 각각의 행들이 &lt;strong&gt;그룹화되지 않으며 별도의 ID&lt;/strong&gt;를 가진다. 그렇기에 윈도우 함수는 현재 row의 정보보다 더 많은 정보에 접근이 가능하다. 예를 들면 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;일반집계함수 :&lt;/strong&gt; COUNT() + GROUP BY-&amp;gt; 그룹별 1개의 행 출력 (그룹 개수만큼 출력, 자르기 + 집약)&lt;br&gt;
&lt;strong&gt;윈도우집계함수 :&lt;/strong&gt; COUNT() OVER (PARTITION BY) -&amp;gt; ID개수만큼 행 출력 (행의 개수가 줄어들지 않는다, 자르기)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 데이터베이스 상속(Inheritance)의 개념과 사용법 및 성능비교 (Inherits, Only)</title>
      <link>http://localhost:1313/posts/39/</link>
      <pubDate>Mon, 30 Oct 2023 18:22:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/39/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/39/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;데이터베이스-상속inheritance이란&#34; ke-size=&#34;size26&#34;&gt;1. 데이터베이스 상속(Inheritance)이란?&lt;/h2&gt;
&lt;p&gt;상속은 객체지향 데이터베이스의 개념 중 하나이다. PostgreSQL은 테이블 생성 시 하나 이상의 다른 테이블로부터의 상속 기능을 제공하며, 이를 잘 활용하면 데이터베이스 설계에 새로운 가능성들을 열어준다. 데이터뿐만 아니라 부모 테이블의 컬럼 속성 및 인덱스 등의 특징들도 자식 테이블로 상속되기에 상황에 따라 효율적인 설계가 가능하다.&lt;/p&gt;
&lt;h2 id=&#34;데이터베이스-상속inherits-방법&#34; ke-size=&#34;size26&#34;&gt;2.데이터베이스 상속(Inherits) 방법&lt;/h2&gt;
&lt;p&gt;다음 예제는 PostgreSQL 공식 문서의 예제이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Capitals -&lt;/strong&gt; 이름, 인구, 고도, 요약어를 포함한 수도의 정보가 포함된 테이블&lt;br&gt;
&lt;strong&gt;Cities -&lt;/strong&gt; 이름, 인구, 고도를 포함한 도시 정보가 포함된 테이블&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 날짜 형태 검증하기 (ERROR: date/time field value out of range)</title>
      <link>http://localhost:1313/posts/38/</link>
      <pubDate>Thu, 26 Oct 2023 14:11:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/38/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/38/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;날짜-형태로-형변환&#34; ke-size=&#34;size26&#34;&gt;1. 날짜 형태로 형 변환&lt;/h2&gt;
&lt;p&gt;데이터 베이스에서 날짜형태로 형 변환을 하는 것은 다음과 같은 방법으로 쉽게 가능하다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- Unix타임(int)형 변환
SELECT to_timestamp(1658792421)

-- varchar 타입 변환
SELECT to_timestamp(&amp;#39;20231026&amp;#39;,&amp;#39;yyyymmdd&amp;#39;)

-- 날짜형을 char로 변환
SELECT to_char(to_timestamp(1658792421), &amp;#39;DD-MM-YYYY&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-유효한-날짜형태-검증&#34;&gt;2. 유효한 날짜형태 검증&lt;/h2&gt;
&lt;p&gt;데이터 정제가 완료되지 않아 조회하려는 데이터에 날짜유형에서 벗어난 데이터 
(&#39;20231301&#39;,202301&#39;, &#39;20231232&#39; 등)가 하나라도 있을 경우 조회 자체가 안된다. 그럴 경우 날짜 규격에 맞지 않는 데이터를 보정 후 연산해야 하는 경우가 있는데 단순 월별 케이스문으로 분리하여 날짜 유형에 어긋나는 경우를 찾을 수도 있지만 row마다 날짜 유형이 다르거나 윤달을 체크할 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Java] 가상 스레드 (Virtual Threads)란? 자바 21의 가상스레드 (Virtual Thread) 도입</title>
      <link>http://localhost:1313/posts/37/</link>
      <pubDate>Wed, 25 Oct 2023 16:37:30 +0000</pubDate>
      <guid>http://localhost:1313/posts/37/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;가상-스레드-virtual-threads란&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;1. 가상 스레드 (Virtual Threads)&lt;strong&gt;란?&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;2023.09.20 릴리즈 된 자바 21에 추가된 가상 스레드(Virtual Threads)라는 기능을 살펴보자.&lt;/p&gt;
&lt;p&gt;가상 스레드는 경량 스레드로, 높은 처리량의 동시 어플리케이션을 작성, 유지 및 관찰하는 작업 공수를 크게 줄인다.  OS스레드를 그대로 사용하지 않고 JVM 자체적으로 스케쥴링을 통해 사용할 수 있는 경량 스레드이며, 하나의 프로세스가 수십 - 수백만 스레드를 동시에 실행할수 있도록 설계되었다.&lt;/p&gt;
&lt;h2 id=&#34;자바의-전통적인-스레드&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;2. 자바의 전통적인 스레드&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;자바 개발자들은 근 30년동안 동시성 서버 어플리케이션의 처리를 위해 스레드에 의존해왔다. 모든 메서드의 구문들은 스레드 내부에서 실행되며, 1개의 요청을 1개의 스레드가 처리한다. 대표적으로 스프링은 멀티스레드 구조이기에, 여러 스레드의 실행이 동시에 발생하며 동시 요청이 많아질수록 스레드의 수 역시 증가한다. 각각의 스레드는 지역 변수를 저장하고 메소드 호출을하는 스택을 제공하며, 문제가 생겼을 때의 Context도 제공하는데, 예를들어 Exception은 동일 스레드 내에서의 메소드에 의해 throw/catch 된다. 그렇기 때문에 개발자는 스레드의 Stack trace로 문제를 추적할 수 있는 것이고, 그 외 Debugger (스레드의 메소드 내에서 구문을 차례로 훑어본다), Profiler(JFR) (여러 스레드의 행동을 시각화하여 스레드의 성능을 이해할 수 있도록 도와준다.)도 모두 스레드 기반으로 되어있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Java] Switch와 else-if의 효율성 비교 (Switch와 else-if 중에 어떤 걸 사용해야 할까?)</title>
      <link>http://localhost:1313/posts/36/</link>
      <pubDate>Tue, 24 Oct 2023 18:55:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/36/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/36/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;switch와-if-else&#34; ke-size=&#34;size26&#34;&gt;1. Switch와 if-else&lt;/h2&gt;
&lt;p&gt;조건에 따라 실행을 분기해야 할 때 우리는 조건문을 사용한다. Java에서는 switch / if-else 두 조건문을 선택적으로 사용 가능하다. 보통 가독성을 기준으로 선택을 많이 하나, 효율성 기준에서 어떤 것을 선택하는 것이 좋을지 비교해보려 한다.
 &lt;/p&gt;
&lt;p&gt;일단 switch 구분에서 Strings를 사용하는 것에 관한 공식문서를 보면,
 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;switch&lt;/strong&gt; statement compares the &lt;strong&gt;String&lt;/strong&gt; object in its expression with the expressions associated with each &lt;strong&gt;case&lt;/strong&gt; label as if it were using the &lt;strong&gt;String.equals&lt;/strong&gt; method; consequently, the comparison of &lt;strong&gt;String&lt;/strong&gt; objects in &lt;strong&gt;switch&lt;/strong&gt; statements is case sensitive. The Java compiler generates generally more efficient bytecode from &lt;strong&gt;switch&lt;/strong&gt; statements that use &lt;strong&gt;String&lt;/strong&gt; objects than from chained &lt;strong&gt;if-then-else&lt;/strong&gt; statements.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Java] 클래스 로딩 과정(Java Class Loading Process)이란?</title>
      <link>http://localhost:1313/posts/35/</link>
      <pubDate>Mon, 23 Oct 2023 17:30:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/35/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;클래스-로딩-과정-java-class-loading-process-이란&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;1. 클래스 로딩 과정 (Java Class Loading Process) 이란?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 &lt;/p&gt;
&lt;p&gt;자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 (&amp;lsquo;java.lang.ClassNotFoundException&#39;과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;클래스-로더-3단계-과정&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;2. 클래스 로더 3단계 과정&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Linux] 스왑 메모리(Swap Memory)의 개념과 적용방법</title>
      <link>http://localhost:1313/posts/34/</link>
      <pubDate>Mon, 23 Oct 2023 15:58:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/34/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;리눅스-swap-메모리-설정-예제는-ec2-환경에서-진행&#34; ke-size=&#34;size26&#34;&gt;1. 리눅스 Swap 메모리 설정 (예제는 EC2 환경에서 진행)&lt;/h2&gt;
&lt;h3 id=&#34;swap-메모리-확인&#34; style=&#34;color: #333333; text-align: start;&#34; ke-size=&#34;size23&#34;&gt;1-1. Swap 메모리 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;swapon -s 

free -h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/34/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-23%20%EC%98%A4%ED%9B%84%203.25.49.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;shared =&lt;/strong&gt; 하나의 프로세스에서 다른 프로세스의 데이터에 효율적으로 접근하기 위해 사용하는 메모리&lt;br&gt;
&lt;strong&gt;buff/cache =&lt;/strong&gt; 버퍼와 캐시를 위해 사용하는 메모리, 커널이 성능향상을 위해 캐시 영역으로 사용되는 메모리&lt;br&gt;
&lt;strong&gt;buff =&lt;/strong&gt; 프로세스가 사용하는 메모리 영역이 아닌 시스템 성능향상을 위해 커널이 사용하고 있는 영역&lt;br&gt;
&lt;strong&gt;cache =&lt;/strong&gt; 캐시영역의 메모리, I/O 작업을 더 빠르게 하기 위해 커널에서 사용&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링부트 &#43; Mybatis 데이터소스 여러개 연결 (스프링 다중 데이터베이스 연결)</title>
      <link>http://localhost:1313/posts/33/</link>
      <pubDate>Fri, 20 Oct 2023 17:57:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/33/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/33/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 스프링부트 + 마이바티스 프로젝트에 2개 이상의 데이터소스를 연결하는 예제이다. &lt;/p&gt;
&lt;p&gt;기존 스프링 데이터베이스 연동이 되어있다고 가정 후 진행되며, 신규 데이터베이스는 구별이 쉽도록 new 데이터베이스로 명칭 한다.&lt;/p&gt;
&lt;h2 id=&#34;신규-데이터베이스-접속정보-추가&#34; ke-size=&#34;size26&#34;&gt;1. 신규 데이터베이스 접속정보 추가&lt;/h2&gt;
&lt;p&gt;추가될 데이터베이스의  속성을 &lt;strong&gt;application.properties&lt;/strong&gt;에 추가&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#기존 DB Setting
spring.datasource.url={url}
spring.datasource.driverClassName={driverClassName}
spring.datasource.username={username}
spring.datasource.password={password}
spring.datasource.schema={schema}

#추가될 DB Setting
new.datasource.url={url}
new.datasource.driverClassName={driverClassName}
new.datasource.username={username}
new.datasource.password={password}
new.datasource.schema={schema}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;데이터베이스-연결-빈-속성-추가&#34; ke-size=&#34;size26&#34;&gt;2. 데이터베이스 연결 빈 속성 추가&lt;/h2&gt;
&lt;p&gt;기존 데이터베이스 연결 설정을 하는 &lt;strong&gt;DatabaseConfig.java&lt;/strong&gt; 외에 &lt;strong&gt;NewDatabaseConfig.java&lt;/strong&gt;신규로 추가한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;기존 DatabaseConfig.java&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링 배치 ItemReader의 개념, (MybatisCursorItemReader, MybatisPagingItemReader 구현)</title>
      <link>http://localhost:1313/posts/32/</link>
      <pubDate>Thu, 19 Oct 2023 18:20:45 +0000</pubDate>
      <guid>http://localhost:1313/posts/32/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/32/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;itemreader란&#34; ke-size=&#34;size26&#34;&gt;1. ItemReader란?&lt;/h2&gt;
&lt;p&gt;스프링 배치의 ItemReader는 다음과 같은 과정을 거쳐 데이터를 처리한다.
 &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/32/img_1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;대부분의 데이터 형태는 이미 ItemReader로 제공하고 있기에 ItemReader, ItemStream 인터페이스 자체를 구현할 필요는 없다.&lt;/p&gt;
&lt;p&gt;ItemReader는 Chunk 기반 트랜잭션을 다루며 Cursor, Paging 가 대표적인 2가지 방식이다.&lt;/p&gt;
&lt;h2 id=&#34;cursor-paging-형식&#34; ke-size=&#34;size26&#34;&gt;2. Cursor, Paging 형식&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/32/img_2.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;cursor기반-itemreader&#34; ke-size=&#34;size23&#34;&gt;2-1. Cursor기반 ItemReader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JDBC ResultSet의 기본 기능이다.&lt;/li&gt;
&lt;li&gt;ResultSet이 Open 될 때마다 데이터베이스의 데이터가 반환된다.&lt;/li&gt;
&lt;li&gt;데이터베이스와 연결 맺은 후 데이터를 Streaming 방식으로 I/O이다.&lt;/li&gt;
&lt;li&gt;현재 행에서Cursor를 유지하며 다음 데이터를 호출하면 Cursor를 한 칸씩 옮기면서 데이터를 가져온다.&lt;/li&gt;
&lt;li&gt;하나의 Connection으로 배치가 끝날때까지 사용되기에 Batch가 끝나기 전에 데이터베이스와 애플리케이션의 연결이 먼저 끊어질 수 있어 데이터베이스와 SocketTimeout을 충분한 값으로 설정하여야 한다.&lt;/li&gt;
&lt;li&gt;모든 결과를 메모리에 할당 하기 때문에 메모리 사용량이 많아진다.&lt;/li&gt;
&lt;li&gt;Chunk 사이즈 만큼의 트랜잭션 단위로 데이터를 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Cursor 기반 ItemReader 구현체&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[네트워크] TCP/IP의 개념</title>
      <link>http://localhost:1313/posts/31/</link>
      <pubDate>Wed, 18 Oct 2023 17:46:05 +0000</pubDate>
      <guid>http://localhost:1313/posts/31/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;tcpip-란&#34; ke-size=&#34;size26&#34;&gt;1. TCP/IP 란?&lt;/h2&gt;
&lt;p&gt;패킷 전송방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서대로 받는 것을 보장하지 않지만, TCP는 IP 위에서 동작하는 프로토콜로 데이터의 전달을 보증하고 보낸 순서대로 받게 해 준다. IP가 패킷 간의 관계를 이해하지 못하고 목적지를 찾아가는 데만 집중한다면 TCP는 Endpoint 간 통신할 준비가 되어있는지, 데이터 전송이 제대로 되었는지, 데이터가 변질되지 않은지, 데이터 유실은 없는지 등을 점검한다.
 &lt;/p&gt;
&lt;p&gt;즉 IP주소 체계를 따르고 IP Routing을 통해 목적지에 도달하여 TCP의 특성을 활용하여 송신자와 수신자의 논리적 연결을 생성, 신뢰성 유지한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[네트워크] 소켓(SOCEKT) 통신, 3-way handshake의 개념</title>
      <link>http://localhost:1313/posts/30/</link>
      <pubDate>Wed, 18 Oct 2023 15:32:25 +0000</pubDate>
      <guid>http://localhost:1313/posts/30/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;소켓socket이란&#34; ke-size=&#34;size26&#34;&gt;1. 소켓(Socket)이란&lt;/h2&gt;
&lt;p&gt;소켓은 떨어져 있는 두 호스트를 연결해 주는 도구로써 인터페이스 역할을 한다. TCP/IP 기반 네트워크 통신에서 데이터 송수신의 앤드포인트이며 앤드포인트는 IP, Port조합으로 이루어진 목적지를 나타낸다. 서버-클라이언트 간 데이터를 주고받는 양방향 연결 지향성 통신으로 지속적으로 연결을 유지하면서 실시간 데이터를 주고받는 데 사용된다.&lt;/p&gt;
&lt;p&gt;소켓은 서버 소켓과 클라이언트 소켓으로 이루어지며, 다음은 소켓 간 통신이 이루어지는 과정이다.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/30/img.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;서버-소켓&#34; ke-size=&#34;size23&#34;&gt;&lt;strong&gt;1-1. 서버 소켓&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;클라이언트에서 연결요청이 오기를 기다렸다가 연결 요청이 들어오면 클라이언트와 연결을 맺고 새로운 소켓을 만든다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring] 스프링 트랜잭션의 개념 및 적용 (@Transactional 사용법)</title>
      <link>http://localhost:1313/posts/29/</link>
      <pubDate>Tue, 17 Oct 2023 18:37:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/29/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/29/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션이란&#34; ke-size=&#34;size26&#34;&gt;트랜잭션이란?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/20&#34;&gt;[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;스프링에서-제공하는-트랜잭션&#34; ke-size=&#34;size26&#34;&gt;스프링에서 제공하는 트랜잭션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;◆ 동기화 (Synchronization)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;트랜잭션을 시작하기 위한 Connection 객체를 특별 저장소에 보관하고 필요할 때 쓸 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;작업 쓰레드마다 Connection 객체를 독립적으로 관리하기에 멀티 스레드 환경에서도 충돌이 발생하지 않는다. 하지만 JDBC가 아닌 Hiberate 같은 기능을 사용한다면 JDBC 종속적인 트랜잭션 동기화 코드들은 문제가 발생한다. 대표적으로 Hibernate는 Connection이 아니라 Session 객체를 사용하기 때문이다. 이를 해결하기 위해 트랜잭션 관리 부분을 추상화한 기술을 제공하고 있다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?</title>
      <link>http://localhost:1313/posts/28/</link>
      <pubDate>Tue, 17 Oct 2023 14:01:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/28/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/28/img.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습&lt;/p&gt;
&lt;h2 id=&#34;thread란&#34; ke-size=&#34;size26&#34;&gt;1. Thread란?&lt;/h2&gt;
&lt;p&gt;CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. &lt;/p&gt;
&lt;h3 id=&#34;스레드의-종류&#34; ke-size=&#34;size23&#34;&gt;스레드의 종류&lt;/h3&gt;
&lt;p&gt;스레드는 지원 주체에 따라 2가지로 나눌 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Threads&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드&lt;/li&gt;
&lt;li&gt;라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.&lt;/li&gt;
&lt;li&gt;여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)&lt;/li&gt;
&lt;li&gt;스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Kernel Threads&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[AWS] RDS 적정 인스턴스 선택, 비용 최적화</title>
      <link>http://localhost:1313/posts/27/</link>
      <pubDate>Mon, 16 Oct 2023 18:35:57 +0000</pubDate>
      <guid>http://localhost:1313/posts/27/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/27/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rds란&#34; ke-size=&#34;size26&#34;&gt;1. RDS란?&lt;/h2&gt;
&lt;p&gt;RDS는 클라우드에서 데이터베이스를 쉽게 설정, 운영 및 확장할 수 있는 완전관리형 오픈소스 관계형 데이터베이스이다. &lt;/p&gt;
&lt;p&gt;온디맨드, 혹은 예약형 인스턴스 구매로 유연한 데이터베이스 관리가 가능하며 스토리지 및 메모리 등의 설정에 따라 금액이 달라진다.&lt;/p&gt;
&lt;h2 id=&#34;rds-비용을-결정하는-요소&#34; ke-size=&#34;size26&#34;&gt;2. RDS 비용을 결정하는 요소&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DB 인스턴스 가용시간&lt;/strong&gt; - 1초 단위로 청구되며 1회 최소 10분 과금&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스토리지 (월별 GB당)&lt;/strong&gt; - DB인스턴스에 프로비저닝 한 스토리지 용량&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;월별 I/O&lt;/strong&gt; - 총 스토리지 I/O 요청 수&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백업 스토리지&lt;/strong&gt; - 자동 데이터베이스 백업 및 모든 데이터베이스 스냅샷과 연결된 스토리지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 전송&lt;/strong&gt; - RDS에서 인스턴스를 통한 데이터 송수신&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;티어별 계산은 여기서 가능 (PostgreSQL 기준)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 쿼리 성능향상 (실행계획 보는 법, 상세 확인방법, Explain의 어떤 지표를 봐야할까?)</title>
      <link>http://localhost:1313/posts/26/</link>
      <pubDate>Thu, 12 Oct 2023 18:25:52 +0000</pubDate>
      <guid>http://localhost:1313/posts/26/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/26/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;실행-계획-확인&#34; ke-size=&#34;size26&#34;&gt;1. 실행 계획 확인&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--Synopsis
EXPLAIN [ ( option [, ...] ) ] 쿼리문
EXPLAIN [ ANALYZE ] [ VERBOSE ] 쿼리문

option 자리에 사용할 수 있는 것들:

    ANALYZE [ boolean ]
    VERBOSE [ boolean ]
    COSTS [ boolean ]
    BUFFERS [ boolean ]
    TIMING [ boolean ]
    FORMAT { TEXT | XML | JSON | YAML }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;* 이후 설명에서 사용될 테스트 데이터는 아래의 &amp;quot;7. 테스트 데이터 생성&amp;quot; 부분 쿼리 확인&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 뷰(VIEW) 테이블 개념 및 사용, 생성(CREATE), 수정(CREATE OR REPLACE), 삭제(DROP)</title>
      <link>http://localhost:1313/posts/25/</link>
      <pubDate>Wed, 11 Oct 2023 19:29:02 +0000</pubDate>
      <guid>http://localhost:1313/posts/25/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/25/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;뷰view-테이블의-사용-생성-삭제-수정&#34; ke-size=&#34;size26&#34;&gt;1. 뷰(VIEW) 테이블의 사용 (생성, 삭제, 수정)&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본 생성
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = &amp;#39;Comedy&amp;#39;;

-- 삭제
DROP VIEW comedies

--Synopsis
CREATE [ OR REPLACE ] VIEW name [ ( column_name [, ...] ) ] AS query
-- or
CREATE VIEW name [ ( column [, ...] ) ]
    AS query
    [ WITH [ CASCADE | LOCAL ] CHECK OPTION ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;뷰view의-개념-및-특징&#34; ke-size=&#34;size26&#34;&gt;2. 뷰(VIEW)의 개념 및 특징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;정의된 쿼리를 실행시켜 가상의 테이블 형태로 보여주며 테이블을 조회하는 것과 같은 방식으로 조회가 가능하다.&lt;/li&gt;
&lt;li&gt;VIEW는 물리적으로 생성되지 않는다.&lt;/li&gt;
&lt;li&gt;복잡한 쿼리를 단순화시키거나 반복된 쿼리 작업을 효율적으로 처리할 수 있게 해 준다.&lt;/li&gt;
&lt;li&gt;VIEW에 참조된 쿼리는 호출 시 매번 새로 실행되기에 실시간 결과물을 조회할 수 있다.&lt;/li&gt;
&lt;li&gt;CREATE OR REPLACE VIEW로 VIEW를 수정할 시, 완전히 일치하는 컬럼 셋을 조회하는 쿼리로만 대체가 가능하다. (같은 컬럼명과 데이터타입)&lt;/li&gt;
&lt;li&gt;Schema 명을 명시적으로 작성하면 해당 Schema에, 아니라면 현재 Schema에 생성된다.&lt;/li&gt;
&lt;li&gt;View, Table, Sequence, Index는 한 스키마에 중복된 명칭을 가질 수 없다.&lt;/li&gt;
&lt;li&gt;VIEW 결과물은 수정이 불가능하다.&lt;/li&gt;
&lt;li&gt;테이블의 전체 컬럼 및 정보를 직접적으로 노출시키지 않은 채로 사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;주의사항&#34; ke-size=&#34;size26&#34;&gt;3. 주의사항&lt;/h2&gt;
&lt;h3 id=&#34;read-only&#34; ke-size=&#34;size23&#34;&gt;          3-1. READ-ONLY&lt;/h3&gt;
&lt;p&gt;VIEW 자체에 insert, update, delete를 실행할 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] CREATE TABLE AS (결과물을 테이블로)</title>
      <link>http://localhost:1313/posts/24/</link>
      <pubDate>Wed, 11 Oct 2023 18:44:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/24/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/24/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;create-table-as-사용&#34; ke-size=&#34;size26&#34;&gt;1. CREATE TABLE AS 사용&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &amp;gt;= &amp;#39;2002-01-01&amp;#39;;

--Synopsis
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name [ (column_name [, ...] ) ] [ [ WITH | WITHOUT ] OIDS ]
    AS query
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;create-table-as-옵션&#34; ke-size=&#34;size26&#34;&gt;2. CREATE TABLE AS 옵션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;- TEMPORARY / TEMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        임시 테이블로 생성되며 세션이 종료될 시 삭제된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- WITH OIDS / WITHOUT OIDS&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 시퀀스(Sequence)의 개념과 사용법(생성, 삭제, 조회 등)</title>
      <link>http://localhost:1313/posts/23/</link>
      <pubDate>Wed, 11 Oct 2023 14:12:44 +0000</pubDate>
      <guid>http://localhost:1313/posts/23/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/23/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;시퀀스sequence의-사용&#34; ke-size=&#34;size26&#34;&gt;1. 시퀀스(Sequence)의 사용&lt;/h2&gt;
&lt;h3 id=&#34;생성-삭제-조회&#34; ke-size=&#34;size23&#34;&gt;          1-1. 생성, 삭제, 조회&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 101부터 시작하는 기본 시퀀스 생성
CREATE SEQUENCE serial START 101;
-- 시퀀스 다음값 조회
SELECT nextval(&amp;#39;serial&amp;#39;);
-- 시퀀스 현재값 조회
select currval(&amp;#39;serial&amp;#39;);
-- 시퀀스 삭제
DROP SEQUENCE serial;

-- 시퀀스로 INSERT하기
INSERT INTO distributors VALUES (nextval(&amp;#39;serial&amp;#39;), &amp;#39;nothing&amp;#39;);
-- COPY FROM 후에 시퀀스 시작값 변경하기
BEGIN;
COPY distributors FROM &amp;#39;input_file&amp;#39;;
SELECT setval(&amp;#39;serial&amp;#39;, max(id)) FROM distributors;
END;

-- Synopsis
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] 이름
    [ AS 자료형 ]
    [ INCREMENT [ BY ] 증가값 ]
    [ MINVALUE 최소값 | NO MINVALUE ] [ MAXVALUE 최대값 | NO MAXVALUE ]
    [ START [ WITH ] 시작값 ] [ CACHE 캐시 ] [ [ NO ] CYCLE ]
    [ OWNED BY { 테이블이름.칼럼이름 | NONE } ]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;사용-중인-시퀀스-확인&#34; ke-size=&#34;size23&#34;&gt;          1-2. 사용 중인 시퀀스 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select n.nspname as sequence_schema, 
          c.relname as sequence_name,
          u.usename as owner
from pg_class c 
     join pg_namespace n on n.oid = c.relnamespace
     join pg_user u on u.usesysid = c.relowner
where c.relkind = &amp;#39;S&amp;#39;
     and u.usename = current_user;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;시퀀스-생성시-상세-옵션&#34; ke-size=&#34;size26&#34;&gt;2. 시퀀스 생성시 상세 옵션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;- TEMPORARY or TEMP&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 역할 및 권한 (ROLE, USER, GROUP) 개념 및 설정</title>
      <link>http://localhost:1313/posts/22/</link>
      <pubDate>Wed, 11 Oct 2023 10:32:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/22/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/22/img.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;role&#34; ke-size=&#34;size26&#34;&gt;1. ROLE&lt;/h2&gt;
&lt;h3 id=&#34;role-생성&#34; ke-size=&#34;size23&#34;&gt;        1-1. ROLE 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE ROLE jonathan LOGIN;
-- 비밀번호 포함
CREATE USER davide WITH PASSWORD &amp;#39;jw8s0F4&amp;#39;;
-- 권한 포함
CREATE ROLE admin WITH CREATEDB CREATEROLE;
-- 사용 기한 포함
CREATE ROLE miriam WITH LOGIN PASSWORD &amp;#39;jw8s0F4&amp;#39; VALID UNTIL &amp;#39;2005-01-01&amp;#39;;
-- 삭제
DELETE ROLE miriam;

-- Synopsis

CREATE ROLE name [ [ WITH ] option [ ... ] ]

where option can be:

      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | REPLICATION | NOREPLICATION
    | BYPASSRLS | NOBYPASSRLS
    | CONNECTION LIMIT connlimit
    | [ ENCRYPTED ] PASSWORD &amp;#39;password&amp;#39; | PASSWORD NULL
    | VALID UNTIL &amp;#39;timestamp&amp;#39;
    | IN ROLE role_name [, ...]
    | IN GROUP role_name [, ...]
    | ROLE role_name [, ...]
    | ADMIN role_name [, ...]
    | USER role_name [, ...]
    | SYSID uid
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;role-이란&#34; ke-size=&#34;size23&#34;&gt;        1-2. ROLE 이란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE ROLE은 PostgreSQL database cluster에 새로운 ROLE을 추가한다. &lt;/li&gt;
&lt;li&gt;ROLE은 데이터베이스 object, 권한을 가질 수 있는 엔티티이다.&lt;/li&gt;
&lt;li&gt;ROLE은 사용방법에 따라 USER, GROUP 혹은 둘다로 간주될 수 있다.&lt;/li&gt;
&lt;li&gt;CREATEROLE 권한이 있어야지만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;ALTER ROLE, DELETE ROLE을 통해 권한을 수정, 삭제 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;role-권한별-특징&#34; ke-size=&#34;size23&#34;&gt;        1-3. ROLE 권한별 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SUPERUSER - 로그인을 제외한 모든 권한 포함 (ex. Role 생성 및 권한 부여)&lt;/li&gt;
&lt;li&gt;LOGIN - 데이터베이스에 로그인하기 위한 권한&lt;/li&gt;
&lt;li&gt;PASSWORD - 로그인 비밀번호 설정&lt;/li&gt;
&lt;li&gt;CREATEDB - 데이터베이스 생성&lt;/li&gt;
&lt;li&gt;CREATEROLE - ROLE 생성/삭제/수정&lt;/li&gt;
&lt;li&gt;REPLICATION - REPLICATION 권한&lt;/li&gt;
&lt;li&gt;CONNECTIONLIMIT - 데이터베이스 접속 카운트&lt;/li&gt;
&lt;li&gt;INHERIT - ROLE 권한들 상속&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;user&#34; ke-size=&#34;size26&#34;&gt;2. USER&lt;/h2&gt;
&lt;h3 id=&#34;user-생성&#34; ke-size=&#34;size23&#34;&gt;        2-1. USER 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE USER jonathan;
-- 비밀번호 추가
CREATE USER davide WITH PASSWORD &amp;#39;jw8s0F4&amp;#39;;
-- 만료기한 추가
CREATE USER miriam WITH PASSWORD &amp;#39;jw8s0F4&amp;#39; VALID UNTIL &amp;#39;2005-01-01&amp;#39;;
-- 권한 추가
CREATE USER manuel WITH PASSWORD &amp;#39;jw8s0F4&amp;#39; CREATEDB;

--Synopsis
CREATE USER name [ [ WITH ] option [ ... ] ]

where option can be:
    
      SYSID uid 
    | CREATEDB | NOCREATEDB
    | CREATEUSER | NOCREATEUSER
    | IN GROUP groupname [, ...]
    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD &amp;#39;password&amp;#39;
    | VALID UNTIL &amp;#39;abstime&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;user란&#34; ke-size=&#34;size23&#34;&gt;        2-2. USER란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE ROLE은 PostgreSQL database cluster에 새로운 User을 추가한다.&lt;/li&gt;
&lt;li&gt;CREATEUSER 권한이 있어야지만 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;group&#34; ke-size=&#34;size26&#34;&gt;3. GROUP&lt;/h2&gt;
&lt;h3 id=&#34;group-생성&#34; ke-size=&#34;size23&#34;&gt;        3-1. GROUP 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--기본
CREATE GROUP staff;
--유저 추가
CREATE GROUP marketing WITH USER jonathan, david;
--그룹 삭제
DROP GROUP staff;

-- Synopsis
CREATE GROUP name [ [ WITH ] option [ ... ] ]

where option can be:

     SYSID gid
   | USER  username [, ...]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;group이란&#34; ke-size=&#34;size23&#34;&gt;        3-2. GROUP이란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE GROUP은 USER 그룹을 생성한다. &lt;/li&gt;
&lt;li&gt;SUPERUSER 권한이 있어야지만 생성가능하다.&lt;/li&gt;
&lt;li&gt;데이터베이스의 cluster 레벨에 접근 가능하기 위해 GROUP, USER, ROLE은 모두 cluster단에서 정의되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;role-user-group-차이&#34; ke-size=&#34;size26&#34;&gt;4. ROLE, USER, GROUP 차이&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ROLE은 Postgresql Database 관련 권한들을 모아 놓은 것으로, 8.1버전부터 USER와 GROUP의 개념이 ROLE로 통합되었다.&lt;/li&gt;
&lt;li&gt;현재 버전에서는 USER와 ROLE의 기능은 동일하며, USER는 login 권한이 default, ROLE은 login 권한을 별도로 부여해야 하는 차이점만 있다. &lt;/li&gt;
&lt;li&gt;CREATE GROUP의 경우 PostgreSQL의 SQL 표준에는 존재하지 않으며, ROLE과 비슷한 개념을 가지고 있다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 제약조건 (Constraint) 개념 및 설정 (Primary Keys, Foreign Keys, Unique, Not null, Check)</title>
      <link>http://localhost:1313/posts/21/</link>
      <pubDate>Tue, 10 Oct 2023 15:41:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/21/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/21/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postgresql-제약조건-constrant란&#34; ke-size=&#34;size26&#34;&gt;PostgreSQL 제약조건 (Constrant)란?&lt;/h2&gt;
&lt;p&gt;데이터베이스는 데이터 타입 외에 제약조건들을 통해 데이터의 무결성을 유지한다.&lt;/p&gt;
&lt;p&gt;제약조건에는 여러 가지 종류가 있으며 DMBS에 마다 다양하지만, 이번 포스트는 PostgreSQL의 5가지 제약 조건들을 설명하겠다.
 &lt;/p&gt;
&lt;p&gt;1. Primary Keys(PK)&lt;/p&gt;
&lt;p&gt;2. Foreign Keys(FK)&lt;/p&gt;
&lt;p&gt;3. Check&lt;/p&gt;
&lt;p&gt;4. Not-null&lt;/p&gt;
&lt;p&gt;5. Unique&lt;/p&gt;
&lt;h2 id=&#34;primary-keys-pk&#34; ke-size=&#34;size26&#34;&gt;1. Primary Keys (PK)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Primary Keys는 테이블의 각 ROW를 구분하는 유니크한 컬럼 혹은 컬럼의 조합이다.&lt;/li&gt;
&lt;li&gt;Not null, Unique Constraints의 조합이다. 테이블인 단 1개의 PK만 가질 수 있다.&lt;/li&gt;
&lt;li&gt;PK 생성 시 Postgresql은 B-tree 인덱스를 자동으로 부여한다.&lt;/li&gt;
&lt;li&gt;B-tree 인덱스를 사용하기 때문에 컬럼의 조합으로 PK를 설정 시 순서가 중요하다. (상세 내용은 다음 포스트에서 확인이 가능하다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/6&#34;&gt;[PostgreSQL] B-tree 인덱스의 원리 및 특징&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용</title>
      <link>http://localhost:1313/posts/20/</link>
      <pubDate>Tue, 10 Oct 2023 14:42:53 +0000</pubDate>
      <guid>http://localhost:1313/posts/20/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/20/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션transaction이란&#34; ke-size=&#34;size26&#34;&gt;1. 트랜잭션(Transaction)이란?&lt;/h2&gt;
&lt;p&gt;트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션-적용&#34; ke-size=&#34;size26&#34;&gt;2. 트랜잭션 적용&lt;/h2&gt;
&lt;p&gt;트랜잭션을 사용하는 커맨드 예제이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = &amp;#39;Alice&amp;#39;;
COMMIT;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[AWS] AMI(Amazon Machine Image) 개념 및 적용</title>
      <link>http://localhost:1313/posts/19/</link>
      <pubDate>Mon, 09 Oct 2023 15:21:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/19/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/19/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;amiamazon-machine-image란&#34; ke-size=&#34;size26&#34;&gt;1. AMI(Amazon Machine Image)란?&lt;/h2&gt;
&lt;p&gt;인스턴스를 생성하는데 필요한 정보를 가지고 있는 이미지이다. 한 AMI로 동일 속성을 가진 인스턴스를 여러 개 생성할 수 있으며 인스턴스의 설정값을 가지고 있는 템플릿으로 보면 된다. AMI 생성 시 소프트웨어 구성이 기재된 템플릿 (예: 운영 체제, 애플리케이션 서버, 애플리케이션)을 추출하고, AMI를 사용하여 신규 인스턴스를 바로 복제 가능하다.&lt;/p&gt;
&lt;h2 id=&#34;주의사항&#34; ke-size=&#34;size26&#34;&gt;2. 주의사항&lt;/h2&gt;
&lt;p&gt;AMI 생성시 기존 인스턴스가 정지 또는 최소전력 상태로 전환되니 주의해야 한다. AMI 생성 시 인스턴스 재부팅 안 함 옵션이 선택가능하지만, 재부팅을 하지 않을 경우 시스템의 무결성을 보장할 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[AWS] Elastic IP (탄력적 IP)의 개념 및 적용</title>
      <link>http://localhost:1313/posts/18/</link>
      <pubDate>Mon, 09 Oct 2023 14:41:55 +0000</pubDate>
      <guid>http://localhost:1313/posts/18/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/18/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;elastic-ip-탄력적-ip-란&#34; ke-size=&#34;size26&#34;&gt;1. Elastic IP (탄력적 IP) 란?&lt;/h2&gt;
&lt;p&gt;EIP(Elastic Ip Address)란 인터넷으로 접속이 가능한 공인 IP를 할당하여, 인스턴스에 탈부착할 수 있는 서비스이다. 인스턴스 혹은 네트워크 인터페이스에 연결이 가능하며 삭제 전까지 해당 IP를 유지할 수 있다.
 &lt;/p&gt;
&lt;p&gt;EC2 인스턴스 생성 시 공인 IP 사용 설정을 Enable로 변경 (default는 Disable)할 경우 인스턴스 자체에 공인 IP를 할당받을 수 있는데 왜 굳이 Elastic IP를 사용하는 것일까?&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/18/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-09%20%EC%98%A4%ED%9B%84%201.56.51.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;인스턴스가 stop 후 재시작될 경우 공인 IP가 변경되는 경우가 발생한다. 인스턴스 자체의 공인 IP가 변경될 경우 큰 문제로 이어질 수 있어&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Vacuum 개념 및 적절한 사용</title>
      <link>http://localhost:1313/posts/17/</link>
      <pubDate>Mon, 09 Oct 2023 13:33:14 +0000</pubDate>
      <guid>http://localhost:1313/posts/17/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/17/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;vacuum-이란&#34; ke-size=&#34;size26&#34;&gt;1. Vacuum 이란?&lt;/h2&gt;
&lt;p&gt;Vacuum은 postgresql에서 dead tuple이 차지하는 저장공간을 회수한다. 일반적으로 Postgresql에서 update, delete tuple 은 물리적으로 삭제되지 않으며 vacuum이 완료될 때까지 계속 존재한다. &lt;/p&gt;
&lt;p&gt;(update, delete 시 tuple의 순환은 MVCC 개념에서 확인할 수 있다.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/15&#34;&gt;[PostgreSQL] MVCC (Multi-Version Concurrency Control)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그렇기 때문에 특히 자주 업데이트되는 테이블의 경우 주기적인 Vacuum 수행이 필요하다. Vacuum은 특정 테이블에 한해서도 실행이 가능하고, 테이블을 지정하지 않는다면 전체 테이블 (권한을 보유한)에 대해서 실행된다.&lt;/p&gt;
&lt;h2 id=&#34;vacuum-명령어&#34; style=&#34;color: #000000; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. Vacuum 명령어&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- DB 전체 full vacuum
vacuum full analyze;

-- DB 전체 간단하게 실행
vacuum verbose analyze;

-- 해당 테이블만 간단하게 실행
vacuum analyze [테이블 명];

-- 특정 테이블만 full vacuum
vacuum full [테이블 명];
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;vacuum-상세-옵션&#34; ke-size=&#34;size26&#34;&gt;3. Vacuum 상세 옵션&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;VACUUM [ ( option [, ...] ) ] [ table_and_columns [, ...] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ ANALYZE ] [ table_and_columns [, ...] ]

where option can be one of:

    FULL [ boolean ]
    FREEZE [ boolean ]
    VERBOSE [ boolean ]
    ANALYZE [ boolean ]
    DISABLE_PAGE_SKIPPING [ boolean ]
    SKIP_LOCKED [ boolean ]
    INDEX_CLEANUP { AUTO | ON | OFF }
    PROCESS_MAIN [ boolean ]
    PROCESS_TOAST [ boolean ]
    TRUNCATE [ boolean ]
    PARALLEL integer
    SKIP_DATABASE_STATS [ boolean ]
    ONLY_DATABASE_STATS [ boolean ]
    BUFFER_USAGE_LIMIT [ size ]

and table_and_columns is:

    table_name [ ( column_name [, ...] ) ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;vacuum-analyze&#34; ke-size=&#34;size26&#34;&gt;4. Vacuum analyze&lt;/h2&gt;
&lt;p&gt;Vacuum analyze 는 vacuum 후 테이블 별로 analyze를 수행(통계정보 수집)하기에 유지보수에 원활하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Linux] 심볼릭 링크 (Symbolic link) 설정하기</title>
      <link>http://localhost:1313/posts/16/</link>
      <pubDate>Mon, 09 Oct 2023 11:46:58 +0000</pubDate>
      <guid>http://localhost:1313/posts/16/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;심볼릭-링크-symbolic-link란&#34; ke-size=&#34;size26&#34;&gt;1. 심볼릭 링크 (Symbolic link)란?&lt;/h2&gt;
&lt;p&gt;링크를 걸어 원본 파일을 직접 사용하는 것과 같은 효과를 낸다. 특정 폴더에 링크를 걸어 NAS, library 원본 파일을 사용하거나 톰캣 빌듯이 상위경로의 파일을 사용하고자 할 때 사용한다. 심볼릭 링크는 단순히 원본파일을 가리키도록 링크만 연결시켜둔 것으로 원본파일을 가리키기만 하고 있으므로 원본파일의 크기와 무관하며 원본파일이 삭제되어 존재하지 않을 경우에 빨간색으로 링크파일의 원본파일이 없다는 것을 알려준다.
 &lt;/p&gt;
&lt;h2 id=&#34;2-심볼릭-링크-설정하기&#34;&gt;2. 심볼릭 링크 설정하기&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ln -s [대상 원본 파일] [새로 만들 파일 이름]

-- 파일을 생성 후 링크를 거는 것이 아니라 새로 만들 파일/directory가 없는 채로 링크를 생성을 해야한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ln-옵션&#34; style=&#34;background-color: #ffffff; color: #000000; text-align: start;&#34; ke-size=&#34;size23&#34;&gt;    2-1. ln 옵션&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;s : 심볼릭링크 생성한다.&lt;/li&gt;
&lt;li&gt;b : 링크파일 생성 시에 대상파일이 이미 존재하면 백업파일을 만든 후에 링크파일을 생성한다.&lt;/li&gt;
&lt;li&gt;d : 디렉토리에 대한 하드링크파일생성을 가능하게 한다.&lt;/li&gt;
&lt;li&gt;f : 대상파일이 존재할 경우에 대상파일을 지우고 링크파일을 생성한다.&lt;/li&gt;
&lt;li&gt;i : 대상파일이 존재할 경우에 대상파일을 지울건인가를 확인요청한다.&lt;/li&gt;
&lt;li&gt;t : 링크파일을 생성할 디렉토리를 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;심볼릭-링크-생성directory&#34; ke-size=&#34;size23&#34;&gt;     2-2. 심볼릭 링크 생성(directory)&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/16/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-10-09%20%EC%98%A4%EC%A0%84%2011.35.53.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] MVCC (Multi-Version Concurrency Control)</title>
      <link>http://localhost:1313/posts/15/</link>
      <pubDate>Fri, 06 Oct 2023 18:53:47 +0000</pubDate>
      <guid>http://localhost:1313/posts/15/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/15/img.png&#34;&gt;
 &lt;/p&gt;
&lt;h2 id=&#34;1-mvcc란&#34;&gt;1.  MVCC란?&lt;/h2&gt;
&lt;p&gt;동시성 제어를 위해 lock을 사용하는 대부분의 다른 데이터베이스 시스템과 달리 Postgres는 다중 버전 모델(multiversion model)을 사용하여 데이터 일관성을 유지한다. 각 트랜잭션이 데이터베이스를 쿼리 하는 동안 데이터의 현재 상태에 관계없이 얼마 전의 데이터 스냅샷을 볼 수 있음을 의미한다. 데이터를 쿼리 하기 위해 트랜잭션을 만들었다면 해당 Transaction은 데이터의 스냅샷을 보고 있는 것이다.&lt;/p&gt;
&lt;p&gt;동일한 행에 서로 다른 트랜잭션이 동시에 업데이트를 시도할 때, 일관성 없는 데이터가 조회되지 않도록 트랜잭션을 보호하여 각 데이터베이스 세션에 대한 트랜잭션 격리를 제공한다. Multiversion과 Lock model의 주요 차이점은 MVCC에서 데이터 read를 위해 획득한 lock과 데이터 쓰기를 위해 획득한 lock이 충돌하지 않는다는 것이다. (따라서 read와 write는 서로 block 하지 않는다.) 이러한 방식을 통해서 Reading 하는 작업에 대해서 Lock을 걸지 않기에 높은 성능을 얻을 수 있게 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 미사용 인덱스(INDEX) 찾기 및 삭제, 성능향상</title>
      <link>http://localhost:1313/posts/14/</link>
      <pubDate>Fri, 06 Oct 2023 16:52:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/14/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/14/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;인덱스index-상세-개념&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스(INDEX) 상세 개념&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/5&#34;&gt;Postgresql 인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;미사용-인덱스&#34; ke-size=&#34;size26&#34;&gt;2. 미사용 인덱스&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;간단히 말해, 인덱스는 지정 컬럼에 매핑된 정보를 별도로 저장하고 있다. 보통 플랜 확인을 통해 효율적으로 인덱스를 추가하여 쿼리 최적화를 진행하게 된다. 오래되고 변경이 잦은 어플리케이션일수록 미사용 인덱스는 늘어나고, 인덱스가 사용되지 않는 경우를 매번 모니터링하여 삭제하는 것은 힘든 일이다. 하지만 불필요 인덱스는 디비 성능저하 및 vacuum 코스트를 증가시키기에, 최적화된 인덱스 생성만큼 최적화된 인덱스 삭제도 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ERROR: text search configuration name \&#34;english\&#34; must be schema-qualified</title>
      <link>http://localhost:1313/posts/13/</link>
      <pubDate>Thu, 05 Oct 2023 13:53:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/13/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/13/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;발생&#34; ke-size=&#34;size26&#34;&gt;1. 발생&lt;/h2&gt;
&lt;p&gt;해당 에러는 Postgresql에서 Full Text Search를 위해 tsvector 컬럼을 업데이트할 때 발생한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 특정 컬럼을 ts_vector로 변경하여 업데이트
UPDATE
    TABLE
SET
    tsvec_words = to_tsvector(&amp;#39;english&amp;#39;,COLUMN);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;원인&#34; ke-size=&#34;size26&#34;&gt;2. 원인&lt;/h2&gt;
&lt;p&gt;해당 컬럼 (혹은 다른 컬럼) 에 테이블 row 업데이트/인서트 시 ts_vector를 자동으로 업데이트하는 trigger가 걸려 있기 때문에 업데이트 간 충돌이 생겨 발생한다.&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; ke-size=&#34;size26&#34;&gt;3. 해결&lt;/h2&gt;
&lt;p&gt;트러거를 삭제 후 데이터 업데이트 후에 트리거를 재설정하면 해결된다.&lt;/p&gt;
&lt;h4 id=&#34;트리거-삭제&#34; ke-size=&#34;size20&#34;&gt;       3-1. 트리거 삭제&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drop trigger TABLE_TRGGER on TABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;트리거-생성&#34; ke-size=&#34;size20&#34;&gt;       3-2. 트리거 생성&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE TRIGGER
  TABLE_TRIGGER
BEFORE INSERT OR UPDATE ON
  TABLE
FOR EACH ROW EXECUTE PROCEDURE
  tsvector_update_trigger(tsvec_words, &amp;#39;english&amp;#39;,COLUMN);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 문자열내 중복 공백, 단어 제거</title>
      <link>http://localhost:1313/posts/12/</link>
      <pubDate>Wed, 04 Oct 2023 19:34:40 +0000</pubDate>
      <guid>http://localhost:1313/posts/12/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/12/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;중복-공백-제거&#34; ke-size=&#34;size26&#34;&gt;1. 중복 공백 제거&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;특정 문자열에 대해서 중복 공백 제거를 하고 싶다면 postgresql 정규식을 사용해서 가능하다.&lt;br&gt;
(공백 외에 단일 문자에 대한 중복제거도 동일한 방법으로 가능하다.)&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select regexp_replace(name, &amp;#39; +&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;g&amp;#39;) from TABLE; -- &amp;#39;g&amp;#39; 옵션을 제거할 경우 최초 건에 대에서만 변경
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;중복-단어-제거&#34; style=&#34;color: #333333; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 중복 단어 제거&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;컬럼 단위 중복제거는 distinct, group by를 통해 쉽게 가능하지만, 컬럼 내 문자열의 중복 단어 제거의 경우 다음과 같다.&lt;br&gt;
(쉼표 기준으로 컬럼을 분리, 중복을 제거한 후 다시 연결)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] BRIN 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/11/</link>
      <pubDate>Mon, 18 Sep 2023 19:03:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/11/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/11/img.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;brin-인덱스란&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;1. BRIN 인덱스란?&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;▪ Block range index의 약자&lt;br&gt;
▪ Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)&lt;br&gt;
▪ 특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Block range는 테이블 내에서 근접한 물리주소를 가진 page 그룹을 의미한다. 각 Block range 에 대해 일부 요약 정보가 인덱스로 저장된다. 예를 들어 상점의 판매 주문을 저장하는 테이블에는 각 주문이 배치된 날짜 열이 있을 수 있으며 대부분의 경우 이전 주문시점에 맞게 순차적으로 주문정보가 들어갈 것이고, ZIP 코드 열을 저장하는 테이블에는 도시에 대한 모든 코드가 자연스럽게 그룹화되어 있을 것이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] GIN인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/10/</link>
      <pubDate>Wed, 13 Sep 2023 19:45:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/10/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;1-gin-인덱스란&#34;&gt;1. GIN 인덱스란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Generalized Inverted Index의 약자이다. 이전 포스트인 full text search에서 사용하는 인덱스의 유형. 기본 구조는 B-tree와 유사하지만, 저장 형태가 다르다.  저장된 요소 자제에 대한 검색이 아닌 인덱스 컬럼의 값을 split 한 token인 lexeme 배열에 대해서 검색을 한다. array_ops, tsvector_ops, jsonb_ops, jsonb_path_ops 등 의 built-in operators를 통해 접근이 가능하다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;2-full-text-search에서의-적용&#34;&gt;2. full text search에서의 적용&lt;/h2&gt;
&lt;h3 id=&#34;2-1-샘플-테이블-및-데이터-생성&#34;&gt;2-1. 샘플 테이블 및 데이터 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create table ts(doc text, doc_tsv tsvector);

insert into ts(doc) values
  (&amp;#39;Can a sheet slitter slit sheets?&amp;#39;), 
  (&amp;#39;How many sheets could a sheet slitter slit?&amp;#39;),
  (&amp;#39;I slit a sheet, a sheet I slit.&amp;#39;),
  (&amp;#39;Upon a slitted sheet I sit.&amp;#39;), 
  (&amp;#39;Whoever slit the sheets is a good sheet slitter.&amp;#39;), 
  (&amp;#39;I am a sheet slitter.&amp;#39;),
  (&amp;#39;I slit sheets.&amp;#39;),
  (&amp;#39;I am the sleekest sheet slitter that ever slit sheets.&amp;#39;),
  (&amp;#39;She slits the sheet she sits on.&amp;#39;);

update ts set doc_tsv = to_tsvector(doc);
create index on ts using gin(doc_tsv);

select doc from ts where doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;조회-결과-및-플랜-확인&#34; ke-size=&#34;size23&#34;&gt;2-2. 조회 결과 및 플랜 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;                             QUERY PLAN                              
---------------------------------------------------------------------
 Bitmap Heap Scan on ts
   Recheck Cond: (doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;::text))
   -&amp;gt;  Bitmap Index Scan on ts_doc_tsv_idx
         Index Cond: (doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;::text))
(4 rows)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] SP-GiST인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/9/</link>
      <pubDate>Wed, 13 Sep 2023 18:11:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/9/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;sp-gist-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. SP-GiST 인덱스란?&lt;/h2&gt;
&lt;p&gt;Space-Partitioned Generalized Search Tree의 약자이다. GiST인덱스와 같이 지리, 좌표, ip주소 데이터 등 복잡한 유형의 데이터를 처리하는 인덱스 유형이다. GiST가 B-tree 인덱스를 통해 보관 데이터를 세분화할 때, 위계적 순서를 따라야 하기에, 이를 보완하기 위해 만들어진 유형으로, GiST로 분리된 공간을 다시 한번 공간 단위로 나누어 관리하는 개념이다. SP-GiST는 겹치지 않는 영역으로 재귀적 분할을 할 수 있는 구조에 적합하다. 기본적으로 SP-GiST는 다양한 데이터 유형, 복잡한 쿼리를 지원하도록 설계되었다.&lt;/p&gt;
&lt;h3 id=&#34;sp-gist-인덱스-생성&#34; style=&#34;color: #000000; text-align: start;&#34; ke-size=&#34;size23&#34;&gt;1-1. SP-GiST 인덱스 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE INDEX idx_spgist_example ON example_table USING spgist (column1);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;장점&#34; ke-size=&#34;size23&#34;&gt;1-2. 장점&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;다양한 종류의 데이터 타입에 사용 가능&lt;/strong&gt; : 기하학, IP, 다른 복잡한 데이터 타입&lt;br&gt;
&lt;strong&gt;복잡한 쿼리에 사용 가능&lt;/strong&gt; : 복잡한 데이터구조, 쿼리에 사용 적합하도록 설계
&lt;strong&gt;빠른 검색 효율&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] GiST인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/8/</link>
      <pubDate>Wed, 13 Sep 2023 16:27:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/8/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;gist-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. GiST 인덱스란?&lt;/h2&gt;
&lt;p&gt;Generalized Search Tree의 약자이며 B-tree와 같은 balanced search tree의 형태이다. B-tree인덱스는 정렬된 채로 비교&amp;amp;일치의 연산에 최적화된 채로 연결되어있다. 하지만 현대의 다양한 데이터 종류 (기하학적, 텍스트문서, 이미지 등)를 연산하는 데는 적합하지 않다.&lt;/p&gt;
&lt;p&gt;GiST 인덱스는 이러한 데이터 타입의 인덱싱을 위해 설계되었다. GiST 인덱스는 각 유형의 데이터를 Balanced tree 형태로 구성하게하고, tree에 접근하는 연산자를 정의해 준다. 각각 leaf node는 table row(TID)와 boolean 형태의 predicate를 가지고 있고 인덱스 데이터(key)는 이 predicate와 부합한다. 그 후는 일반적인 tree search처럼, 루트노드에서 시작하여, 어떤 child node로 진입할지를 결정한다. 그러다가 leaf node를 발견하면, 그 결과들을 반환한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Hash 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/7/</link>
      <pubDate>Wed, 13 Sep 2023 14:28:16 +0000</pubDate>
      <guid>http://localhost:1313/posts/7/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/7/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;hash-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. Hash 인덱스란?&lt;/h2&gt;
&lt;p&gt;해쉬 인덱스의 기본 아이디어는, hash function을 통해 작은 숫자를 데이터와 조합하여 integer 형태의 해쉬값 (최대 2^32 = 4B)을 생성하고 해쉬값을 테이블 행 정보(TID)가 저장될 배열의 인덱스 값으로 사용하는 것이다. 이 배열의 각 요소를 해시 테이블 버킷(hash table bucket)이라고 한다. 데이터 조회 시, hash function을 통해 생성된 key가 포함된 bucket을 찾고, 그 bucket만 확인하면 실제 데이터의 위치를 바로 확인할 수 있다. 데이터의 크기에 상관없이 인덱스의 크기가 작고 검색이 빠르다. 1개의 데이터를 조회하는 시간은 O(1)로 빠르지만 해쉬 테이블 내의 값들은 정렬이 되어있지 않기 때문에 범위 비교나 부정형 비교가 포함된 조건에서는 인덱스를 사용할 수 없다. Hash function이 버킷 단위로 소스 값을 더 균일하게 분배할수록 효율이 좋다. &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] B-tree 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/6/</link>
      <pubDate>Tue, 12 Sep 2023 19:12:12 +0000</pubDate>
      <guid>http://localhost:1313/posts/6/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.&lt;/p&gt;
&lt;p&gt;그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;b-tree-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. B-tree 인덱스란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조&lt;br&gt;
▪ B-tree는 Binary 가 아닌 Balanced의 약자&lt;br&gt;
▪ 컬럼의 기존 데이터를 변형하지 않음&lt;br&gt;
▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;b-tree-인덱스의-원리&#34; ke-size=&#34;size26&#34;&gt;2. B-tree 인덱스의 원리&lt;/h2&gt;
&lt;h3 id=&#34;b-tree-인덱스의-자료구조-형태&#34; ke-size=&#34;size23&#34;&gt;▪ B-tree 인덱스의 자료구조 형태&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/6/img.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL]  인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법</title>
      <link>http://localhost:1313/posts/5/</link>
      <pubDate>Tue, 12 Sep 2023 17:50:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/5/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/5/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;인덱스-컨트롤&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스 컨트롤&lt;/h2&gt;
&lt;h3 id=&#34;인덱스-조회&#34; ke-size=&#34;size23&#34;&gt;1-1. 인덱스 조회 &lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM pg_indexes WHERE tablename = &amp;#39;{테이블명}&amp;#39;; -- 테이블명에 &amp;#39;&amp;#39; 필요
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-생성&#34; ke-size=&#34;size23&#34;&gt;1-2. 인덱스 생성 &lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 단일 인덱스
CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명});

-- 결합 인덱스
CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명1}, {컬럼명2});

-- 유니크 인덱스
CREATE UNIQUE INDEX {인덱스명} ON table_name ({컬럼명});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-삭제&#34; ke-size=&#34;size23&#34;&gt;1-3. 인덱스 삭제&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DROP INDEX {인덱스명};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-사용-빈도-확인&#34; ke-size=&#34;size23&#34;&gt;1-4. 인덱스 사용 빈도 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT schemaname, relname, indexrelname, idx_scan as idx_scan_cnt FROM pg_stat_user_indexes ORDER BY idx_scan;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-손상-시-재인덱싱&#34; ke-size=&#34;size23&#34;&gt;1-5. 인덱스 손상 시 재인덱싱&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;REINDEX INDEX {인덱스명}

REINDEX TABLE {테이블명}

REINDEX DATABASE {데이터베이스명}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>Postgresql Lock이란? (조회 및 kill, Dead lock)</title>
      <link>http://localhost:1313/posts/4/</link>
      <pubDate>Mon, 11 Sep 2023 18:02:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/4/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/4/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-lock-확인방법&#34;&gt;1. Lock 확인방법&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT PSAT.RELNAME,
       PL.LOCKTYPE,
       PL.PID,
       PL.MODE,
       PL.GRANTED
FROM PG_LOCKS PL,
     PG_STAT_ALL_TABLES PSAT
WHERE PL.RELATION = PSAT.RELID
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-lock-kill-방법&#34;&gt;2. Lock Kill 방법&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT PG_CANCEL_BACKEND([PID])

SELECT PG_TERMINATE_BACKEND([PID])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lock 리스트에서 조회된 PID를 넣고 cancel, 혹은 terminate 시켜주면 된다. cancel은 해당 프로세스만을, terminate는 상위 프로세스들까지 종료시킨다.&lt;/p&gt;
&lt;h2 id=&#34;3-lock-이란-postgresql&#34;&gt;3. Lock 이란? (Postgresql)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Postgresql은 다양한 종류의 lock 기능을 제공한다. 애플리케이션 단에서 제어도 가능하지만, 대부분 기본적인 SQL 실행 시 적절한 락을 자동실행시켜 관련 테이블의 무결성 유지한다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;테이블-단위-lock&#34; ke-size=&#34;size23&#34;&gt;&lt;strong&gt;3-1.  테이블 단위 Lock&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다음 락 들은 모두 테이블 단위의 락이며, 명칭과 상관없이 테이블 단위로 적용된다.&lt;/li&gt;
&lt;li&gt;서로 다른 락이 충돌했을때의 상관관계에 의해 대기 상태로 돌입한다. (테이블 단위 락은 유형에 따라 서로 충돌여부가 다름)&lt;/li&gt;
&lt;li&gt;한 테이블에는 2개의 트랜잭션이 동시에 락 적용 될 수 없다. (서로 충돌되지 않는 락은 여러 트랜잭션에 동시에 적용될 수 있다.)&lt;/li&gt;
&lt;li&gt;특정 락은 self-conflicting 될 수 있다.
(ex. access exclusive 락은 중첩불가 access share 락은 여러 트랜잭션에서 다중으로 적용될 수 있다.)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/4/img_1.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Trigger, Procedure, Function (history 관리하기)</title>
      <link>http://localhost:1313/posts/3/</link>
      <pubDate>Fri, 08 Sep 2023 13:37:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/3/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/3/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-가장보편적으로쓰이는간단한history-저장트리거생성예제&#34;&gt;* 가장 보편적으로 쓰이는 간단한 history 저장 트리거 생성 예제&lt;/h2&gt;
&lt;p&gt;특정 테이블에 insert, update가 수행될 경우 무조건 내역에 “insert”를 하는 간단한 트리거 생성 예제이다.&lt;/p&gt;
&lt;h4 id=&#34;1-1-함수를-실행할-트리거-생성&#34;&gt;1-1. 함수를 실행할 트리거 생성&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create trigger trigger_save_history
after insert or update on A
for each row
execute procedure trigger_insert();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;1-2-실제-insert문이-실행되는-함수&#34;&gt;1-2. 실제 insert문이 실행되는 함수 &lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE OR REPLACE FUNCTION trigger_insert()
returns trigger
AS $$
DECLARE
BEGIN
    insert into B
        (id, values, date)
    values
        (new.id, new.values, current_timestamp());
    return NULL;
END; $$
LANGUAGE &amp;#39;plpgsql&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;하지만 특정 table에 insert, delete, update에 따라 서로 다른 테이블에 이력을 보관하거나, 기존 이력을 업데이트하는 등&lt;/p&gt;</description>
    </item>
    <item>
      <title>Full Text Search를 활용한 데이터베이스 성능 향상</title>
      <link>http://localhost:1313/posts/2/</link>
      <pubDate>Thu, 07 Sep 2023 17:25:06 +0000</pubDate>
      <guid>http://localhost:1313/posts/2/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/2/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;문제상황&#34; ke-size=&#34;size26&#34;&gt;1. 문제상황&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색&lt;br&gt;
(Ex. Susan loves hiking 을 &amp;ldquo;love hike&amp;rdquo; 이라는 키워드로 검색하고자 함)&lt;/li&gt;
&lt;li&gt;RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;full-text-search전문검색란&#34; ke-size=&#34;size26&#34;&gt;2. Full Text Search(전문검색)란?&lt;/h2&gt;
&lt;p&gt;게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>방명록</title>
      <link>http://localhost:1313/guestbook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/guestbook/</guid>
      <description></description>
    </item>
  </channel>
</rss>
