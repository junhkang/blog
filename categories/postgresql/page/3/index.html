<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Postgresql | Jun Kang's Blog</title>
<meta name=keywords content><meta name=description content="AI와 빅데이터로 건설업계의 디지털 혁신을 이끄는 (주)산군의 Jun Kang입니다. 대규모 데이터 처리, DB 최적화, 확장 가능한 시스템 구축에 관심이 많으며, 개발팀의 건강하고 지속 가능한 성장 문화를 문화를 만들어가고 있습니다."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/categories/postgresql/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://junhkang.com/categories/postgresql/index.xml><link rel=alternate hreflang=en href=https://junhkang.com/categories/postgresql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/categories/postgresql/"><meta property="og:title" content="Postgresql | Jun Kang's Blog"><meta property="og:description" content="AI와 빅데이터로 건설업계의 디지털 혁신을 이끄는 (주)산군의 Jun Kang입니다. 대규모 데이터 처리, DB 최적화, 확장 가능한 시스템 구축에 관심이 많으며, 개발팀의 건강하고 지속 가능한 성장 문화를 문화를 만들어가고 있습니다."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/categories/postgresql/"><meta property="twitter:title" content="Postgresql | Jun Kang's Blog"><meta property="twitter:description" content="AI와 빅데이터로 건설업계의 디지털 혁신을 이끄는 (주)산군의 Jun Kang입니다. 대규모 데이터 처리, DB 최적화, 확장 가능한 시스템 구축에 관심이 많으며, 개발팀의 건강하고 지속 가능한 성장 문화를 문화를 만들어가고 있습니다."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9413249746505723" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/categories/postgresql/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="Postgresql"><meta property="og:description" content="AI와 빅데이터로 건설업계의 디지털 혁신을 이끄는 (주)산군의 Jun Kang입니다. 대규모 데이터 처리, DB 최적화, 확장 가능한 시스템 구축에 관심이 많으며, 개발팀의 건강하고 지속 가능한 성장 문화를 문화를 만들어가고 있습니다."><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Postgresql"><meta name=twitter:description content="AI와 빅데이터로 건설업계의 디지털 혁신을 이끄는 (주)산군의 Jun Kang입니다. 대규모 데이터 처리, DB 최적화, 확장 가능한 시스템 구축에 관심이 많으며, 개발팀의 건강하고 지속 가능한 성장 문화를 문화를 만들어가고 있습니다."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://junhkang.com/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Postgresql</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] TOAST (The Oversized-Attribute Storage Technique)의 개념, PostgreSQL의 대용량 속성 저장 기법</h2></header><div class=entry-content><p>1. TOAST (The Oversized-Attribute Storage Technique)란? 데이터베이스의 대용량 속성을 효율적으로 저장하고 관리하기 위한 기법으로, 데이터를 효율적으로 처리하고, 저장공간을 최적화하며 데이터 접근시간을 개선하기 위해 사용된다. PostgreSQL의 각 page영역은 일반적으로 8kb의 고정된 크기로 되어있고 각 tuple이 여러 페이지에 나뉘어 존재할 수 없다. (매우 큰 값을 바로 저장할 수 없다.) 이 한계를 극복하기 위해서, 큰 필드 값은 압축되어 저장되거나 여러 개의 물리적 ROWS로 분할되어 저장된다. 이 과정은 보통 개발자가 별도의 처리로직을 구현할 필요 없이 데이터베이스 백앤드에서 자동으로 이루어진다. 이 기법을 TOAST (The Oversized-Attribute Storage Technique)라고 하며 PostgreSQL에서 큰 데이터 값을 메모리 내에서 효율적으로 처리하는 데에 사용된다.
...</p></div><footer class=entry-footer><span title='2024-03-23 21:01:58 +0000 UTC'>March 23, 2024</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] TOAST (The Oversized-Attribute Storage Technique)의 개념, PostgreSQL의 대용량 속성 저장 기법" href=https://junhkang.com/posts/75/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] DISK(디스크) 사용량 모니터링</h2></header><div class=entry-content><p>1. Disk 영역 PostgreSQL의 저장 영역은 크게 Heap, Index, Toast 3개로 나뉜다. 각 테이블의 대부분의 데이터를 메인 heap 영역에 저장한고, 테이블 칼럼 중 매우 큰 데이터를 받을 수 있는 칼럼은 TOAST 영역에 별도 저장한다. TOAST 테이블에는 실제 데이터를 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. TOAST 테이블의 유효한 인덱스는 1개뿐이고, 기준 테이블에는 더 많은 인덱스가 존재할 수 있다. 테이블과 인덱스는 각각의 디스크파일에 저장 되며 각 파일이 1G가 넘으면 별도 파일로 분리된다.
...</p></div><footer class=entry-footer><span title='2024-03-19 16:31:20 +0000 UTC'>March 19, 2024</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] DISK(디스크) 사용량 모니터링" href=https://junhkang.com/posts/74/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] PostgreSQL의 물리적 한계치</h2></header><div class=entry-content><p>1. PostreSQL의 물리적 한계치 물론 사용 가능한 disk 용량, 성능 이슈 등 실직적인 제한이 먼저 적용되겠지만, 모든 자원이 충분하다고 가정할 때 물리적인 limit이다.
항목 최대치 데이터베이스 사이즈 무제한 데이터베이스 수량 4,294,950,911 데이터베이스 당 Relations(테이블, 뷰, 인덱스 등의 테이블 객체)수량 1,431,650,303 Relations 사이즈 32TB 테이블 당 ROW 수량 4,294,967,295 pages영역의 크기에 해당하는 ROW 테이블 당 COL 수량 1,600 결과셋의 COL 수량 1,664 COL 사이즈 1GB 테이블 당 인덱스 수량 무제한 인덱스 당 컬럼 32 파티션 키 32 식별자 키 (ex, 테이블, ROW, COL 등의 명칭) 63 bytes function의 매개변수 100 쿼리파라미터 65,535 테이블당 ROW 수량은 4,294,967,295개의 pages 영역에 저장 가능한 ROWS로 제한되어 있는데, 4,294,967,295는 2^32 - 1로 32비트 시스템에서 사용가능한 최대 정수이다. 데이터베이스에서 최대로 관리할 수 있는 pages의 수며, 각 페이지에는 여러 튜플이 저장될 수 있다. 테이블 당 인덱스의 수량은 이론상은 “무제한"이제만, 실제로는 데이터베이스가 관리할 수 있는 최대 Relations (테이블, 뷰, 인덱스 등의 테이블 객체)에 의해 제한된다. 위 표의 인덱스 당 칼럼 수, 파티션 키 수량, 식별자 키, 함수 매개변수 최대 수량은 기본값이며 설정값을 변경하여 증가시킬 수 있다. 테이블 당 최대 칼럼 수는 1600개이지만, 저장되는 튜플이 8192바이트의 힙 페이지에 fit 해야 한다는 조건 때문에 더 줄어들 수 있다. 예를 들어 튜플 헤더를 제외하고, 1600개의 int칼럼 투플 - 6400 bytes로 힙페이지에 정상 저장 가능 (6400 &lt; 8192) 1600의 bigint칼럼 투플 - 12800 bytes로 heap page를 초과 (12800 &lt; 8192) text, varchar, char같이 길이 변경이 가능한 필드의 경우 값이 크면 TOAST 테이블 영역이라 불리는 주 저장공간 외부영역에 값을 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. 테이블에서 삭제된 칼럼들도 최대 칼럼 개수에 포함된다. 삭제된 칼럼에 대해 새로 생성된 ROW도 내부적으로는 null 표시되지만, 추적을 위해 여전히 공간을 차지하여 최대 개수에 영향을 준다. 2. 결론 운영 단계에서 1억 개 이상의 테이블을 생성하거나 1000개가 넘는 칼럼의 테이블을 생성하는 일은 없을 것이고, 이러한 물리적 제약보다 자원의 한계 (용량 및 성능이슈)를 먼저 만날 것이기에 정확한 수치를 정확히 외울 필요는 없겠지만, 삭제된 칼럼들과 그 이후 생성된 ROW들이 내부적으로는 추적을 위해 해당 컬럼을 NULL로 저장하며, 이 과정에서 사용되는 NULL비트맵이 공간을 차지하기에 최대 카운트에 영향을 준다는 것 운영 시에 유의해야 할 내용이다.
...</p></div><footer class=entry-footer><span title='2024-03-18 15:00:18 +0000 UTC'>March 18, 2024</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] PostgreSQL의 물리적 한계치" href=https://junhkang.com/posts/72/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] Planner, Optimizer (플래너, 옵티마이저)란? Planner, Optimizer (플래너, 옵티마이저)의 개념과 작동방식</h2></header><div class=entry-content><p>1. Planner / Optimizer (플래너 / 옵티마이저) 란? Planner / Optimizer는 쿼리의 최적화된 실행 계획을 만들어낸다. 한 개의 SQL 쿼리도 결과는 같지만, 다양한 방법과 순서로 실행될 수 있다. Planner / Optimizer (이후는 Planner로 명칭)는 실행 가능한 각각의 플랜을 검사하여 궁극적으로 가장 빠르게 실행 "기대"되는 플랜을 선택한다. 1-1. Genetic Query Optimize 가끔 쿼리의 실행 가능한 방식들을 검사하는 데만도 굉장히 큰 시간과 메모리가 소모된다. (특히, 많은 양의 join을 포함한 쿼리를 실행할 때 발생) 합리적인 쿼리 플랜(최고일 필요는 없다)을 합리적인 시간 내에 찾기 위해, PostgreSQL은 join수량이 임계치를 초과하면 Genetic Query Optimizer를 사용한다. Genetic Query Optimize는 최적의 조인 순서를 찾기 위해, 일부 조인 순서를 시도 후 적합성 함수를 통해 조인 순서의 적합성을 평가하여 최적의 plan을 선택한다. 메모리와 시간을 절약할 수 있지만, 항상 최선의 답을 찾는 것은 아니기에 효율성을 보장하지 못한다. ...</p></div><footer class=entry-footer><span title='2024-03-14 18:51:34 +0000 UTC'>March 14, 2024</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] Planner, Optimizer (플래너, 옵티마이저)란? Planner, Optimizer (플래너, 옵티마이저)의 개념과 작동방식" href=https://junhkang.com/posts/71/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용</h2></header><div class=entry-content><p>1. Index-Only Scans PostgreSQL의 모든 인덱스는 "보조(Secondary)" 인덱스이다. 각 인덱스는 테이블의 메인 데이터 영역(테이블의 heap 영역)과 분리되어서 저장된다. 그렇기 때문에 일반적인 인덱스 스캔에서 각 ROW를 찾기 위해서는, index와 heap 영역 모두에 접근하여 데이터를 탐색해야 한다. 보통 WHERE 절 조건에 부합하는 데이터들은
인덱스 영역 - 서로 가까이 존재하여 정렬된 순서로 빠르게 접근할 수 있다. (인덱스 테이블은 정렬된 상태로 생성) heap 영역 - 특별한 규칙 없이 어디에서든 분포할 수 있기에 heap 영역을 스캔할 때는 무작위로 접근하게 되어 속도가 느리다. 이 퍼포먼스 문제를 해결하기 위해 PostgreSQL은 힙 영역에 대한 접근 없이 인덱스 내에서만 데이터를 조회하는 Index-only 스캔을 지원한다. 기본 개념은 말 그대로 heap 영역의 참조 없이 index 항목에서 바로 값을 반환하는 것으로 매우 효율적으로 보이지만 몇 가지 제한사항이 있다.
...</p></div><footer class=entry-footer><span title='2024-03-13 18:52:22 +0000 UTC'>March 13, 2024</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용" href=https://junhkang.com/posts/70/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://junhkang.com/categories/postgresql/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://junhkang.com/categories/postgresql/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>