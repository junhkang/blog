<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라 | Jun Kang's Blog</title>
<meta name=keywords content="Effective"><meta name=description content="

싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다.
 
싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다."><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/posts/55/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/55/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="http://localhost:1313/posts/55/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라"><meta property="og:description" content=" 싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다. 싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-24T13:04:41+00:00"><meta property="article:modified_time" content="2024-01-24T13:04:41+00:00"><meta property="article:tag" content="Effective"><meta name=twitter:card content="summary"><meta name=twitter:title content="[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라"><meta name=twitter:description content="

싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다.
 
싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라","item":"http://localhost:1313/posts/55/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라","name":"[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라","description":" 싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다. 싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.\n","keywords":["Effective"],"articleBody":" 싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다. 싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.\n1. public static final 필드 방식의 싱글턴 public class ElvisField { public static final ElvisField INSTANCE = new ElvisField(); private ElvisField() {} public void leaveTheBuilding() { System.out.println(\"Whoa baby, I'm outta here!\"); } } Private 생성자는 public static final 필드인 elvis.instance를 초기화할 때 딱 한 번만 호출된다. public, protected 생성자가 없기에 초기화 시 생성된 인스턴스가 전체 시스템에서 유일함이 보장된다. 단, 권한이 있는 클라이언트의 경우 리플렉션 API 인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출가능하다, 이 경우를 방지하기 위해서는 생성자를 수정하여 두 번째 객체가 되려 할 때 Exception을 던지면 된다. 리플렉션 API를 통해 새로운 객체가 생성되는 것을 확인해 보면\npublic static void main(String[] args) { ElvisField ElvisField1 = ElvisField.INSTANCE; ElvisField ElvisField2 = ElvisField.INSTANCE; System.out.println(ElvisField1.hashCode()); System.out.println(ElvisField2.hashCode()); try { Constructor constructor = ElvisField.class.getDeclaredConstructor(); constructor.setAccessible(true); ElvisField ElvisField3 = constructor.newInstance(); System.out.println(ElvisField3.hashCode()); } catch (Exception e) { throw new RuntimeException(e); } } 821270929 821270929 1160460865 기존 ElvisField1, ElvisField2에서는 동일 인스턴스를 반환하지만, 리플렉션 API를 통해 생성하면 새로운 객체가 생성이 된다. 이 경우, 다음과 같이 인스턴스가 이미 존재하는지를 체크하여 예외처리를 하면 싱글턴에 위배되는 상황을 방지할 수 있다.\npublic class ElvisField { public static final ElvisField INSTANCE = new ElvisField(); private ElvisField() { // private 생성자는 ElvisField.INSTANCE를 초기화할 때 딱 한번만 호출된다. if (INSTANCE != null) { throw new IllegalStateException(\"Already initialized\"); } } public void leaveTheBuilding() { System.out.println(\"Whoa baby, I'm outta here!\"); } } 1-1. 장점 - 해당 클래스가 싱글턴임이 API에 명백히 드러남\\\npublic static 필드가 final이니 절대 다른 객체를 참조 불가 코드가 훨씬 간결 2. 정적 팩터리 방식의 싱글턴 두 번째 방법은 정적 팩터리 메서드를 public static 멤버로 제공하는 방식이다. 책의 예제를 먼저 살펴보면\npublic class EvlisStaticFactory { private static final EvlisStaticFactory INSTANCE = new EvlisStaticFactory(); private EvlisStaticFactory() {} public static EvlisStaticFactory getInstance() { return INSTANCE; } public void leaveTheBuilding() { System.out.println(\"Whoa baby, I'm outta here!\"); } } Elvis.getInstance는 항상 같은 객체를 참조하기에 애플리케이션 내에서 유일함을 보장한다. (1번 방식의 리플렉션 API의 예외는 동일하게 적용된다.)\n2-1. 장점 - API를 바꾸지 않고도 싱글턴이 아니게 변경이 가능하다는 유연성\\\n유일한 인스턴스를 반환하는 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 반환하게 수정도 가능 정적 팩터리를 제네릭 싱글턴 팩터리로 생성 가능 정적 팩터리메서드 참조를 공급자로 사용 가능 ex) Elvis::getInstance를 Supplier 로 사용 가능 * 이러한 장점이 필요 없다면 public 필드 방식이 더 좋다. 위의 두 방식 중 하나로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현하는 및 선언하는 것으로는 부족하다.\n직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 생성되는 것을 방지하기 위해 readResolve() 메서드를 제공해야 한다.\nprivate Object readResolve() { return INSTANCE; } 3. 열거 타입 방식의 싱글턴 - 바람직한 방법 이펙티브 자바에서 말하는 싱글턴을 만드는 가장 바람직한 세 번째 방법은 원소가 하나인 열거 타입을 선언하는 것이다.\npublic enum ElvisEnum { INSTANCE; public void leaveTheBuilding() { System.out.println(\"Whoa baby, I'm outta here!\"); } } public 방식과 비슷하지만 훨씬 간결하다. 바로 직렬화가 가능하며 복잡한 직렬화 상황이나 리플렉션 공격에도 인스턴스가 중복되어 생성되는 경우를 완벽하게 막아준다. 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다. (만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용불가) 책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능\nhttps://github.com/junhkang/effective-java-summary ","wordCount":"555","inLanguage":"en","datePublished":"2024-01-24T13:04:41Z","dateModified":"2024-01-24T13:04:41Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/55/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보장하라</h1><div class=post-meta><span title='2024-01-24 13:04:41 +0000 UTC'>January 24, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/55/img.png></p><p>싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스로, 함수와 같은 무상태 (stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트, 혹은 익숙한 스프링 빈이 대표적인 싱글턴의 예로 들 수 있다. 클래스를 싱글턴으로 만들 경우, (타입을 인터페이스로 정의한 후 인터페이스를 구현해서 만든 싱글턴이 아니라면) 싱글턴 인스턴스를 Mock으로 대체할 수 없기에 테스트가 어려울 수 있다.
 </p><p>싱글턴을 만드는 보편적인 두가지 방식이 있는데, 두 방식 모두생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.</p><h2 id=public-static-final-필드-방식의-싱글턴 ke-size=size26>1. public static final 필드 방식의 싱글턴<a hidden class=anchor aria-hidden=true href=#public-static-final-필드-방식의-싱글턴>#</a></h2><pre tabindex=0><code>public class ElvisField {
    public static final ElvisField INSTANCE = new ElvisField();
    private ElvisField() {}
    public void leaveTheBuilding() {
        System.out.println(&#34;Whoa baby, I&#39;m outta here!&#34;);
    }
}
</code></pre><p> </p><p>Private 생성자는 public static final 필드인 elvis.instance를 초기화할 때 딱 한 번만 호출된다. public, protected 생성자가 없기에 초기화 시 생성된 인스턴스가 전체 시스템에서 유일함이 보장된다. 단, 권한이 있는 클라이언트의 경우 리플렉션 API 인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출가능하다, 이 경우를 방지하기 위해서는 생성자를 수정하여 두 번째 객체가 되려 할 때 Exception을 던지면 된다. 리플렉션 API를 통해 새로운 객체가 생성되는 것을 확인해 보면</p><pre tabindex=0><code>public static void main(String[] args) {
        ElvisField ElvisField1 = ElvisField.INSTANCE;
        ElvisField ElvisField2 = ElvisField.INSTANCE;
        System.out.println(ElvisField1.hashCode());
        System.out.println(ElvisField2.hashCode());
        try {
            Constructor&lt;ElvisField&gt; constructor = ElvisField.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            ElvisField ElvisField3 = constructor.newInstance();
            System.out.println(ElvisField3.hashCode());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
</code></pre><pre tabindex=0><code>821270929
821270929
1160460865
</code></pre><p>기존 ElvisField1, ElvisField2에서는 동일 인스턴스를 반환하지만, 리플렉션 API를 통해 생성하면 새로운 객체가 생성이 된다. 이 경우, 다음과 같이 인스턴스가 이미 존재하는지를 체크하여 예외처리를 하면 싱글턴에 위배되는 상황을 방지할 수 있다.</p><pre tabindex=0><code>public class ElvisField {
    public static final ElvisField INSTANCE = new ElvisField();
    private ElvisField() {
        // private 생성자는 ElvisField.INSTANCE를 초기화할 때 딱 한번만 호출된다.
        if (INSTANCE != null) {
            throw new IllegalStateException(&#34;Already initialized&#34;);
        }
        
    }
    public void leaveTheBuilding() {
        System.out.println(&#34;Whoa baby, I&#39;m outta here!&#34;);
    }
}
</code></pre><h4 id=장점 ke-size=size20>1-1. 장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><blockquote><p>- 해당 클래스가 싱글턴임이 API에 명백히 드러남\</p><ul><li>public static 필드가 final이니 절대 다른 객체를 참조 불가</li><li>코드가 훨씬 간결</li></ul></blockquote><h2 id=정적-팩터리-방식의-싱글턴 ke-size=size26>2. 정적 팩터리 방식의 싱글턴<a hidden class=anchor aria-hidden=true href=#정적-팩터리-방식의-싱글턴>#</a></h2><p>두 번째 방법은 정적 팩터리 메서드를 public static 멤버로 제공하는 방식이다. 책의 예제를 먼저 살펴보면</p><pre tabindex=0><code>public class EvlisStaticFactory {
    private static final EvlisStaticFactory INSTANCE = new EvlisStaticFactory();
    private EvlisStaticFactory() {}
    public static EvlisStaticFactory getInstance() {
        return INSTANCE;
    }
    public void leaveTheBuilding() {
        System.out.println(&#34;Whoa baby, I&#39;m outta here!&#34;);
    }
}
</code></pre><p>Elvis.getInstance는 항상 같은 객체를 참조하기에 애플리케이션 내에서 유일함을 보장한다. (1번 방식의 리플렉션 API의 예외는 동일하게 적용된다.)</p><h4 id=장점-1 ke-size=size20>2-1. 장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h4><blockquote><p>- API를 바꾸지 않고도 싱글턴이 아니게 변경이 가능하다는 유연성\</p><ul><li>유일한 인스턴스를 반환하는 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 반환하게 수정도 가능</li><li>정적 팩터리를 제네릭 싱글턴 팩터리로 생성 가능</li><li>정적 팩터리메서드 참조를 공급자로 사용 가능 ex) Elvis::getInstance를 Supplier &lt;Elvis>로 사용 가능
* 이러한 장점이 필요 없다면 public 필드 방식이 더 좋다.
 </li></ul></blockquote><p>위의 두 방식 중 하나로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현하는 및 선언하는 것으로는 부족하다.</p><p>직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 생성되는 것을 방지하기 위해 readResolve() 메서드를 제공해야 한다.</p><pre tabindex=0><code>private Object readResolve() {
        return INSTANCE;
    }
</code></pre><h2 id=열거-타입-방식의-싱글턴---바람직한-방법 ke-size=size26>3. 열거 타입 방식의 싱글턴 - 바람직한 방법<a hidden class=anchor aria-hidden=true href=#열거-타입-방식의-싱글턴---바람직한-방법>#</a></h2><p>이펙티브 자바에서 말하는 싱글턴을 만드는 가장 바람직한 세 번째 방법은 원소가 하나인 열거 타입을 선언하는 것이다.</p><pre tabindex=0><code>public enum ElvisEnum {
    INSTANCE;
    public void leaveTheBuilding() {
        System.out.println(&#34;Whoa baby, I&#39;m outta here!&#34;);
    }
}
</code></pre><p>public 방식과 비슷하지만 훨씬 간결하다. 바로 직렬화가 가능하며 복잡한 직렬화 상황이나 리플렉션 공격에도 인스턴스가 중복되어 생성되는 경우를 완벽하게 막아준다. 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.  (만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용불가)
 </p><p> </p><p> </p><p>책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능</p><p><a href=https://github.com/junhkang/effective-java-summary>https://github.com/junhkang/effective-java-summary</a>
 </p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/effective/>Effective</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>