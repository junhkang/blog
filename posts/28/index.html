<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란? | Jun Kang's Blog</title>
<meta name=keywords content="OS,운영체제,스레드,멀티스레드"><meta name=description content="

두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습
1. Thread란?
CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 
스레드의 종류
스레드는 지원 주체에 따라 2가지로 나눌 수 있다.
User Threads

유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드
라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.
동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.
여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)
스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다

Kernel Threads"><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/28/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/28/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/28/"><meta property="og:title" content="[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란? | Jun Kang's Blog"><meta property="og:description" content="

두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습
1. Thread란?
CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 
스레드의 종류
스레드는 지원 주체에 따라 2가지로 나눌 수 있다.
User Threads

유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드
라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.
동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.
여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)
스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다

Kernel Threads"><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/28/"><meta property="twitter:title" content="[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란? | Jun Kang's Blog"><meta property="twitter:description" content="

두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습
1. Thread란?
CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 
스레드의 종류
스레드는 지원 주체에 따라 2가지로 나눌 수 있다.
User Threads

유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드
라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.
동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.
여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)
스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다

Kernel Threads"><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="https://junhkang.com/posts/28/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?"><meta property="og:description" content=" 두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습
1. Thread란? CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 스레드의 종류 스레드는 지원 주체에 따라 2가지로 나눌 수 있다.
User Threads
유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드 라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다. 동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다. 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문) 스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다 Kernel Threads"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-17T14:01:18+00:00"><meta property="article:modified_time" content="2023-10-17T14:01:18+00:00"><meta property="article:tag" content="OS"><meta property="article:tag" content="운영체제"><meta property="article:tag" content="스레드"><meta property="article:tag" content="멀티스레드"><meta name=twitter:card content="summary"><meta name=twitter:title content="[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?"><meta name=twitter:description content="

두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습
1. Thread란?
CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 
스레드의 종류
스레드는 지원 주체에 따라 2가지로 나눌 수 있다.
User Threads

유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드
라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.
동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.
여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)
스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다

Kernel Threads"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?","item":"https://junhkang.com/posts/28/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?","name":"[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?","description":" 두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습\n1. Thread란? CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 스레드의 종류 스레드는 지원 주체에 따라 2가지로 나눌 수 있다.\nUser Threads\n유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드 라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다. 동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다. 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문) 스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다 Kernel Threads\n","keywords":["OS","운영체제","스레드","멀티스레드"],"articleBody":" 두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습\n1. Thread란? CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. 스레드의 종류 스레드는 지원 주체에 따라 2가지로 나눌 수 있다.\nUser Threads\n유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드 라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다. 동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다. 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문) 스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다 Kernel Threads\n커널 스레드는 커널이 지원하는 스레드 커널 스레드를 사용하면 안정적이지만 유저모드에서 커널모드로 계속 바꿔줘야 하기에 성능이 저하된다. 반대로 유저 스레드를 사용하면 안정성은 떨어지지만 성능이 저하되지는 않는다. 스레드가 시스템 호출 등으로 중단되어도 다른 스레드를 중단시키지 않고 계속 실행시킨다. Thread Group (스레드 그룹) Thread Group (스레드 그룹)이란 관련 있는 스레드를 그룹으로 묶어 다루는 장치이다. 쓰레드 그룹은 다른 스레드그룹에 포함될 수 있으며, 트리형태로 연결된다. 스레드는는 자신이 포함된 스레드 그룹이나 하위 그룹에는 접근가능 하지만, 다른 그룹에는 접근할 수 없다.\nDeamon Thread(데몬 스레드) 다른 일반 스레드의 작업을 돕는 보조 쓰레드 일반 스레드가 모두 종료되면 자동으로 종료 일정시간마도 자동수행되는 저장/ 화면 갱신등에 사용 Thread Pools 스레드를 요청할 때마다 매번 새로 생성하고, 수행하고, 지우고 반복하면 성능저하로 이어진다.\n그래서 미리 스레드 풀에 여러 개의 스레드를 만들어두고 요청이 오면 스레드풀에서 스레드를 할당해 주는 방법을 사용한다. 2. 멀티스레드란? 한 번에 하나의 작업만 수행하면 싱글 스레드, 하나의 프로세스가 둘 이상의 스레드가 동시에 작업을 수행하면 멀티스레드라 한다.\n멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다. 멀티스레드의 장점 두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.\n프로세스사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생 (스레드 전환 시에도 일어나지만 속도가 더 빠르다) 응답성 : 대화형 프로그램을 멀티스레드화 하면 일부 스레드가 중단되거나 긴 작업을 수행하더라도 [ 다른 스레드가 별도의 작업을 할 수 있어 응답성이 좋다]{style=“color: #333333; text-align: start;”}. 자원공유 : 프로세스 내의 자원과 메모리를 공유함으로 시스템 자원의 낭비가 적다. 또한 같은 주소 공간 내에 여러 개의 활동성 스레드를 가질 수 있다는 장점이 있다.\n경제성 : 메모리와 자원할당은 많인 비용이 소모된다. 스레드는 프로세스 내 자원을 공유하기에 스레드생성과 Context Switching을 하는 것이 효율적이다.\n멀티프로세서 활용 : 각각의 스레드가 다른 프로세스에서 병렬로 수행 가능하다. 단일 쓰레드 프로세스는 CPU가 많아도 1개의 CPU에서만 실행되지만, 다중 스레드화 하면 다중 CPU에서 병렬성이 증간된다.\n프로세스와 비교 두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.\n스레드, 프로세스 사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생하나 스레드의 Context Switching의 속도가 더 빨라서 효율적이다.\n멀티스레드의 단점 캐시, 변환 생인 버퍼(TLB) 등의 하드웨어 리소스를 공유할 때 서로 간섭할 수 있다. Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하되어 단순 계산은 싱글 스레드 보다 실행시간이 개선되지 않고 오히려 지연될 수 있다. 멀티 쓰레딩의 하드웨어 지원을 위해 애플리케이션, 운영체제 모두에 최적화 변경이 필요하다. 각 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다. 예를 들어 스레드 1, 스레드 2로 다음 작업을 수행할 때,\n공유되는 변수 i의 값을 레지스터에 저장 레지스터의 값을 1 증가 변수 i에 그 값을 저장 쓰레드 동작 i 스레드 1의 레지스터 스레드 2의 레지스터 스레드 1 i의 값을 레지스터에 저장 0 0 스레드 1 레지스터 값을 1 증가 0 1 스레드 1 i에 값 저장 1 1 스레드 2 i의 값을 레지스터에 저장 1 1 1 스레드 2 레지스터 값을 1 증가 1 1 2 스레드 2 i에 값 저장 2 1 2 스레드 순서가 정상적으로 처리된다면 다음과 같이 최종적으로 i = 2가 되지만, 스레드 실행 순서가 달라진다면 스레드 동작 i 스레드 1의 레지스터 스레드 2의 레지스터 스레드 1 i의 값을 레지스터에 저장 0 0 스레드 2 i의 값을 레지스터에 저장 0 0 0 스레드 1 레지스터 값을 1 증가 0 1 0 스레드 2 레지스터 값을 1 증가 0 1 1 스레드 1 i에 값 저장 1 1 1 스레드 2 i에 값 저장 1 1 1 i = 1 이 되기에 의도와 다른 수행이 일어나며, 스레드의 실행조건에 따라 다른 결과를 나타내기에 원인 파악이 힘들다.\n이러한 문제를 경쟁조건이라고 하며 세마포어 같은 방법으로 공유데이터에 접근하는 스레드의 개수를 한 개 이하로 유지하여 해결할 수 있다.\nContext Switching 컴퓨터가 동시에 처리할 수 있는 작업 수는 CPU의 코어 수량과 같다. CPU 코어보다 많은 스레드가 동시에 실행되면 각 코어별로 정해진 시간만큼 번갈아가며 작업을 수행한다. 각 스레드가 서로 번갈아가며 교체될때 쓰레드간 현재까지의 작업상태나 다음 작업에 필요한 데이터를 저장하고 읽는 작업을 하는데 이를 Context Switching라고 한다. Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하된다. 그래서 많은 양의 단순계산은 싱글 쓰레드로 처리하는 것이 효율적인 경우가 있기에 쓰레드 수가 많은 게 항상 고성능은 아니다.\nMultithreaded Server Architecture 서버와 클라이언트 사이에도 멀티 스레드를 구현한다. 클라이언트가 새로운 요청을 하면 서버는 스레드를 새로 생성해서 요청을 수행한다. 프로세스 보다 스레드를 생성하는 것이 더 빠르기 때문에 효율적이다.\nMulticore Programming 동시성(Concurrency)\n동시성은 싱글 프로세스에서 사용되는 방식으로 프로세서가 여러 개의 스레드를 번갈아가면 수행하며 동시에 실행되는 것처럼 보이게 한다.\n병렬성(Parallelism)\n병렬성은 멀티코어 방식에서 사용되는 방식으로 여러 개의 코어가 스레드를 동시에 수행한다.\n3. Multithreading Models 유저 스레드와 커널 쓰레드 관계를 정의하는 방식이다.\nMany-to-One Model 하나의 커널 스레드에 여러 개의 유저 스레드 연결 사용자 수준에서의 스레드 관리 주로 커널 스레드를 지원하지 않는 시스템에서 사용 한 번에 하나의 유저스레드만 커널에 접근가능 멀티코어 시스템에서 병렬적인 수행이 불가능 One-to-One Model 하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델 Many-to-One방식에서 시스템 호출 시 다른 스레드들이 중단되는 문제를 해결할 수 있어 동시성 향상 멀티프로세서 시스템에서는 동시에 여러 개 쓰레드 수행 가능 유저 스레드 증가분만큼 커널 스레드가 증가. 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기에 성능저하 발생가능 Many-to-Many Model 여러 유저스레드가 더 적거나 같은 수의 커널 스레드에 대응하는 모델 운영체제에 충분한 수의 커널 스레드를 생성가능 커널 스레드의 구체적 개수는 프로그램이나 작동기기에 따라 상이 멀티프로세서 프로그램에서는 싱글프로세서 보다 더 많은 커널 스레드가 생성 커널이 사용자 스레드와 커널 스레드의 매핑을 적절하게 조절 Two-level Model Many-to-Many 모델과 유사 특정 유저 스레드를 위한 커널 스레드를 따로 제공하는 모델 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리 가능 참고\nhttps://ko.wikipedia.org/wiki/스레드_(컴퓨팅)\nhttps://rebro.kr/174\nhttp://www.tcpschool.com/java/java_thread_multi\nhttps://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9\n","wordCount":"992","inLanguage":"en","datePublished":"2023-10-17T14:01:18Z","dateModified":"2023-10-17T14:01:18Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/28/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[운영체제(OS)] 스레드 (Thread), 멀티스레드(Multithreaded Programming)란?</h1><div class=post-meta><span title='2023-10-17 14:01:18 +0000 UTC'>October 17, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/28/img.png></p><p>두 개의 실행 스레드를 가진 프로세스가 하나의 프로세서 위에서 실행 중인 모습</p><h2 id=thread란 ke-size=size26>1. Thread란?<a hidden class=anchor aria-hidden=true href=#thread란>#</a></h2><p>CPU 수행의 기본단위이며 특히 프로세스 안의 흐름의 단위이다. 스레드가 수행되는 환경을 Task라고 하며 Thread ID, Program counter, register set, Stack space로 구성된다. 각각의 스레드는 레지스터 상태와 스택을 갖는다. Code, Data 섹션이나 운영체제 자원들은 스레드끼리 공유한다. </p><h3 id=스레드의-종류 ke-size=size23>스레드의 종류<a hidden class=anchor aria-hidden=true href=#스레드의-종류>#</a></h3><p>스레드는 지원 주체에 따라 2가지로 나눌 수 있다.</p><p><strong>User Threads</strong></p><ul><li>유저 스레드는 사용자 수준의 스레드 라이브러리가 관리하는 스레드</li><li>라이브러리는 스레드의 생성 및 스케쥴링 등 관리 기능을 제공한다.</li><li>동일 메모리에서 스레드가 생성 및 관리되므로 속도가 빠르다.</li><li>여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 스레드가 같이 종료된다. (커널이 프로세스 내부 스레드를 인식하지 못하여 해당 프로세스를 대기상태로 전환시키기 때문)</li><li>스레드 라이브러리에는 POSIX, Pthreads, Win32 threads, Java threads 대표적이다</li></ul><p><strong>Kernel Threads</strong></p><ul><li>커널 스레드는 커널이 지원하는 스레드</li><li>커널 스레드를 사용하면 안정적이지만 유저모드에서 커널모드로 계속 바꿔줘야 하기에 성능이 저하된다.</li><li>반대로 유저 스레드를 사용하면 안정성은 떨어지지만 성능이 저하되지는 않는다.</li><li>스레드가 시스템 호출 등으로 중단되어도 다른 스레드를 중단시키지 않고 계속 실행시킨다.</li></ul><h3 id=thread-group-스레드-그룹 ke-size=size23>Thread Group (스레드 그룹)<a hidden class=anchor aria-hidden=true href=#thread-group-스레드-그룹>#</a></h3><p>Thread Group (스레드 그룹)이란 관련 있는 스레드를 그룹으로 묶어 다루는 장치이다. 쓰레드 그룹은 다른 스레드그룹에 포함될 수 있으며, 트리형태로 연결된다. 스레드는는 자신이 포함된 스레드 그룹이나 하위 그룹에는 접근가능 하지만, 다른 그룹에는 접근할 수 없다.</p><h3 id=deamon-thread데몬-스레드 style=color:#333;text-align:start ke-size=size23>Deamon Thread(데몬 스레드)<a hidden class=anchor aria-hidden=true href=#deamon-thread데몬-스레드>#</a></h3><ul><li>다른 일반 스레드의 작업을 돕는 보조 쓰레드</li><li>일반 스레드가 모두 종료되면 자동으로 종료</li><li>일정시간마도 자동수행되는 저장/ 화면 갱신등에 사용</li></ul><h3 id=thread-pools ke-size=size23>Thread Pools<a hidden class=anchor aria-hidden=true href=#thread-pools>#</a></h3><p>스레드를 요청할 때마다 매번 새로 생성하고, 수행하고, 지우고 반복하면 성능저하로 이어진다.</p><p>그래서 미리 스레드 풀에 여러 개의 스레드를 만들어두고 요청이 오면 스레드풀에서 스레드를 할당해 주는 방법을 사용한다. </p><h2 id=멀티스레드란 ke-size=size26>2. 멀티스레드란?<a hidden class=anchor aria-hidden=true href=#멀티스레드란>#</a></h2><p>한 번에 하나의 작업만 수행하면 싱글 스레드, 하나의 프로세스가 둘 이상의 스레드가 동시에 작업을 수행하면 멀티스레드라 한다.</p><p>멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다. </p><h3 id=멀티스레드의-장점 ke-size=size23>멀티스레드의 장점<a hidden class=anchor aria-hidden=true href=#멀티스레드의-장점>#</a></h3><p>두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.</p><p>프로세스사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생 (스레드 전환 시에도 일어나지만 속도가 더 빠르다)
 </p><p><strong>응답성</strong> : 대화형 프로그램을 멀티스레드화 하면 일부 스레드가 중단되거나 긴 작업을 수행하더라도 [ 다른 스레드가 별도의 작업을 할 수 있어 응답성이 좋다]{style=&ldquo;color: #333333; text-align: start;&rdquo;}. </p><p><strong>자원공유</strong> : 프로세스 내의 자원과 메모리를 공유함으로 시스템 자원의 낭비가 적다. 또한 같은 주소 공간 내에 여러 개의 활동성 스레드를 가질 수 있다는 장점이 있다.</p><p><strong>경제성</strong> : 메모리와 자원할당은 많인 비용이 소모된다. 스레드는 프로세스 내 자원을 공유하기에 스레드생성과 Context Switching을 하는 것이 효율적이다.</p><p><strong>멀티프로세서 활용</strong> : 각각의 스레드가 다른 프로세스에서 병렬로 수행 가능하다. 단일 쓰레드 프로세스는 CPU가 많아도 1개의 CPU에서만 실행되지만, 다중 스레드화 하면 다중 CPU에서 병렬성이 증간된다.</p><p><strong>프로세스와 비교</strong> </p><p>두 프로세스가 하나의 데이터를 공유하려면 공유메모리 또는 파이프를 사용해야 하지만, 효율이 떨어지고 구현/관리하기 힘들다.</p><p>스레드, 프로세스 사이 콘텍스트 스위치가 지속적으로 일어나면 성능저하 발생하나 스레드의 Context Switching의 속도가 더 빨라서 효율적이다.</p><h3 id=멀티스레드의-단점 style=color:#000;text-align:start ke-size=size23>멀티스레드의 단점<a hidden class=anchor aria-hidden=true href=#멀티스레드의-단점>#</a></h3><ul><li>캐시, 변환 생인 버퍼(TLB) 등의 하드웨어 리소스를 공유할 때 서로 간섭할 수 있다.</li><li>Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하되어 단순 계산은 싱글 스레드 보다 실행시간이 개선되지 않고 오히려 지연될 수 있다.</li><li>멀티 쓰레딩의 하드웨어 지원을 위해 애플리케이션, 운영체제 모두에 최적화 변경이 필요하다.</li><li>각 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다.</li></ul><p>예를 들어 스레드 1, 스레드 2로 다음 작업을 수행할 때,</p><blockquote><ul><li>공유되는 변수 i의 값을 레지스터에 저장</li><li>레지스터의 값을 1 증가</li><li>변수 i에 그 값을 저장</li></ul></blockquote><table><thead><tr><th><strong>쓰레드</strong></th><th><strong>동작</strong></th><th><strong>i</strong></th><th><strong>스레드 1의 레지스터</strong></th><th><strong>스레드 2의 레지스터</strong></th></tr></thead><tbody><tr><td>스레드 1</td><td>i의 값을 레지스터에 저장</td><td>0</td><td>0</td><td> </td></tr><tr><td>스레드 1</td><td>레지스터 값을 1 증가</td><td>0</td><td>1</td><td> </td></tr><tr><td>스레드 1</td><td>i에 값 저장</td><td><strong>1</strong></td><td>1</td><td> </td></tr><tr><td>스레드 2</td><td>i의 값을 레지스터에 저장</td><td>1</td><td>1</td><td>1</td></tr><tr><td>스레드 2</td><td>레지스터 값을 1 증가</td><td>1</td><td>1</td><td>2</td></tr><tr><td>스레드 2</td><td>i에 값 저장</td><td><strong>2</strong></td><td>1</td><td>2</td></tr></tbody></table><p>스레드 순서가 정상적으로 처리된다면 다음과 같이 최종적으로 i = 2가 되지만, 스레드 실행 순서가 달라진다면 </p><table><thead><tr><th><strong>스레드</strong></th><th><strong>동작</strong></th><th><strong>i</strong></th><th><strong>스레드 1의 레지스터</strong></th><th><strong>스레드 2의 레지스터</strong></th></tr></thead><tbody><tr><td>스레드 1</td><td>i의 값을 레지스터에 저장</td><td>0</td><td>0</td><td> </td></tr><tr><td>스레드 2</td><td>i의 값을 레지스터에 저장</td><td>0</td><td>0</td><td>0</td></tr><tr><td>스레드 1</td><td>레지스터 값을 1 증가</td><td>0</td><td>1</td><td>0</td></tr><tr><td>스레드 2</td><td>레지스터 값을 1 증가</td><td>0</td><td>1</td><td>1</td></tr><tr><td>스레드 1</td><td>i에 값 저장</td><td><strong>1</strong></td><td>1</td><td>1</td></tr><tr><td>스레드 2</td><td>i에 값 저장</td><td><strong>1</strong></td><td>1</td><td>1</td></tr></tbody></table><p>i = 1 이 되기에 의도와 다른 수행이 일어나며, 스레드의 실행조건에 따라 다른 결과를 나타내기에 원인 파악이 힘들다.</p><p>이러한 문제를 <strong>경쟁조건</strong>이라고 하며 <strong>세마포어</strong> 같은 방법으로 공유데이터에 접근하는 스레드의 개수를 한 개 이하로 유지하여 해결할 수 있다.</p><h3 id=context-switching ke-size=size23>Context Switching<a hidden class=anchor aria-hidden=true href=#context-switching>#</a></h3><p>컴퓨터가 동시에 처리할 수 있는 작업 수는 CPU의 코어 수량과 같다. CPU 코어보다 많은 스레드가 동시에 실행되면 각 코어별로 정해진 시간만큼 번갈아가며 작업을 수행한다. 각 스레드가 서로 번갈아가며 교체될때 쓰레드간 현재까지의 작업상태나 다음 작업에 필요한 데이터를 저장하고 읽는 작업을 하는데 이를 Context Switching라고 한다. Context Switching 시간이 길수록 멀티 쓰레딩의 효율은 저하된다. 그래서 많은 양의 단순계산은 싱글 쓰레드로 처리하는 것이 효율적인 경우가 있기에 쓰레드 수가 많은 게 항상 고성능은 아니다.</p><h3 id=multithreaded-server-architecture ke-size=size23>Multithreaded Server Architecture<a hidden class=anchor aria-hidden=true href=#multithreaded-server-architecture>#</a></h3><p>서버와 클라이언트 사이에도 멀티 스레드를 구현한다. 클라이언트가 새로운 요청을 하면 서버는 스레드를 새로 생성해서 요청을 수행한다.  프로세스 보다 스레드를 생성하는 것이 더 빠르기 때문에 효율적이다.</p><h3 id=multicore-programming ke-size=size23>Multicore Programming<a hidden class=anchor aria-hidden=true href=#multicore-programming>#</a></h3><p><strong>동시성(Concurrency)</strong></p><p>동시성은 싱글 프로세스에서 사용되는 방식으로 프로세서가 여러 개의 스레드를 번갈아가면 수행하며 동시에 실행되는 것처럼 보이게 한다.</p><p><strong>병렬성(Parallelism)</strong></p><p>병렬성은 멀티코어 방식에서 사용되는 방식으로 여러 개의 코어가 스레드를 동시에 수행한다.</p><h2 id=multithreading-models ke-size=size26>3. Multithreading Models<a hidden class=anchor aria-hidden=true href=#multithreading-models>#</a></h2><p>유저 스레드와 커널 쓰레드 관계를 정의하는 방식이다.</p><h3 id=many-to-one-model ke-size=size23><strong>Many-to-One Model</strong><a hidden class=anchor aria-hidden=true href=#many-to-one-model>#</a></h3><ul><li>하나의 커널 스레드에 여러 개의 유저 스레드 연결</li><li>사용자 수준에서의 스레드 관리</li><li>주로 커널 스레드를 지원하지 않는 시스템에서 사용</li><li>한 번에 하나의 유저스레드만 커널에 접근가능</li><li>멀티코어 시스템에서 병렬적인 수행이 불가능</li></ul><h3 id=one-to-one-model ke-size=size23><strong>One-to-One Model</strong><a hidden class=anchor aria-hidden=true href=#one-to-one-model>#</a></h3><ul><li>하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델</li><li>Many-to-One방식에서 시스템 호출 시 다른 스레드들이 중단되는 문제를 해결할 수 있어 동시성 향상</li><li>멀티프로세서 시스템에서는 동시에 여러 개 쓰레드 수행 가능</li><li>유저 스레드 증가분만큼 커널 스레드가 증가.</li><li>커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기에 성능저하 발생가능</li></ul><h3 id=many-to-many-model ke-size=size23><strong>Many-to-Many Model</strong><a hidden class=anchor aria-hidden=true href=#many-to-many-model>#</a></h3><ul><li>여러 유저스레드가 더 적거나 같은 수의 커널 스레드에 대응하는 모델</li><li>운영체제에 충분한 수의 커널 스레드를 생성가능</li><li>커널 스레드의 구체적 개수는 프로그램이나 작동기기에 따라 상이</li><li>멀티프로세서 프로그램에서는 싱글프로세서 보다 더 많은 커널 스레드가 생성</li><li>커널이 사용자 스레드와 커널 스레드의 매핑을 적절하게 조절</li></ul><h3 id=two-level-model ke-size=size23><strong>Two-level Model</strong><a hidden class=anchor aria-hidden=true href=#two-level-model>#</a></h3><ul><li>Many-to-Many 모델과 유사</li><li>특정 유저 스레드를 위한 커널 스레드를 따로 제공하는 모델</li><li>점유율이 높아야 하는 유저 스레드를 더 빠르게 처리 가능
 </li></ul><p>참고</p><ul><li><p><a href=https://ko.wikipedia.org/wiki/>https://ko.wikipedia.org/wiki/</a>스레드_(컴퓨팅)</p></li><li><p><a href=https://rebro.kr/174>https://rebro.kr/174</a></p></li><li><p><a href=http://www.tcpschool.com/java/java_thread_multi>http://www.tcpschool.com/java/java_thread_multi</a></p></li><li><p><a href=https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9>https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/os/>OS</a></li><li><a href=https://junhkang.com/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/>운영체제</a></li><li><a href=https://junhkang.com/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/>스레드</a></li><li><a href=https://junhkang.com/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C/>멀티스레드</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>