<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 | Jun Kang's Blog</title>
<meta name=keywords content="이펙티브자바"><meta name=description content='

1. 개념
한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.
IoC(제어의 역전) & DI(의존성 주입)의 개념
이펙티브 자바 책에서는 "맞춤법 검사기 (SpellChecker)" 클레스에서 "사전 (Dictionary)" 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.'><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/76/><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/76/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://junhkang.com/posts/76/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"><meta property="og:description" content=' 1. 개념 한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.
IoC(제어의 역전) & DI(의존성 주입)의 개념
이펙티브 자바 책에서는 "맞춤법 검사기 (SpellChecker)" 클레스에서 "사전 (Dictionary)" 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-25T14:36:42+00:00"><meta property="article:modified_time" content="2024-03-25T14:36:42+00:00"><meta property="article:tag" content="이펙티브자바"><meta name=twitter:card content="summary"><meta name=twitter:title content="[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라"><meta name=twitter:description content='

1. 개념
한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.
IoC(제어의 역전) & DI(의존성 주입)의 개념
이펙티브 자바 책에서는 "맞춤법 검사기 (SpellChecker)" 클레스에서 "사전 (Dictionary)" 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","item":"https://junhkang.com/posts/76/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","name":"[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","description":" 1. 개념 한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.\nIoC(제어의 역전) \u0026amp; DI(의존성 주입)의 개념\n이펙티브 자바 책에서는 \u0026quot;맞춤법 검사기 (SpellChecker)\u0026quot; 클레스에서 \u0026quot;사전 (Dictionary)\u0026quot; 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.\n","keywords":["이펙티브자바"],"articleBody":" 1. 개념 한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.\nIoC(제어의 역전) \u0026 DI(의존성 주입)의 개념\n이펙티브 자바 책에서는 \"맞춤법 검사기 (SpellChecker)\" 클레스에서 \"사전 (Dictionary)\" 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.\n2. 예제 2-1. 정적 유틸리티 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.\npublic class SpellCheckerStatic { private static final Lexicon dictionary = new Lexicon(); private SpellCheckerStatic() { } // 객체 생성 방지 public static boolean isValid(String word) { return dictionary.isValid(word); } public static List\u003cString\u003e suggestions(String typo) { return dictionary.suggestions(typo); } } 2-2. 싱글턴 싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다. public class SpellCheckerSingleton { private static final Lexicon dictionary = new Lexicon(); private SpellCheckerSingleton() { } public static SpellCheckerSingleton INSTANCE = new SpellCheckerSingleton(); public static boolean isValid(String word) { return dictionary.isValid(word); } public static List\u003cString\u003e suggestions(String typo) { return dictionary.suggestions(typo); } } 두방식 모두 dictionary 자원을 한 가지만 사용한다. 그렇기에 다양한 언어의 사전을 사용하거나 특수 언어용 사전을 별도로 쓰는 경우의 확장성을 생각해 보면 좋지 않다. 일반적으로 클래스에서 여러 자원을 참조할 경우 흔히 발생하는 상황이다. 위의 Spellchecker클래스에서 여러 사전을 유연하게 쓸 수 있도록 수정하려면 대표적으로 다음 두 가지 방식이 있을 것이다. 1. 단순히 dictionary 필드에서 final 제한을 제거하고 다른 사전으로 교체하는 메서드를 추가한다.\n어색하고, 오류를 내기 쉬우며 멀티 스레드 환경에서 사용 불가능하다. 사용하는 자원 객체에 따라 이후 동작이 달라지는 클래스에서는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. 2. 인스턴스를 생성하는 시점에 필요에 맞는 dictionary를 넘겨주는 방식으로 변경한다. (의존객체 주입)\n의존 객체 주입의 한 형태로 맞춤법 검사기를 생성할 때 의존 객체인 사전을 주입해주면 된다. SpellChecker 클래스가 여러 인스턴스를 지원해야 하며 클라이언트가 원하는 자원을 사용해야 한다.\n2-3. 의존객체 주입 의존객체 주입은 유연성과 테스트 용이성을 높여준다.\npublic class SpellCheckerInjection { private static final Lexicon dictionary; public SpellCheckerInjection(Lexicon disctionary) { this.dictionary = Objects.requireNonNull(disctionary); } public static boolean isValid(String word) { return dictionary.isValid(word); } public static List\u003cString\u003e suggestions(String typo) { return dictionary.suggestions(typo); } } 예시에서는 dictionary라는 하나의 자원만 사용하지만 여러 개의 자원을 참조하는 경우가 대부분이다. 그런 상황에서 의존객체 주입을 사용했을 때의 장점을 생각해 보자.\n몇 개의 자원에 의존하던 관계없이 실행된다. 불변성을 보장하여 여러 클라이언트가 의존객체들을 안심하고 공유할 수 있다. 테스트가 용이하다. 이에 변형으로 생성자에 자원 팩토리 자체를 넘겨주는 방식도 별도로 소개하고 있다. 호출될 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.(팩토리 메서드 패턴) 책에서는 자바 8의 Supplier 인터페이스를 팩토리를 표현한 완벽한 예제로 소개하고 있다.\n팩토리의 타입 매개변수를 제한하며, 이 방식을 사용해 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩토리를 넘길 수 있다. 다음 코드는 클라이언트가 제공한 팩토리가 생성한 타일들로 구성된 Mosaic를 만드는 샘플 메서드이다.\nMosaic create(Supplier\u003c\u003e extends Tile\u003e tileFactory) { Tile tile = tileFactory.get(); return new Mosaic(tile); } 3. 정리 클래스가 내부에서 하나 이상의 자원에 의존할 때 클래스 동작에 영향을 주는 자원이 있다면 싱글턴, 정적 유틸 클래스는 사용하지 않는 것이 좋고 이 자원들을 클래스가 새로 생성해서도 안된다. 필요한 자원들을 생성자에 넘겨주는 생성자 주입 방식으로 구현하면 클래스의 유연성, 재사용성, 테스트 용이성을 매우 개선해 준다. 책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능하다. https://github.com/junhkang/effective-java-summaryhttps://github.com/junhkang/effective-java-summary\nhttps://github.com/junhkang/effective-java-summary\n","wordCount":"526","inLanguage":"en","datePublished":"2024-03-25T14:36:42Z","dateModified":"2024-03-25T14:36:42Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/76/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</h1><div class=post-meta><span title='2024-03-25 14:36:42 +0000 UTC'>March 25, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/76/img.png></p><h2 id=개념 ke-size=size26>1. 개념<a hidden class=anchor aria-hidden=true href=#개념>#</a></h2><p>한 클래스 내에서 여러 개의 자원에 의존하여 사용되는 경우에 의존 객체 주입을 통해 유연성과 테스트 용이성을 개선하는 내용이다. 스프링의 의존성 주입 개념을 생각해 본다면 이미 당연하게 사용하고 있는 경우가 많을 것이지만, 의존 객체 주입의 장점을 다시 한번 생각해 볼 수 있는 내용이다.</p><p><a href=https://junhkang.tistory.com/42>IoC(제어의 역전) & DI(의존성 주입)의 개념</a></p><p>이펙티브 자바 책에서는 "맞춤법 검사기 (SpellChecker)" 클레스에서 "사전 (Dictionary)" 자원을 사용하는 예제를 들고 있다. 맞춤법 검사기 (SpellChecker)는 사전(dictionary) 자원에 의존하는 상황을 정적 유틸리티, 싱글턴, 의존객체 주입의 차이를 비교하고 있다.</p><h2 id=예제 ke-size=size26>2. 예제<a hidden class=anchor aria-hidden=true href=#예제>#</a></h2><h3 id=정적-유틸리티 ke-size=size23>2-1. 정적 유틸리티<a hidden class=anchor aria-hidden=true href=#정적-유틸리티>#</a></h3><p>정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>SpellCheckerStatic</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Lexicon dictionary <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Lexicon();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SpellCheckerStatic</span>() {
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 객체 생성 방지
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>String</span> <span style=color:#66d9ef>word</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.<span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>word</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span><span style=color:#f92672>&gt;</span> suggestions(<span style=color:#66d9ef>String</span> typo) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.suggestions(typo);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=싱글턴 ke-size=size23>2-2. 싱글턴<a hidden class=anchor aria-hidden=true href=#싱글턴>#</a></h3><p>싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다. </p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>SpellCheckerSingleton</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Lexicon dictionary <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Lexicon();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>SpellCheckerSingleton</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> SpellCheckerSingleton INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SpellCheckerSingleton();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>String</span> <span style=color:#66d9ef>word</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.<span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>word</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span><span style=color:#f92672>&gt;</span> suggestions(<span style=color:#66d9ef>String</span> typo) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.suggestions(typo);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>두방식 모두 dictionary 자원을 한 가지만 사용한다. 그렇기에 다양한 언어의 사전을 사용하거나 특수 언어용 사전을 별도로 쓰는 경우의 확장성을 생각해 보면 좋지 않다. 일반적으로 클래스에서 여러 자원을 참조할 경우 흔히 발생하는 상황이다. 위의 Spellchecker클래스에서 여러 사전을 유연하게 쓸 수 있도록 수정하려면 대표적으로 다음 두 가지 방식이 있을 것이다.
 
1. 단순히 dictionary 필드에서 final 제한을 제거하고 다른 사전으로 교체하는 메서드를 추가한다.</p><p>어색하고, 오류를 내기 쉬우며 멀티 스레드 환경에서 사용 불가능하다. 사용하는 자원 객체에 따라 이후 동작이 달라지는 클래스에서는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
 </p><p>2. 인스턴스를 생성하는 시점에 필요에 맞는 dictionary를 넘겨주는 방식으로 변경한다. (의존객체 주입)</p><p>의존 객체 주입의 한 형태로 맞춤법 검사기를 생성할 때 의존 객체인 사전을 주입해주면 된다. SpellChecker 클래스가 여러 인스턴스를 지원해야 하며 클라이언트가 원하는 자원을 사용해야 한다.</p><h3 id=의존객체-주입 ke-size=size23>2-3. 의존객체 주입<a hidden class=anchor aria-hidden=true href=#의존객체-주입>#</a></h3><p>의존객체 주입은 유연성과 테스트 용이성을 높여준다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#960050;background-color:#1e0010>class </span><span style=color:#a6e22e>SpellCheckerInjection</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Lexicon dictionary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SpellCheckerInjection</span>(Lexicon disctionary) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.dictionary <span style=color:#f92672>=</span> Objects.requireNonNull(disctionary);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>String</span> <span style=color:#66d9ef>word</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.<span style=color:#a6e22e>isValid</span>(<span style=color:#66d9ef>word</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span><span style=color:#f92672>&gt;</span> suggestions(<span style=color:#66d9ef>String</span> typo) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dictionary.suggestions(typo);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>예시에서는 dictionary라는 하나의 자원만 사용하지만 여러 개의 자원을 참조하는 경우가 대부분이다. 그런 상황에서 의존객체 주입을 사용했을 때의 장점을 생각해 보자.</p><ul><li>몇 개의 자원에 의존하던 관계없이 실행된다.</li><li>불변성을 보장하여 여러 클라이언트가 의존객체들을 안심하고 공유할 수 있다.</li><li>테스트가 용이하다.</li></ul><p>이에 변형으로 생성자에 자원 팩토리 자체를 넘겨주는 방식도 별도로 소개하고 있다. 호출될 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말한다.(팩토리 메서드 패턴) 책에서는 자바 8의 Supplier &lt;T> 인터페이스를 팩토리를 표현한 완벽한 예제로 소개하고 있다.</p><p><img loading=lazy src=/images/posts/76/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-25%20%EC%98%A4%ED%9B%84%202.00.21.png></p><p>팩토리의 타입 매개변수를 제한하며, 이 방식을 사용해 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩토리를 넘길 수 있다. 다음 코드는 클라이언트가 제공한 팩토리가 생성한 타일들로 구성된 Mosaic를 만드는 샘플 메서드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-arduino data-lang=arduino><span style=display:flex><span>Mosaic <span style=color:#a6e22e>create</span>(Supplier<span style=color:#f92672>&lt;&gt;</span> extends Tile<span style=color:#f92672>&gt;</span> tileFactory) {
</span></span><span style=display:flex><span>    Tile tile <span style=color:#f92672>=</span> tileFactory.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Mosaic(tile);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=정리 ke-size=size26>3. 정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>클래스가 내부에서 하나 이상의 자원에 의존할 때 클래스 동작에 영향을 주는 자원이 있다면 싱글턴, 정적 유틸 클래스는 사용하지 않는 것이 좋고 이 자원들을 클래스가 새로 생성해서도 안된다. 필요한 자원들을 생성자에 넘겨주는 생성자 주입 방식으로 구현하면 클래스의 유연성, 재사용성, 테스트 용이성을 매우 개선해 준다.
 </p><ul><li>책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능하다.</li></ul><p><a href=https://github.com/junhkang/effective-java-summaryhttps://github.com/junhkang/effective-java-summary>https://github.com/junhkang/effective-java-summaryhttps://github.com/junhkang/effective-java-summary</a></p><p><a href=https://github.com/junhkang/effective-java-summary>https://github.com/junhkang/effective-java-summary</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/>이펙티브자바</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>