<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.1"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Jun Kang's Blog</title>
<meta name=description content><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:1313/><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/index.xml><link rel=alternate type=application/json href=http://localhost:1313/index.json><link rel=alternate hreflang=en href=http://localhost:1313/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[WEB] SSR(Server Side Rendering) 과 CSR(Client Side Rendering)의 개념 및 차이</h2></header><div class=entry-content><p>1. SSR (Server Side Rendering) 서버에서 렌더링 준비를 마친 상태로 클라이언트에 자원을 전달한다.
1-1. SSR 작동 방식 유저가 웹사이트 자원을 요청 서버에서 “렌더링 가능한” HTML 파일 생성 (리소스 체크, 컴파일 후 완성된 HTML 콘텐츠 생성) 브라우저는 즉시 HTML 렌더링, 사이트 조작 불가 상태 클라이언트가 자바스크립트를 다운받는다. 다운로드하여지고 있는 사이 콘텐츠는 볼 수 있지만 조작은 불가, 이 기간 동안 유저의 액션을 기억 브라우저가 자바스크립트 프레임워크를 실행 자바스크립트가 컴파일된 후 기억하고 있던 유저 액션을 실행시킨다. 서버에서 렌더링 가능한 상태로 이미 전달되기에 자바스크립트를 받는 동안 특정 자원을 볼 수 있다. 1-2. SSR 장점 초기 페이지의 로딩속도가 빠르다. 서버에서 컴파일되어 클라이언트로 넘어오기에 클롤러 대응에 용이하여 SEO 친화적이다. 클라이언트 하드웨어 및 소프트웨어 성능에 영향을 덜 받는다. 1-3. SSR 선택 기준 네트워크가 느릴 때 (페이지마다 나눠서 불러오기 때문) 검색엔진 최적화가 필요할 때 최초 로딩이 빨라야 할 때 메인 스크립트가 크고 로딩이 느릴 때 웹사이트 상호작용이 별로 없을 때 2. CSR (Client Side Rendering) 렌더링이 클라이언트에서 일어난다. 서버에선 HTML과 JS를 보내고, 클라이언트에서 렌더링을 시작한다. 모든 로직, 데이터, 템플릿, 라우팅은 클라이언트에서 실행된다. 자바스크립트 번들 크기의 영향을 많이 받기에 코드 분할을 고려해야 하며, 적시 적소에 필요한 기능만을 제공해야 한다.
...</p></div><footer class=entry-footer><span title='2023-11-28 12:33:47 +0000 UTC'>November 28, 2023</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [WEB] SSR(Server Side Rendering) 과 CSR(Client Side Rendering)의 개념 및 차이" href=http://localhost:1313/posts/49/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[네트워크] REST, RESTful API의 개념 및 설계 가이드</h2></header><div class=entry-content><p>1. REST란? REST란 Representational State Transfer의 약자로 자원을 이름으로 구분하여 자원의 상태를 주고받는 것을 의미한다. HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 행위를 적용한다.
1-1. REST 구성요소 자원(Resource) : HTTP URI - 서버는 고유한 리소스 식별자로 각 리소스를 식별 행위(Verb) : HTTP Method (GET, POST, PUT, DELETE) 내용(Representations) : HTTP Message Pay Load - 하나의 자원은 JSON,XML, TEST, RSS 등 여러 형태의 Representaion으로 나타내어질 수 있다. 1-2. REST의 특징 Stateless (무상태성) - 서버가 이전의 모든 요청과 독립적으로 클라이언트 요청을 완료함을 의미 Cacheable(캐쉬 가능성) - 일부 응답을 저장하는 프로세스인 캐싱을 지원함을 의미 Layered System (계층화) - 클라이언트는 REST API Server만 호출하지만, 클라이언트 요청을 이행하기 위해 함께 작동하는 비즈니스 로직(보안, 암호화 등)을 여러 계층으로 실행될 수 있도록 유연하게 설계 가능함을 의미 Uniform Interface (균일한 인터페이스) - 서버가 표준 형식으로 정보를 전송함을 의미 1-3. 장점 HTTP 프로토콜을 그대로 사용하기에 별도 인프라를 구축할 필요가 없음 HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능 API의 의도를 쉽고 명확하게 파악 가능 클라이언트, 서버를 완전히 분리하기에 각 부분이 독립적으로 발전 가능 사용되는 기술과 독립적이기에 API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 작성이 가능 1-4. 단점 표준이 존재하지 않아 정의가 필요함 HTTP Method 형태가 제한적 2. RESTful API란? REST 아키텍쳐를 따르는 API를 RESTful API (Representaional state transfer API)라고 하며 REST 아키텍처를 구현하는 웹서비스를 RESTful 웹 서비스라고 한다. REST는 복잡한 네트워크에서 통신을 관리하기 위한 지침으로 만들어 졌으며, 대규모의 고성능 통신을 안정적으로 지원할 수 있고 쉽게 구현 및 수정할 수 있어 파악에 용이하고 여러 시스템에서 사용이 가능하다.
...</p></div><footer class=entry-footer><span title='2023-11-21 17:36:52 +0000 UTC'>November 21, 2023</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [네트워크] REST, RESTful API의 개념 및 설계 가이드" href=http://localhost:1313/posts/48/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[Spring] 순환참조란? The dependencies of some of the beans in the application context form a cycle</h2></header><div class=entry-content><p>1. 순환참조란? 순환참조는 맞물린 의존성 주입 (DI) 상태에서 어떤 빈을 먼저 생성할지 결정하지 못해서 생기에 발생한다. BeanA에서 BeanB를 참조(BeanA->BeanB) 일 경우 스프링은 BeanB를 먼저 생성 후 BeanA를 생성하기에, BeanB에서 다시 BeanA를 참조할 경우 (BeanA->BeanB->BeanA) 순환 참조가 발생하게된다. 2. 의존성 주입 의존성 주입의 3가지 상황 (생성자 주입방식, 필드 주입방식, Setter주입)에서 순환참조가 발생할수 있다. 다음 포스트 각각의 상세 내용을 확인할 수 있고, 이번 포스트에서는 각각의 경우에 순환참조가 발생하면 어떤 차이점이 있는지 확인해 보자.
...</p></div><footer class=entry-footer><span title='2023-11-17 14:36:15 +0000 UTC'>November 17, 2023</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [Spring] 순환참조란? The dependencies of some of the beans in the application context form a cycle" href=http://localhost:1313/posts/47/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[PostgreSQL] 함수(Function)의 정의 및 상세 사용법 (다양한 예제)</h2></header><div class=entry-content><p>1. PostgreSQL Function이란? SQL 함수는 임의의 SQL문들을 실행하고 마지막 쿼리의 결과를 반환한다. 단순한 형태의 함수는 마지막 쿼리의 첫 번째 row가 리턴된다. (order by 를 사용하지 않는 경우 다중 row의 첫 번째 행은 별도 정의되지 않기에 결과 row가 매번 다를 수 있다.) 마지막 쿼리가 row를 하나도 반환하지 않을 경우 null이 리턴된다. SQL 함수는 함수의 리턴 유형을 특정 타입의 집합 (SET)으로 선언하거나, 테이블로 선언하여 반환할 수 있다. 이 경우에는 마지막 쿼리의 모든 ROW가 리턴된다. SQL함수의 body는 세미콜론(;)으로 구분된 SQL구문의 집합이어야만 한다. 마지막 구문 뒤의 세미콜론(;)은 생략하여도된다. 함수가 void를 리턴하는 것으로 선언되지 않았다면, 마지막 구문은 반환절이 존재하는 select, insert, update, delete 여야만 한다. 모든 종류의 SQL 언어의 명령 모음은 패키징 되어 함수로 정의될 수 있다. select쿼리 외에도 insert, update, delete, merge 등의 데이터 수정쿼리 및 기타 SQL을 포함할 수 있지만, 트랜잭션 제어 명령( ex. commit, savepoint) 및 vacutaion 등의 일부 유틸리티 명령은 사용할 수 없다. SQL이 작동은 하지만 특정 값을 리턴하지 않는 SQL 함수를 정의하고 싶다면, void를 리턴하는 것으로 정의할 수 있다. ▶ 1-1. Function 간단 예시 다음은 emp 테이블에서 음수의 salary를 삭제하는 함수이다.
...</p></div><footer class=entry-footer><span title='2023-11-15 17:12:23 +0000 UTC'>November 15, 2023</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [PostgreSQL] 함수(Function)의 정의 및 상세 사용법 (다양한 예제)" href=http://localhost:1313/posts/46/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법</h2></header><div class=entry-content><p>1. 단위 테스트 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 통합 테스트의 경우 시스템을 구성하는 컴포넌트들이 커질수록 테스트 시간이 길어지지만, 단위 테스트의 경우 해당 부분만 독립적으로 테스트하기에 코드의 변경이 있어도 빠르게 문제 여부를 확인할 수 있다. CleanCode 책에 의하면 깨끗한 테스트 코드는 다음 5가지 규칙을 따라야 한다.
Fast - 빠르게 동작하여 자주 돌릴 수 있어야 한다.
Independent - 테스트는 독립적이며 서로 의존해서는 안된다.
Repeatable - 어느 환경에서도 반복이 가능해야 한다.
Self-validating - 테스트는 성공 또는 실패로 결과를 내어 자체 검증되어야 한다.
Timely - 테스트는 적시에, 테스트하려는 실제코드를 구현하기 직전에 구현해야 한다.
...</p></div><footer class=entry-footer><span title='2023-11-14 15:36:35 +0000 UTC'>November 14, 2023</span>&nbsp;·&nbsp;Jun Kang</footer><a class=entry-link aria-label="post link to [Spring] 단위 테스트, JUnit의 개념 및 단위 테스트 코드 작성 방법" href=http://localhost:1313/posts/45/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://localhost:1313/page/11/>«&nbsp;Prev&nbsp;
</a><a class=next href=http://localhost:1313/page/13/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>