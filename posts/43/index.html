<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Spring] 스프링 컨테이너(Spring container)의 개념 | Jun Kang's Blog</title>
<meta name=keywords content="spring,Bean,Spring"><meta name=description content="
1. 스프링 컨테이너(Spring container)란?
스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.

객체의 생명주기 관리
생성된 객체들의 추가적인 기능 제공

스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는
 
[수동]
@Configuration - 어플리케이션 구성정보를 등록
@Bean - 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록
 
[자동]
@ComponentScan - 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 "><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/43/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/43/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="https://junhkang.com/posts/43/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[Spring] 스프링 컨테이너(Spring container)의 개념"><meta property="og:description" content=" 1. 스프링 컨테이너(Spring container)란? 스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.
객체의 생명주기 관리 생성된 객체들의 추가적인 기능 제공 스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는 [수동]
@Configuration - 어플리케이션 구성정보를 등록
@Bean - 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록 [자동]
@ComponentScan - 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 "><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-07T16:45:10+00:00"><meta property="article:modified_time" content="2023-11-07T16:45:10+00:00"><meta property="article:tag" content="Bean"><meta property="article:tag" content="Spring"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Spring] 스프링 컨테이너(Spring container)의 개념"><meta name=twitter:description content="
1. 스프링 컨테이너(Spring container)란?
스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.

객체의 생명주기 관리
생성된 객체들의 추가적인 기능 제공

스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는
 
[수동]
@Configuration - 어플리케이션 구성정보를 등록
@Bean - 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록
 
[자동]
@ComponentScan - 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[Spring] 스프링 컨테이너(Spring container)의 개념","item":"https://junhkang.com/posts/43/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Spring] 스프링 컨테이너(Spring container)의 개념","name":"[Spring] 스프링 컨테이너(Spring container)의 개념","description":" 1. 스프링 컨테이너(Spring container)란? 스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.\n객체의 생명주기 관리 생성된 객체들의 추가적인 기능 제공 스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는 [수동]\n@Configuration - 어플리케이션 구성정보를 등록\n@Bean - 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록 [자동]\n@ComponentScan - 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 ","keywords":["spring","Bean","Spring"],"articleBody":" 1. 스프링 컨테이너(Spring container)란? 스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.\n객체의 생명주기 관리 생성된 객체들의 추가적인 기능 제공 스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는 [수동]\n@Configuration - 어플리케이션 구성정보를 등록\n@Bean - 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록 [자동]\n@ComponentScan - 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 @Component - 스프링 런타임시 자동으로 빈을 찾아 등록 이전 포스트의 IoC는 스프링 빈들의 생명 주기를 관리하기 위해 사용하며, 스프링 컨테이너는 DI(의존성 주입)이 이루어진 빈들을 BeanFactory, ApplicationContext 2개의 컨테이너로 제어하고 관리한다.\n[Spring] - [Spring] IoC(제어의 역전) \u0026 DI(의존성 주입)의 개념\n2. 왜 스프링 컨테이너를 사용할까? 자바 코드를 작성시 new생성자를 통해 객체를 매번 생성할 경우, 객체 간의 참조가 많아지고 의존성이 높아지게 된다. 이는 객체 지향 프로그램 원칙에 위배되며 객체 간의 의존성 및 결합도를 낮추기 위해 스프링 컨테이너가 사용된다. 스프링 컨테이너는 구현 클래스의 의존성을 제거하고 인터페이스에만 의존하도록 설계 가능하도록 한다.\n3. 스프링 컨테이너의 종류 도식을 보면 ApplicationContext 인터페이스가 다른 인터페이스를 다중 상속하고 있다\nBeanFactory의 모든 기능을 상속하여 Bean 객체를 관리한다. BeanFactory\n스프링 컨테이너의 최상위 인터페이스 스프링 빈을 관리하고 조회 ApplicationContext\nBeanFactory의 모든 기능을 상속받아서 제공 단순한 빈 관리를 넘어 어플리케이션 개발을 위해 공통적으로 필요한 많은 부가기능을 제공 참고\n도서 : 스프링 부트 3 백엔드 개발자 되기 - 자바 편\nhttps://devloper-dreaming.tistory.com/148\nhttps://ittrue.tistory.com/220%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84,%EB%B9%88(Bean)%EC%9D%B4%EB%9D%BC%20%ED%95%9C%EB%8B%A4. https://chobopark.tistory.com/200\nhttps://devloper-dreaming.tistory.com/148\n","wordCount":"227","inLanguage":"en","datePublished":"2023-11-07T16:45:10Z","dateModified":"2023-11-07T16:45:10Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/43/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[Spring] 스프링 컨테이너(Spring container)의 개념</h1><div class=post-meta><span title='2023-11-07 16:45:10 +0000 UTC'>November 7, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=스프링-컨테이너spring-container란 ke-size=size26>1. 스프링 컨테이너(Spring container)란?<a hidden class=anchor aria-hidden=true href=#스프링-컨테이너spring-container란>#</a></h2><p>스프링 프레임워크의 핵심 컴포넌트이며 주요한 용도는 다음과 같다.</p><ul><li>객체의 생명주기 관리</li><li>생성된 객체들의 추가적인 기능 제공</li></ul><p>스프링에서는 자바 객체를 빈(Bean)이라고 하며 컨테이너는 내부의 빈 라이프사이클(생성, 제거 등)을 하며 추가 기능을 제공한다. 기존 스프링에서는 xml 파일로 설정하나 스프링 부트에서는 자바 클래스에서 설정가능하다. 주요 설정으로는
 </p><p><strong>[수동]</strong></p><p><strong>@Configuration -</strong> 어플리케이션 구성정보를 등록</p><p><strong>@Bean -</strong> 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록
 </p><p><strong>[자동]</strong></p><p><strong>@ComponentScan -</strong> 해당 클레스클래스 패키지와 하위의 @Component, @Service, @Repository, @Controller 클래스를 탐색하여 빈등록 </p><p><strong>@Component -</strong> 스프링 런타임시 자동으로 빈을 찾아 등록
 </p><p>이전 포스트의 IoC는 스프링 빈들의 생명 주기를 관리하기 위해 사용하며, 스프링 컨테이너는 DI(의존성 주입)이 이루어진 빈들을 BeanFactory, ApplicationContext 2개의 컨테이너로 제어하고 관리한다.</p><p><a href=https://junhkang.tistory.com/42>[Spring] - [Spring] IoC(제어의 역전) & DI(의존성 주입)의 개념</a></p><p><img loading=lazy src=/images/posts/43/img.png></p><h2 id=왜-스프링-컨테이너를-사용할까 ke-size=size26>2. 왜 스프링 컨테이너를 사용할까?<a hidden class=anchor aria-hidden=true href=#왜-스프링-컨테이너를-사용할까>#</a></h2><p>자바 코드를 작성시 new생성자를 통해 객체를 매번 생성할 경우, 객체 간의 참조가 많아지고 의존성이 높아지게 된다. 이는 객체 지향 프로그램 원칙에 위배되며 객체 간의 의존성 및 결합도를 낮추기 위해 스프링 컨테이너가 사용된다. 스프링 컨테이너는 구현 클래스의 의존성을 제거하고 인터페이스에만 의존하도록 설계 가능하도록 한다.</p><h2 id=스프링-컨테이너의-종류 ke-size=size26>3. 스프링 컨테이너의 종류<a hidden class=anchor aria-hidden=true href=#스프링-컨테이너의-종류>#</a></h2><p><img loading=lazy src=/images/posts/43/img_1.png></p><p>도식을 보면 ApplicationContext 인터페이스가 다른 인터페이스를 다중 상속하고 있다</p><p>BeanFactory의 모든 기능을 상속하여 Bean 객체를 관리한다.
 </p><p><strong>BeanFactory</strong></p><ul><li>스프링 컨테이너의 최상위 인터페이스</li><li>스프링 빈을 관리하고 조회</li></ul><p><strong>ApplicationContext</strong></p><ul><li>BeanFactory의 모든 기능을 상속받아서 제공</li><li>단순한 빈 관리를 넘어 어플리케이션 개발을 위해 공통적으로 필요한 많은 부가기능을 제공
 </li></ul><p> </p><p>참고</p><ul><li><p>도서 : 스프링 부트 3 백엔드 개발자 되기 - 자바 편</p></li><li><p><a href=https://devloper-dreaming.tistory.com/148>https://devloper-dreaming.tistory.com/148</a></p></li><li><p><a href=https://ittrue.tistory.com/220%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84,%EB%B9%88(Bean)%EC%9D%B4%EB%9D%BC%20%ED%95%9C%EB%8B%A4>https://ittrue.tistory.com/220%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84,%EB%B9%88(Bean)%EC%9D%B4%EB%9D%BC%20%ED%95%9C%EB%8B%A4</a>.
 </p></li><li><p><a href=https://chobopark.tistory.com/200>https://chobopark.tistory.com/200</a></p></li><li><p><a href=https://devloper-dreaming.tistory.com/148>https://devloper-dreaming.tistory.com/148</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/bean/>Bean</a></li><li><a href=https://junhkang.com/tags/spring/>Spring</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>