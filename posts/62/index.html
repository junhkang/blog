<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라 | Jun Kang's Blog</title>
<meta name=keywords content="Effective"><meta name=description content="

1. 개념
단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다.
 
단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우

기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays
특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections
final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문)

해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다.
 "><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/62/><meta name=google-site-verification content="G-LE7D0WZLFJ"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/62/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="https://junhkang.com/posts/62/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라"><meta property="og:description" content=" 1. 개념 단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다. 단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우
기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays 특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문) 해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다. "><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-18T15:44:56+00:00"><meta property="article:modified_time" content="2024-02-18T15:44:56+00:00"><meta property="article:tag" content="Effective"><meta name=twitter:card content="summary"><meta name=twitter:title content="[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라"><meta name=twitter:description content="

1. 개념
단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다.
 
단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우

기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays
특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections
final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문)

해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다.
 "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라","item":"https://junhkang.com/posts/62/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라","name":"[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라","description":" 1. 개념 단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다. 단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우\n기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays 특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문) 해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다. ","keywords":["Effective"],"articleBody":" 1. 개념 단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다. 단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우\n기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays 특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문) 해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다. 실제로 공개된 API들에서도 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 보인다. 단순히 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 하위 클래스를 만들어 인스턴스화하면 그만이기 때문이다. 이 경우 사용자는 상속해서 사용하라는 것으로 오해할 수도 있으니 문제이지만, 다행히 인스턴스화를 막는 것은 간단하다. 컴파일러가 기본생성자를 만드는 경우는 오직 명시된 생성자가 없을 때뿐이니 private 생성자를 추가하면 클래스의 인스턴스화를 막으면 된다. 책의 예제를 확인해보자.\npublic class UtilityClass { // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용). private UtilityClass() { throw new AssertionError(); } } 명시적 생성자가 private이니 클래스 밖에서는 접근불가하다. AssertionError()도 필요 없지만 혹시 클래스 내에서 호출된 경우를 방지한다. 이 코드는 어떤 상황에서도 클래스가 인스턴스화되는 것을 방지한다.\n(하지만 생성자가 존재하는데 호출이 불가한 상태이니 코드만 봐선 직관적이지 않다. 앞의 코드처럼 적절한 주석을 달아주자) 이방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 된다. 이를 private으로 선언해 두면 하위 클래스가 상위 클래스의 생성자에 접근할 길이 없게 된다.\n2. 결론 객체 지향적 사고와 어울리지 않지만 정적 메서드/정적필드만을 담을 클래스를 생성해야 할 경우가 있다. 이 경우에는 private 생성자를 통해 인스턴스화를 막아주어 클래스 내/외부에서의 생성자 호출을 막아주자. 책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능\nhttps://github.com/junhkang/effective-java-summary\nhttps://github.com/junhkang/effective-java-summary/tree/master/src/main/java/org/example/ch01/item04\n","wordCount":"286","inLanguage":"en","datePublished":"2024-02-18T15:44:56Z","dateModified":"2024-02-18T15:44:56Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/62/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</h1><div class=post-meta><span title='2024-02-18 15:44:56 +0000 UTC'>February 18, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/62/img.png></p><h2 id=개념 ke-size=size26>1. 개념<a hidden class=anchor aria-hidden=true href=#개념>#</a></h2><p>단순히 정적 메서드와 정적 필드만을 담은 클래스를 생성하는 경우가 있다. 객체 지향적 사고하지 않는 이들이 종종 남용하지만 쓰임새는 분명히 존재한다.
 </p><p>단순히 정적 메서드와 정적 필드만으로 클래스를 생성하는 경우</p><ul><li>기본 타입 값이나 배열 관련 메서드의 집합 ex) java.lang.Math, java.Util.Arrays</li><li>특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합 ex) java.util.Collections</li><li>final 클래스와 관련된 메서드의 집합 (final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문)</li></ul><p>해당 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰기 위해 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기에 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없다.
 </p><p>실제로 공개된 API들에서도 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 보인다. 단순히 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 하위 클래스를 만들어 인스턴스화하면 그만이기 때문이다. 이 경우 사용자는 상속해서 사용하라는 것으로 오해할 수도 있으니 문제이지만, 다행히 인스턴스화를 막는 것은 간단하다.
 </p><p>컴파일러가 기본생성자를 만드는 경우는 오직 명시된 생성자가 없을 때뿐이니 private 생성자를 추가하면 클래스의 인스턴스화를 막으면 된다. 책의 예제를 확인해보자.</p><pre tabindex=0><code>public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass()  {
        throw new AssertionError();
    }
}
</code></pre><p> </p><p>명시적 생성자가 private이니 클래스 밖에서는 접근불가하다. AssertionError()도 필요 없지만 혹시 클래스 내에서 호출된 경우를 방지한다. 이 코드는 어떤 상황에서도 클래스가 인스턴스화되는 것을 방지한다.</p><p>(하지만 생성자가 존재하는데 호출이 불가한 상태이니 코드만 봐선 직관적이지 않다. 앞의 코드처럼 적절한 주석을 달아주자)
 </p><p>이방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 된다. 이를 private으로 선언해 두면 하위 클래스가 상위 클래스의 생성자에 접근할 길이 없게 된다.</p><h2 id=결론 ke-size=size26>2. 결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>객체 지향적 사고와 어울리지 않지만 정적 메서드/정적필드만을 담을 클래스를 생성해야 할 경우가 있다. 이 경우에는 private 생성자를 통해 인스턴스화를 막아주어 클래스 내/외부에서의 생성자 호출을 막아주자.
 </p><p>책의 예제 소스와 상세 내용은 다음 repo에서 확인 가능</p><ul><li><p><a href=https://github.com/junhkang/effective-java-summary>https://github.com/junhkang/effective-java-summary</a></p></li><li><p><a href=https://github.com/junhkang/effective-java-summary/tree/master/src/main/java/org/example/ch01/item04>https://github.com/junhkang/effective-java-summary/tree/master/src/main/java/org/example/ch01/item04</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/effective/>Effective</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://junhkang.com/>Jun Kang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>