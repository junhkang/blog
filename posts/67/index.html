<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[PostgreSQL] 트랜잭션(Transaction)의 작동원리 | Jun Kang's Blog</title><meta name=keywords content="Transaction,PostgreSQL"><meta name=description content="
 

1. 기본 트랜잭션의 개념 및 원리
트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.
[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용
기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.
2. 트랜잭션과 식별자 (Transactions and Identifiers)
기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/67/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/67/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/67/"><meta property="og:title" content="[PostgreSQL] 트랜잭션(Transaction)의 작동원리 | Jun Kang's Blog"><meta property="og:description" content="
 

1. 기본 트랜잭션의 개념 및 원리
트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.
[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용
기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.
2. 트랜잭션과 식별자 (Transactions and Identifiers)
기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/67/"><meta property="twitter:title" content="[PostgreSQL] 트랜잭션(Transaction)의 작동원리 | Jun Kang's Blog"><meta property="twitter:description" content="
 

1. 기본 트랜잭션의 개념 및 원리
트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.
[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용
기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.
2. 트랜잭션과 식별자 (Transactions and Identifiers)
기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9413249746505723" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/67/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[PostgreSQL] 트랜잭션(Transaction)의 작동원리"><meta property="og:description" content=" 1. 기본 트랜잭션의 개념 및 원리 트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.
[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용
기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.
2. 트랜잭션과 식별자 (Transactions and Identifiers) 기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-08T15:27:32+00:00"><meta property="article:modified_time" content="2024-03-08T15:27:32+00:00"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="PostgreSQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PostgreSQL] 트랜잭션(Transaction)의 작동원리"><meta name=twitter:description content="
 

1. 기본 트랜잭션의 개념 및 원리
트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.
[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용
기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.
2. 트랜잭션과 식별자 (Transactions and Identifiers)
기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"[PostgreSQL] 트랜잭션(Transaction)의 작동원리","item":"https://junhkang.com/posts/67/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[PostgreSQL] 트랜잭션(Transaction)의 작동원리","name":"[PostgreSQL] 트랜잭션(Transaction)의 작동원리","description":" 1. 기본 트랜잭션의 개념 및 원리 트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.\n[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용\n기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.\n2. 트랜잭션과 식별자 (Transactions and Identifiers) 기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자.\n","keywords":["Transaction","PostgreSQL"],"articleBody":" 1. 기본 트랜잭션의 개념 및 원리 트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.\n[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용\n기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.\n2. 트랜잭션과 식별자 (Transactions and Identifiers) 기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자.\n2-1. Virtual Transaction Id 모든 트랜잭션은 유니크한 Virtual Transaction Id(virtualXID, vxid)로 식별된다. 이 Virtual Transaction Id는 Backend ID와 각 백앤드에 순차적으로 부여된 로컬 아이디 (LocalXID)로 구성되어 있다. 캡처의 virtualxid를 확인해 보면 다음과 같다.\nVirtual Transaction ID = 115/10798 Backend Id = 115 LocalXID = 10798 2-2. Non-Virtual TransactionIds 그 외 가상이 아닌 Non-Virtual TransactionIds(or xid) (캡처의 transactionId = 114016445)들은 PostgreSQL 클러스터의 모든 데이터베이스에서 공통으로 사용하는 global counter를 순차적으로 사용한다. 이러한 TransactionID는 트랜잭션이 처음 데이터베이스에 write 할 때 적용되며, xids가 낮을수록 먼저 수행된 트랜잭션임을 의미한다. 하지만 트랜잭션이 처음 데이터베이스 write를 실행한 순서와 트랜잭션이 시작된 순서는 다를 수 있다. 특히 트랜잭션이 데이터베이스를 read만으로 시작할 때 그렇다. 각 xid는 32비트이고 20억 건의 트랜잭션마다 wraps around 한다.\nwraps around - 트랜잭션 번호가 40억 건이 넘으면 0에서부터 다시 시작하며, 중복된 트랜잭션이 부여될 수 있다. 이 경우 데이터는 존재하지만 접근하지 못하는 데이터가 발생하며, 치명적인 데이터 손실로 이어질 수 있다. 이를 방지하기 위해 20억 트랜잭션이 일어날 때마다 모든 데이터베이스, 모든 테이블에 최소 1번의 vacuum을 실행한다. 해당 내용에서 트랜잭션의 40억 건이 넘으면 0부터 다시 실행되는데 왜 40억이 아닌 20억 트랜잭션마다 최소 1번의 Vacuum이 일어날까? 에 대한 궁금증이 들어 PostgreSQL 측에 문의하였고, PostgreSQL 측 공식 답변은 다음과 같다.\n트랜잭션 ID를 \"순환 카운터(Circular Counter)\"로 취급하기 때문이다. 특정 트랜잭션 (A)와 트랜잭션 (B)를 비교할 때 (A의 트랜잭션 ID-B의 트랜잭션 ID)의 연산 후 부호를 포함한 정수로 연산을 한다. 만약 결과가 음수라면 A가 더 최근 트랜잭션이고, 공간이 순환적이고 서로 다른 트랜잭션 A, B의 ID가 다를 수 없기에 부호를 가진 정수로써 모두 표현이 가능하다. \\\n순환 공간에서는 1G(10억 건의 트랜잭션)이 3G보다 이전에 있을 수도 있고, 이후에 있을 수도 있다. (1G가 3G의 이전 사이클에서 생성된 트랜잭션 ID인지, 이후 사이클에서 생성된 트랜잭션 ID인지 부호 없이는 구분이 불가능하다.)\n1.5G와 2.5G의 비교 : 1.5G는 2.5G보다 10억 트랜잭션 이전이므로, 부호 있는 비교에서는 1.5G는 2.5G보다 이전 트랜잭션 0.5G 와 3.5G 비교 : 순환 공간을 생각할 때 4G가 최대치인 상황에서 0.5G가 3.5G보다 이후로 간주된다. (0이 최대치(4G) 이후에 존재하기 때문) 그렇기 때문에 부호 있는 비교에서는 0.5G가 3.5G 이후로 판단됨.\n그렇기 때문에 순환 카운터에서는 최대치(4G)의 절반인 2G 트랜잭션 제한을 통해 +/-2G의 범위 내에서 트랜잭션 ID의 “전후” 관계를 파악한다. 매 wraps around 마다 32bit epoch가 증가하며 64비트의 xid8 유형도 존재한다. (pg_current_xact_id[ () → 로 현재 xid8 조회 가능]{style=“background-color: #ffffff; color: #212529; text-align: left;”}) Xid들은 PostgreSQL의 MVCC의 동시성, 및 스트리밍 복제의 근간으로 사용된다. 최상위 트랜잭션의 non-virtual xid가 커밋되면, pg_xact 디렉터리에 커밋으로 기록되며 추가 정보들은 pg_commit_ts 디렉터리에 기록된다. (track_commit_timestamp가 활성화 필요) virtual xid, non-virtual xid에, PREPARED TRANSACTION의 경우에는 Global Transaction Identifiers(GID)가 추가로 부여된다. GID는 200바이트의 문자열로 현재의 다른 PREPARED TRANSACTION과 중복되지 않아야 한다. (GID와 xid의 매핑관계는 pg_prepared_xacts에서 확인가능하다.)\n3. 트랜잭션과 락 (Transactions and Locking) 현재 진행 중인 트랜잭션의 Transaction ID는 pg_locks의 virtualxid와 transactionId 칼럼에서 확인할 수 있다.\nSELECT LOCKTYPE, VIRTUALXID, TRANSACTIONID FROM PG_LOCKS; 두 칼럼 모두 read/write 트랜잭션에 존재하지만 Read-only 트랜잭션에는 virtualxid는 있으나 transactionId는 null이다. READ만 수행한 트랜잭션\nRead/Write를 모두 실행한 트랜잭션\nRow-level의 read/write locks는 잠긴 row에 바로 기록되며 pgrowlocks extension을 통해 확인 가능하다.\n4. 서브트랜잭션 (Subtransactions) 서브 트랜잭션(Subtransactions, subxact)은 트랜잭션 안에서 시작되며 큰 트랜잭션을 더 작은 트랜잭션 단위로 분리할 수 있게 해 준다. 서브 트랜잭션은 부모 트랜잭션이 영향을 받지 않고 계속 진행되게 한 채로 commit 혹은 rollback 할 수 있다. 서브 트랜잭션은 SAVEPOINT라는 커맨드로 명시적 실행이 가능하지만 PL/pgSQL의 Exception 구문으로도 실행 가능하다. 서브트랜잭션은 다른 서브트랜잭션으로부터도 시작 가능하다. 최상위 트랜잭션과 그 자식 서브트랜잭션은 계층구조 혹은 트리 구조를 형성하며 그렇기 때문에 메인 트랜잭션을 top-level 트랜잭션이라고 한다. 서브트랜잭션이 non-virtual TransactionalId를 할당받았다면, 그 트랜잭션아이디는 subxid라고 한다. Read-only 서브트랜잭션은 subxids가 부여되지 않지만 write를 하려고 하는 순간 1개를 부여받는다. 또한 상위 레벨 트랜잭션을 포함한 하위 xid의 부모 모두에게 non-virtual 트랜잭션 ID가 할당되며, 부모 xid가 자식 xid보다 항상 낮도록 유지한다.\n각 subxid의 바로 윗 부모 xid는 pg_subtrans디렉터리에 기록된다. 최상위 xid의 경우 부모 트랜잭션이 없기에 기록되지 않으며 읽기 전용 하위 트랜잭션에 대해서도 기록하지 않는다. 서브 트랜잭션이 커밋되면, subxid에 포함된 모든 하위 트랜잭션도 해당 트랜잭션에서 임시로 commit 된 것으로 고려된다. 서브 트랜잭션이 취소되면 모든 자신의 서브 트랜잭션도 취소된다. 최상위 트랜잭션의 xid가 커밋되면, 모든 하위 트랜잭션의 임시 커밋들이 pg_xact 디렉터리에 기록된다. 최상위 트랜잭션이 취소되면, 임시 커밋된 트랜잭션을 포함한 모든 서브 트랜잭션이 또한 취소된다. 각 트랜잭션이 서브트랜잭션을 많이 열어둘수록 트랜잭션 관리 오버해드가 증가한다. 각 백앤드마다 서브트랜잭션을 64개까지는 공유메모리에 캐시 하지만, 그 후로는 pg_subtrans의 subxid를 추가로 찾으면서 저장소 I/O 오버헤드가 극도로 증가한다. 5. 2단계 트랜잭션 (Two-Phase Transactions) PostgreSQL은 two-phase commit (2PC) 프로토콜을 지원한다. 다수의 분산 시스템 환경에서 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜로 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을 보장한다.\n(해당 내용은 PREPARE 구문의 상세 내용과 함께 다음 포스트에서 정리할 예정) 참고\nhttps://www.postgresql.org/docs/16/routine-vacuuming.html\nhttps://www.postgresql.org/docs/16/view-pg-prepared-xacts.html\nhttps://www.postgresql.org/docs/16/two-phase.html\nhttps://www.postgresql.org/docs/16/subxacts.html\nhttps://www.postgresql.org/docs/16/xact-locking.html\nhttps://www.postgresql.org/docs/16/transaction-id.html\n","wordCount":"807","inLanguage":"en","datePublished":"2024-03-08T15:27:32Z","dateModified":"2024-03-08T15:27:32Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/67/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://junhkang.com/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[PostgreSQL] 트랜잭션(Transaction)의 작동원리</h1><div class=post-meta><span title='2024-03-08 15:27:32 +0000 UTC'>March 8, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p> </p><p><img loading=lazy src=/images/posts/67/img.png></p><h2 id=기본-트랜잭션의-개념-및-원리 ke-size=size26>1. 기본 트랜잭션의 개념 및 원리<a hidden class=anchor aria-hidden=true href=#기본-트랜잭션의-개념-및-원리>#</a></h2><p>트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.</p><p><a href=https://junhkang.tistory.com/20>[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용</a></p><p>기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.</p><h2 id=트랜잭션과-식별자-transactions-and-identifiers ke-size=size26>2. 트랜잭션과 식별자 (Transactions and Identifiers)<a hidden class=anchor aria-hidden=true href=#트랜잭션과-식별자-transactions-and-identifiers>#</a></h2><p>기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자.</p><p><img loading=lazy src=/images/posts/67/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-08%20%EC%98%A4%ED%9B%84%201.43.08.png></p><h3 id=virtual-transaction-id ke-size=size23>2-1. Virtual Transaction Id<a hidden class=anchor aria-hidden=true href=#virtual-transaction-id>#</a></h3><p>모든 트랜잭션은 유니크한 <strong>Virtual Transaction Id</strong>(virtualXID, vxid)로 식별된다. 이 <strong>Virtual Transaction Id</strong>는 <strong>Backend ID</strong>와 각 백앤드에 순차적으로 부여된 로컬 아이디 (<strong>LocalXID</strong>)로 구성되어 있다. 캡처의 virtualxid를 확인해 보면 다음과 같다.</p><ul><li>Virtual Transaction ID = 115/10798</li><li>Backend Id = 115</li><li>LocalXID = 10798</li></ul><h3 id=non-virtual-transactionids ke-size=size23>2-2. Non-Virtual TransactionIds<a hidden class=anchor aria-hidden=true href=#non-virtual-transactionids>#</a></h3><p>그 외 가상이 아닌 <strong>Non-Virtual TransactionIds</strong>(or xid) (캡처의 transactionId = 114016445)들은 PostgreSQL 클러스터의 모든 데이터베이스에서 공통으로 사용하는 global counter를 순차적으로 사용한다. 
 </p><p>이러한 TransactionID는 트랜잭션이 처음 데이터베이스에 write 할 때 적용되며, xids가 낮을수록 먼저 수행된 트랜잭션임을 의미한다. 하지만 트랜잭션이 처음 데이터베이스 write를 실행한 순서와 트랜잭션이 시작된 순서는 다를 수 있다. 특히 트랜잭션이 데이터베이스를 read만으로 시작할 때 그렇다.
 </p><p>각 xid는 32비트이고 20억 건의 트랜잭션마다 wraps around 한다.</p><blockquote><p><strong>wraps around</strong> - 트랜잭션 번호가 40억 건이 넘으면 0에서부터 다시 시작하며, 중복된 트랜잭션이 부여될 수 있다. 이 경우 데이터는 존재하지만 접근하지 못하는 데이터가 발생하며, 치명적인 데이터 손실로 이어질 수 있다. 이를 방지하기 위해 20억 트랜잭션이 일어날 때마다 모든 데이터베이스, 모든 테이블에 최소 1번의 vacuum을 실행한다. 
 </p></blockquote><p>해당 내용에서 트랜잭션의 40억 건이 넘으면 0부터 다시 실행되는데 왜 40억이 아닌 20억 트랜잭션마다 최소 1번의 Vacuum이 일어날까? 에 대한 궁금증이 들어 PostgreSQL 측에 문의하였고, PostgreSQL 측 공식 답변은 다음과 같다.</p><blockquote><p>트랜잭션 ID를 "순환 카운터(Circular Counter)"로 취급하기 때문이다. 특정 트랜잭션 (A)와 트랜잭션 (B)를 비교할 때 (A의 트랜잭션 ID-B의 트랜잭션 ID)의 연산 후 부호를 포함한 정수로 연산을 한다. 만약 결과가 음수라면 A가 더 최근 트랜잭션이고, 공간이 순환적이고 서로 다른 트랜잭션 A, B의 ID가 다를 수 없기에 부호를 가진 정수로써 모두 표현이 가능하다. \</p><p>순환 공간에서는 1G(10억 건의 트랜잭션)이 3G보다 이전에 있을 수도 있고, 이후에 있을 수도 있다. (1G가 3G의 이전 사이클에서 생성된 트랜잭션 ID인지, 이후 사이클에서 생성된 트랜잭션 ID인지 부호 없이는 구분이 불가능하다.)</p><p><strong>1.5G와 2.5G의 비교 :</strong> 1.5G는 2.5G보다 10억 트랜잭션 이전이므로, 부호 있는 비교에서는 1.5G는 2.5G보다 이전 트랜잭션
<strong>0.5G 와 3.5G 비교 :</strong> 순환 공간을 생각할 때 4G가 최대치인 상황에서 0.5G가 3.5G보다 이후로 간주된다. (0이 최대치(4G) 이후에 존재하기 때문) 그렇기 때문에 부호 있는 비교에서는 0.5G가 3.5G 이후로 판단됨.</p><p>그렇기 때문에 순환 카운터에서는 최대치(4G)의 절반인 2G 트랜잭션 제한을 통해 +/-2G의 범위 내에서 트랜잭션 ID의 &ldquo;전후&rdquo; 관계를 파악한다.
 </p></blockquote><p> </p><p>매 wraps around 마다  32bit epoch가 증가하며 64비트의 xid8 유형도 존재한다. (pg_current_xact_id[ () → 로 현재 xid8 조회 가능]{style=&ldquo;background-color: #ffffff; color: #212529; text-align: left;&rdquo;}) Xid들은 PostgreSQL의 MVCC의 동시성, 및 스트리밍 복제의 근간으로 사용된다. 최상위 트랜잭션의 non-virtual xid가 커밋되면, <strong>pg_xact</strong> 디렉터리에 커밋으로 기록되며 추가 정보들은 <strong>pg_commit_ts</strong> 디렉터리에 기록된다. (track_commit_timestamp가 활성화 필요) virtual xid, non-virtual xid에, PREPARED TRANSACTION의  경우에는 Global Transaction Identifiers(GID)가 추가로 부여된다. GID는 200바이트의 문자열로 현재의 다른 PREPARED TRANSACTION과 중복되지 않아야 한다. (GID와 xid의 매핑관계는 <strong>pg_prepared_xacts</strong>에서 확인가능하다.)</p><h2 id=트랜잭션과-락-transactions-and-locking ke-size=size26>3. 트랜잭션과 락 (Transactions and Locking)<a hidden class=anchor aria-hidden=true href=#트랜잭션과-락-transactions-and-locking>#</a></h2><p>현재 진행 중인 트랜잭션의 Transaction ID는 pg_locks의 virtualxid와 transactionId 칼럼에서 확인할 수 있다.</p><pre tabindex=0><code>SELECT LOCKTYPE, VIRTUALXID, TRANSACTIONID FROM PG_LOCKS;
</code></pre><p>두 칼럼 모두 read/write 트랜잭션에 존재하지만 Read-only 트랜잭션에는 virtualxid는 있으나 transactionId는 null이다. </p><p><img loading=lazy src=/images/posts/67/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-08%20%EC%98%A4%ED%9B%84%201.42.57.png></p><p>READ만 수행한 트랜잭션</p><p><img loading=lazy src=/images/posts/67/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-08%20%EC%98%A4%ED%9B%84%201_1.43></p><p>Read/Write를 모두 실행한 트랜잭션</p><p>Row-level의 read/write locks는 잠긴 row에 바로 기록되며 pgrowlocks extension을 통해 확인 가능하다.</p><h2 id=서브트랜잭션-subtransactions ke-size=size26>4. 서브트랜잭션 (Subtransactions)<a hidden class=anchor aria-hidden=true href=#서브트랜잭션-subtransactions>#</a></h2><p>서브 트랜잭션(Subtransactions, subxact)은 트랜잭션 안에서 시작되며 큰 트랜잭션을 더 작은 트랜잭션 단위로 분리할 수 있게 해 준다. 서브 트랜잭션은 부모 트랜잭션이 영향을 받지 않고 계속 진행되게 한 채로 commit 혹은 rollback 할 수 있다. 서브 트랜잭션은 SAVEPOINT라는 커맨드로 명시적 실행이 가능하지만 PL/pgSQL의 Exception 구문으로도 실행 가능하다. 서브트랜잭션은 다른 서브트랜잭션으로부터도 시작 가능하다. 최상위 트랜잭션과 그 자식 서브트랜잭션은 계층구조 혹은 트리 구조를 형성하며 그렇기 때문에 메인 트랜잭션을 top-level 트랜잭션이라고 한다.
 </p><p>서브트랜잭션이 non-virtual TransactionalId를 할당받았다면, 그 트랜잭션아이디는 subxid라고 한다. Read-only 서브트랜잭션은 subxids가 부여되지 않지만 write를 하려고 하는 순간 1개를 부여받는다. 또한 상위 레벨 트랜잭션을 포함한 하위 xid의 부모 모두에게 non-virtual 트랜잭션 ID가 할당되며, 부모 xid가 자식 xid보다 항상 낮도록 유지한다.</p><ul><li>각 subxid의 바로 윗 부모 xid는 pg_subtrans디렉터리에 기록된다. 최상위 xid의 경우 부모 트랜잭션이 없기에 기록되지 않으며 읽기 전용 하위 트랜잭션에 대해서도 기록하지 않는다.</li><li>서브 트랜잭션이 커밋되면, subxid에 포함된 모든 하위 트랜잭션도 해당 트랜잭션에서 임시로 commit 된 것으로 고려된다. 서브 트랜잭션이 취소되면 모든 자신의 서브 트랜잭션도 취소된다.</li><li>최상위 트랜잭션의 xid가 커밋되면, 모든 하위 트랜잭션의 임시 커밋들이 pg_xact 디렉터리에 기록된다. 최상위 트랜잭션이 취소되면, 임시 커밋된 트랜잭션을 포함한 모든 서브 트랜잭션이 또한 취소된다.</li><li>각 트랜잭션이 서브트랜잭션을 많이 열어둘수록 트랜잭션 관리 오버해드가 증가한다. 각 백앤드마다 서브트랜잭션을 64개까지는 공유메모리에 캐시 하지만, 그 후로는 pg_subtrans의 subxid를 추가로 찾으면서 저장소 I/O 오버헤드가 극도로 증가한다. </li></ul><h2 id=단계-트랜잭션-two-phase-transactions ke-size=size26>5. 2단계 트랜잭션 (Two-Phase Transactions)<a hidden class=anchor aria-hidden=true href=#단계-트랜잭션-two-phase-transactions>#</a></h2><p>PostgreSQL은 two-phase commit (2PC) 프로토콜을 지원한다. 다수의 분산 시스템 환경에서 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜로 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을 보장한다.</p><p>(해당 내용은 PREPARE 구문의 상세 내용과 함께 다음 포스트에서 정리할 예정)
 </p><p> </p><p> </p><p>참고</p><ul><li><p><a href=https://www.postgresql.org/docs/16/routine-vacuuming.html>https://www.postgresql.org/docs/16/routine-vacuuming.html</a></p></li><li><p><a href=https://www.postgresql.org/docs/16/view-pg-prepared-xacts.html>https://www.postgresql.org/docs/16/view-pg-prepared-xacts.html</a></p></li><li><p><a href=https://www.postgresql.org/docs/16/two-phase.html>https://www.postgresql.org/docs/16/two-phase.html</a></p></li><li><p><a href=https://www.postgresql.org/docs/16/subxacts.html>https://www.postgresql.org/docs/16/subxacts.html</a></p></li><li><p><a href=https://www.postgresql.org/docs/16/xact-locking.html>https://www.postgresql.org/docs/16/xact-locking.html</a></p></li><li><p><a href=https://www.postgresql.org/docs/16/transaction-id.html>https://www.postgresql.org/docs/16/transaction-id.html</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/transaction/>Transaction</a></li><li><a href=https://junhkang.com/tags/postgresql/>PostgreSQL</a></li></ul></footer><div class=giscus><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>