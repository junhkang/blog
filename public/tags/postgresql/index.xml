<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>PostgreSQL on Jun Kang&#39;s Blog</title>
    <link>http://localhost:1313/tags/postgresql/</link>
    <description>Recent content in PostgreSQL on Jun Kang&#39;s Blog</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>ko</language>
    <lastBuildDate>Wed, 14 Aug 2024 17:49:46 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/postgresql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[PostgreSQL] RDS 쿼리 성능 분석 방법 : pg_stat_statements 설치, 고려사항 및 주요 지표</title>
      <link>http://localhost:1313/posts/94/</link>
      <pubDate>Wed, 14 Aug 2024 17:49:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/94/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;rds에서의-쿼리-성능-분석-pg_stat_statements란&#34; ke-size=&#34;size26&#34;&gt;1. RDS에서의 쿼리 성능 분석, pg_stat_statements란?&lt;/h2&gt;
&lt;p&gt;RDS에서는 외부 익스텐션 사용이 제한된다. 쿼리 통계 및 성능에 대한 지표를 알 수 있는 여러 가지 익스텐션이 있지만, 그중 pg_stat_statements가 허용된다. pg_stat_statements의 원리, 사용법, 주요 지표에 대해 알아보자.
 &lt;/p&gt;
&lt;p&gt;pg_stat_statements는 실행된 쿼리에 대한 통계를 수집하고 저장한다. 다음은 저장되는 주요 지표들이고, 이를 통해 쿼리 성능을 분석하고 최적화할 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿼리빈도&lt;/li&gt;
&lt;li&gt;쿼리 실행시간&lt;/li&gt;
&lt;li&gt;쿼리 리소스 사용량 (CPU, 디스크I/O, 버퍼 히트 등)&lt;/li&gt;
&lt;li&gt;쿼리 텍스트 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설치&#34; ke-size=&#34;size26&#34;&gt;2. 설치 &lt;/h2&gt;
&lt;p&gt;설치가 되어있지않다면 익스텐션을 먼저 설치하면 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 문자열에서 날짜/시간 변환 및 처리 과정</title>
      <link>http://localhost:1313/posts/88/</link>
      <pubDate>Thu, 02 May 2024 17:53:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/88/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;문자열에서-날짜시간으로의-변환&#34; ke-size=&#34;size26&#34;&gt;1. 문자열에서 날짜/시간으로의 변환&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 날짜형태의 칼럼을 조회할 때, 종종 정확한 날짜 형태를 사용하는 것이 아닌, 문자열, 혹은 숫자 형태로 간편하게 조회하는 경우가 있다. 예를 들어 2024/05/02 이후의 값을 조회할 때 다음 두 가지 조회 방법을 사용할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;date_column &amp;gt; &#39;20240502&#39;&lt;br&gt;
date_column &amp;gt; TO_DATE(&#39;20240502&#39;, &#39;YYYYMMDD&#39;)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;예제와 같이 PostgreSQL은 일련의 문자/숫자열을 조건에 맞는 날짜형으로 자동으로 디코딩을 해주는데,  문자열을 인식하는 상세 과정을 순서대로 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;문자열에서-날짜시간으로의-디코딩-과정&#34; ke-size=&#34;size26&#34;&gt;2. 문자열에서 날짜/시간으로의 디코딩 과정&lt;/h2&gt;
&lt;h3 id=&#34;문자열을-토큰으로-분리하고-각-토큰을-시간-시간대-또는-숫자로-분류한다.&#34; ke-size=&#34;size23&#34;&gt;2-1. 문자열을 토큰으로 분리하고 각 토큰을 시간, 시간대, 또는 숫자로 분류한다.&lt;/h3&gt;
&lt;p&gt;예제들에서는 정상적으로 날짜 및 시간이 변환되는지 확인하기 위해 강제로 TIMESTAMP 및 DATE로 형 변환을 하였지만, 날짜 형태의 데이터와 문자열 그대로를 비교하여도 날짜 및 시간 비교가 가능하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 버전 확인: 필요성과 4가지 방법</title>
      <link>http://localhost:1313/posts/85/</link>
      <pubDate>Thu, 11 Apr 2024 13:31:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/85/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;버전-확인이-왜-필요한가&#34; ke-size=&#34;size26&#34;&gt;1. 버전 확인이 왜 필요한가&lt;/h2&gt;
&lt;p&gt;PostgreSQL를 안정적으로 운영하기 위해서는 보안 패치와 업데이트를 최신 상태로 유지하는 것이 중요하다. 또한 특정 기능이나 호환성 요구 사항을 충족하기 위해서도 버전 정보를 알고 있어야 한다. 이를 위해 현재 버전 및 공식 문서의 버전 관리 내용을 주기적으로 확인해주어야 한다. &lt;/p&gt;
&lt;h2 id=&#34;postgresql-버전-확인-방법&#34; ke-size=&#34;size26&#34;&gt;2. PostgreSQL 버전 확인 방법&lt;/h2&gt;
&lt;h3 id=&#34;sql-쿼리-실행-version&#34; ke-size=&#34;size23&#34;&gt;2-1. SQL 쿼리 실행: VERSION()&lt;/h3&gt;
&lt;p&gt;PostgreSQL 쿼리로 가장 간단하게 버전 정보를 얻을 수 있는 방법이다. 서버의 버전정보를 포함한 상세정보를 확인할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] UNION, INTERSECT, EXCEPT, SQL 쿼리 결합의 개념, 사용법 및 주의사항</title>
      <link>http://localhost:1313/posts/83/</link>
      <pubDate>Mon, 08 Apr 2024 16:04:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/83/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;union-intersect-except를-통한-쿼리-결합&#34; ke-size=&#34;size26&#34;&gt;1. UNION, INTERSECT, EXCEPT를 통한 쿼리 결합&lt;/h2&gt;
&lt;p&gt;UNION(결합), INTERSECT(교차), EXCEPT(차이) 구문을 통해 두 쿼리의 결과를 결합할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;query1 UNION [ALL] query2
query1 INTERSECT [ALL] query2
query1 EXCEPT [ALL] query2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;해당 구문들을 실행시키기 위해서는 query1, query2가 동일한 개수, 동일한 type의 칼럼을 리턴해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;union&#34; ke-size=&#34;size26&#34;&gt;2. UNION&lt;/h2&gt;
&lt;p&gt;query2의 결과를 query1에 이어 붙인다. 그냥 사용할 경우 중복을 제거하여 distinct와 같은 효과를 볼 수 있으며, UNION ALL을 사용하면 중복을 포함하여 쿼리를 합친다.&lt;/p&gt;
&lt;h3 id=&#34;union-단일-사용&#34; ke-size=&#34;size23&#34;&gt;2-1. UNION 단일 사용&lt;/h3&gt;
&lt;p&gt;1~5 번째 ROWS, 4~8번째 ROWS를 합친 후 중복 제거한 결과를 보면 다음과 같다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Visibility Map(가시성 맵)의 개념, 원리, 생명주기 및 정보 확인 방법</title>
      <link>http://localhost:1313/posts/79/</link>
      <pubDate>Thu, 28 Mar 2024 15:54:02 +0000</pubDate>
      <guid>http://localhost:1313/posts/79/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/79/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;visibility-map가시성-맵란&#34; ke-size=&#34;size26&#34;&gt;1. Visibility Map(가시성 맵)란?&lt;/h2&gt;
&lt;p&gt;Visibility Map은 트랜잭션에서 데이터에 접근할 때 어떤 데이터가 가시적인지(&lt;strong&gt;모든 트랜잭션에서 읽을 수 있는지&lt;/strong&gt;), 안정적인지 (&lt;strong&gt;동결된 튜플인지&lt;/strong&gt;) 판별하는데 도움을 준다. 데이터 접근 시 불필요한 I/O작업을 줄여주고, 데이터베이스가 어떤 페이지를 직접 접근할 수 있는지를 빠르게 판단함으로써 시스템의 효율적을 올려주는 역할을 한다.&lt;/p&gt;
&lt;h2 id=&#34;visibility-map가시성-맵의-데이터-관리&#34; ke-size=&#34;size26&#34;&gt;2. Visibility Map(가시성 맵)의 데이터 관리&lt;/h2&gt;
&lt;p&gt;Visibility Map은 데이터를 주요 데이터와는 별도의 파일(fork)에 _vm 접미사를 붙여 관리한다. 예를 들어 예를 들어 employees 테이블이 있다고 하면 테이블의 Visibility Map은 별도의 포크에 저장된다. 이 포크의 이름은 파일 노드 번호에 _vm 접미사를 붙여 구성되며, 예를 들어 파일 노드번호가 12345인 경우 VM 파일은 12345_vm으로 저장된다. 데이터에는 해당 테이블의 page가 모든 트랜잭션에 보이는지, 동결된 튜플만을 포함하는지 등의 정보를 저장한다. 데이터베이스가 employees 테이블을 조회할 때, 가시성 맵을 먼저 확인한다. 만약 쿼리가 접근하려는 pages가 모든 트랜잭션에게 보이는 상태라고 확인되면, 시스템은 데이터에 더 빠르게 접근한다. 불필요한 버전검사나 락을 안 해도 되기에 성능이 향상된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] TOAST (The Oversized-Attribute Storage Technique)의 개념, PostgreSQL의 대용량 속성 저장 기법</title>
      <link>http://localhost:1313/posts/75/</link>
      <pubDate>Sat, 23 Mar 2024 21:01:58 +0000</pubDate>
      <guid>http://localhost:1313/posts/75/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/75/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;toast-the-oversized-attribute-storage-technique란&#34; ke-size=&#34;size26&#34;&gt;1. TOAST (The Oversized-Attribute Storage Technique)란?&lt;/h2&gt;
&lt;p&gt;데이터베이스의 대용량 속성을 효율적으로 저장하고 관리하기 위한 기법으로, 데이터를 효율적으로 처리하고, 저장공간을 최적화하며 데이터 접근시간을 개선하기 위해 사용된다. PostgreSQL의 각 page영역은 일반적으로 8kb의 고정된 크기로 되어있고 각 tuple이 여러 페이지에 나뉘어 존재할 수 없다. (매우 큰 값을 바로 저장할 수 없다.) 이 한계를 극복하기 위해서, 큰 필드 값은 압축되어 저장되거나 여러 개의 물리적 ROWS로 분할되어 저장된다. 이 과정은 보통 개발자가 별도의 처리로직을 구현할 필요 없이 데이터베이스 백앤드에서 자동으로 이루어진다. 이 기법을 TOAST (The Oversized-Attribute Storage Technique)라고 하며 PostgreSQL에서 큰 데이터 값을 메모리 내에서 효율적으로 처리하는 데에 사용된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] DISK(디스크) 사용량 모니터링</title>
      <link>http://localhost:1313/posts/74/</link>
      <pubDate>Tue, 19 Mar 2024 16:31:20 +0000</pubDate>
      <guid>http://localhost:1313/posts/74/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;disk-영역&#34; ke-size=&#34;size26&#34;&gt;1. Disk 영역&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 저장 영역은 크게 Heap, Index, Toast 3개로 나뉜다. 각 테이블의 대부분의 데이터를 메인 heap 영역에 저장한고, 테이블 칼럼 중 매우 큰 데이터를 받을 수 있는 칼럼은 TOAST 영역에 별도 저장한다. TOAST 테이블에는 실제 데이터를 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. TOAST 테이블의 유효한 인덱스는 1개뿐이고, 기준 테이블에는 더 많은 인덱스가 존재할 수 있다. 테이블과 인덱스는 각각의 디스크파일에 저장 되며 각 파일이 1G가 넘으면 별도 파일로 분리된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] PostgreSQL의 물리적 한계치</title>
      <link>http://localhost:1313/posts/72/</link>
      <pubDate>Mon, 18 Mar 2024 15:00:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/72/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/72/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postresql의-물리적-한계치&#34; ke-size=&#34;size26&#34;&gt;1. PostreSQL의 물리적 한계치&lt;/h2&gt;
&lt;p&gt;물론 사용 가능한 disk 용량, 성능 이슈 등 실직적인 제한이 먼저 적용되겠지만, 모든 자원이 충분하다고 가정할 때 물리적인 limit이다.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;항목&lt;/th&gt;
          &lt;th&gt;최대치&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 사이즈&lt;/td&gt;
          &lt;td&gt;무제한&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 수량&lt;/td&gt;
          &lt;td&gt;4,294,950,911&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터베이스 당 Relations(테이블, 뷰, 인덱스 등의 테이블 객체)수량 &lt;/td&gt;
          &lt;td&gt;1,431,650,303&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Relations 사이즈&lt;/td&gt;
          &lt;td&gt;32TB &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 ROW 수량&lt;/td&gt;
          &lt;td&gt;4,294,967,295 pages영역의 크기에 해당하는 ROW&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 COL 수량&lt;/td&gt;
          &lt;td&gt;1,600&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;결과셋의 COL 수량&lt;/td&gt;
          &lt;td&gt;1,664&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;COL 사이즈&lt;/td&gt;
          &lt;td&gt;1GB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;테이블 당 인덱스 수량&lt;/td&gt;
          &lt;td&gt;무제한&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;인덱스 당 컬럼&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;파티션 키&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;식별자 키 (ex, 테이블, ROW, COL 등의 명칭)&lt;/td&gt;
          &lt;td&gt;63 bytes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;function의 매개변수&lt;/td&gt;
          &lt;td&gt;100&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;쿼리파라미터&lt;/td&gt;
          &lt;td&gt;65,535&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;테이블당 ROW 수량은 4,294,967,295개의 pages 영역에 저장 가능한 ROWS로 제한되어 있는데, 4,294,967,295는 2^32 - 1로 32비트 시스템에서 사용가능한 최대 정수이다.  데이터베이스에서 최대로 관리할 수 있는 pages의 수며, 각 페이지에는 여러 튜플이 저장될 수 있다.&lt;/li&gt;
&lt;li&gt;테이블 당 인덱스의 수량은 이론상은 &amp;ldquo;무제한&amp;quot;이제만, 실제로는 데이터베이스가 관리할 수 있는 최대 Relations (테이블, 뷰, 인덱스 등의 테이블 객체)에 의해 제한된다. &lt;/li&gt;
&lt;li&gt;위 표의 인덱스 당 칼럼 수, 파티션 키 수량, 식별자 키, 함수 매개변수 최대 수량은 기본값이며 설정값을 변경하여 증가시킬 수 있다.&lt;/li&gt;
&lt;li&gt;테이블 당 최대 칼럼 수는 1600개이지만, 저장되는 튜플이 8192바이트의 힙 페이지에 fit 해야 한다는 조건 때문에 더 줄어들 수 있다. 예를 들어 튜플 헤더를 제외하고,
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1600개의 int칼럼 투플 -&lt;/strong&gt; 6400 bytes로 힙페이지에 정상 저장 가능 (6400 &amp;lt; 8192)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1600의 bigint칼럼 투플 -&lt;/strong&gt; 12800 bytes로 heap page를 초과 (12800 &amp;lt; 8192)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;text, varchar, char같이 길이 변경이 가능한 필드의 경우 값이 크면 TOAST 테이블 영역이라 불리는 주 저장공간 외부영역에 값을 저장하고, 본래 테이블에는 해당 데이터를 가리키는 포인터만 남게 된다. &lt;/li&gt;
&lt;li&gt;테이블에서 삭제된 칼럼들도 최대 칼럼 개수에 포함된다. &lt;/li&gt;
&lt;li&gt;삭제된 칼럼에 대해 새로 생성된 ROW도 내부적으로는 null 표시되지만, 추적을 위해 여전히 공간을 차지하여 최대 개수에 영향을 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론&#34; ke-size=&#34;size26&#34;&gt;2. 결론&lt;/h2&gt;
&lt;p&gt;운영 단계에서 1억 개 이상의 테이블을 생성하거나 1000개가 넘는 칼럼의 테이블을 생성하는 일은 없을 것이고, 이러한 물리적 제약보다 자원의 한계 (용량 및 성능이슈)를 먼저 만날 것이기에 정확한 수치를 정확히 외울 필요는 없겠지만, 삭제된 칼럼들과 그 이후 생성된 ROW들이 내부적으로는 추적을 위해 해당 컬럼을 NULL로 저장하며, 이 과정에서 사용되는 NULL비트맵이 공간을 차지하기에 최대 카운트에 영향을 준다는 것 운영 시에 유의해야 할 내용이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Index-Only 스캔과 Covering 인덱스, Index-only스캔의 효율적인 사용</title>
      <link>http://localhost:1313/posts/70/</link>
      <pubDate>Wed, 13 Mar 2024 18:52:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/70/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;1-index-only-scans&#34;&gt;1. Index-Only Scans&lt;/h2&gt;
&lt;p&gt;PostgreSQL의 모든 인덱스는 &lt;strong&gt;&amp;quot;보조(Secondary)&amp;quot;&lt;/strong&gt; 인덱스이다. 각 인덱스는 테이블의 메인 데이터 영역(테이블의 &lt;strong&gt;heap&lt;/strong&gt; 영역)과 분리되어서 저장된다. 그렇기 때문에 일반적인 인덱스 스캔에서 각 ROW를 찾기 위해서는, index와 heap 영역 모두에 접근하여 데이터를 탐색해야 한다. 보통 WHERE 절 조건에 부합하는 데이터들은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인덱스 영역 -&lt;/strong&gt; 서로 가까이 존재하여 정렬된 순서로 빠르게 접근할 수 있다. (인덱스 테이블은 정렬된 상태로 생성)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap 영역 -&lt;/strong&gt;  특별한 규칙 없이 어디에서든 분포할 수 있기에 heap 영역을 스캔할 때는 무작위로 접근하게 되어 속도가 느리다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 퍼포먼스 문제를 해결하기 위해 PostgreSQL은 힙 영역에 대한 접근 없이 인덱스 내에서만 데이터를 조회하는 &lt;strong&gt;Index-only&lt;/strong&gt; 스캔을 지원한다. 기본 개념은 말 그대로 heap 영역의 참조 없이 index 항목에서 바로 값을 반환하는 것으로 매우 효율적으로 보이지만 몇 가지 제한사항이 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 인덱스(INDEX)와 오더바이(ORDER BY), ORDER BY 성능개선, 효율적인 인덱스 적용</title>
      <link>http://localhost:1313/posts/69/</link>
      <pubDate>Tue, 12 Mar 2024 18:59:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/69/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;인덱스index와-오더바이order-by&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스(INDEX)와 오더바이(ORDER BY)&lt;/h2&gt;
&lt;p&gt;인덱스는 쿼리의 결과로 특정 row를 찾는 것뿐만 아니라, 특정 순서로 데이터를 정렬하는데도 효율적일 수 있다. ORDER BY와 인덱스를 효율적으로 사용하면 별도의 정렬 과정 없이 ORDER BY를 수행할 수 있다. PostgreSQL에서 현재 지원하는 인덱스 타입 중에서는 B-tree 인덱스만이 정렬 결과로 인덱스를 생성할 수 있다. 다른 인덱스 유형은 특정되지 않은 순서로, 실행 때마다 다른 순서로 열을 반환한다.&lt;/p&gt;
&lt;p&gt;* 상세한 B-tree 인덱스의 개념은 다음 글을 참고 - &lt;a href=&#34;https://junhkang.tistory.com/6&#34;&gt;[Postgresql] - [PostgreSQL] B-tree 인덱스의 원리 및 특징&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 2단계 커밋 프로토콜(Two-Phase Commit Protocol), Prepare transaction</title>
      <link>http://localhost:1313/posts/68/</link>
      <pubDate>Fri, 08 Mar 2024 16:26:45 +0000</pubDate>
      <guid>http://localhost:1313/posts/68/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/68/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;단계-커밋-프로토콜two-phase-commit-2pc&#34; ke-size=&#34;size26&#34;&gt;1. 2단계 커밋 프로토콜([two-phase commit (2PC))&lt;/h2&gt;
&lt;p&gt;PostgreSQL은 two-phase commit (2PC) 프로토콜을 지원한다. 다수의 분산 시스템 환경에서 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜로 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을 보장한다. PostgreSQL의 2단계 트랜잭션은 외부 트랜잭션 관리 시스템에서 사용하기 위해 존재하며 X/Open XA 표준에서 제안된 특징과 모델을 따른다. (사용빈도가 낮은 일부 기능은 구현되지 않았다.) 2단계 커밋은 다음 스탭에 따라 작동된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Coordinator                                         Cohort
                              QUERY TO COMMIT
                --------------------------------&amp;gt;
                              VOTE YES/NO           prepare*/abort*
                &amp;lt;-------------------------------
commit*/abort*                COMMIT/ROLLBACK
                --------------------------------&amp;gt;
                              ACKNOWLEDGMENT        commit*/abort*
                &amp;lt;--------------------------------  
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 트랜잭션(Transaction)의 작동원리</title>
      <link>http://localhost:1313/posts/67/</link>
      <pubDate>Fri, 08 Mar 2024 15:27:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/67/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/67/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;기본-트랜잭션의-개념-및-원리&#34; ke-size=&#34;size26&#34;&gt;1. 기본 트랜잭션의 개념 및 원리&lt;/h2&gt;
&lt;p&gt;트랜잭션의 기본 개념과 사용 방법은 다음 포스트에서 확인이 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/20&#34;&gt;[Postgresql] - [PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 트랜잭션이 어떤 것인지, COMMIT, ROLLBACK도 익숙하게 사용하고 있다면, PostgreSQL 내부의 트랜잭션이 어떤 구조로 작동하며 세부 단계를 어떻게 확인 가능한지 자세히 알아보자.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션과-식별자-transactions-and-identifiers&#34; ke-size=&#34;size26&#34;&gt;2. 트랜잭션과 식별자 (Transactions and Identifiers)&lt;/h2&gt;
&lt;p&gt;기본 개념에서 확인했듯이 트랜잭션은 명시적으로 실행(BEGIN, START TRANSACTION), 종료 (COMMIT, ROLLBACK) 할 수 있다. 명시적 트랜잭션 외의 SQL 구문들은 단일 트랜잭션이 자동으로 적용된다. 그렇다면 각각의 트랜잭션이 어떻게 구분되는지 먼저 살펴보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)의 개념 및 장단점</title>
      <link>http://localhost:1313/posts/66/</link>
      <pubDate>Mon, 26 Feb 2024 18:04:32 +0000</pubDate>
      <guid>http://localhost:1313/posts/66/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/66/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;wal-write-ahead-logging-아카이브-모드-백업archive-mode-backup이란&#34; ke-size=&#34;size26&#34;&gt;1. WAL (Write-Ahead Logging) / 아카이브 모드 백업(Archive mode backup)이란?&lt;/h2&gt;
&lt;p&gt;아카이브 모드 백업을 이해하기 위해 WAL에 대한 개념을 먼저 살펴보자. WAL은 PostgreSQL에서 데이터의 무결성을 보장하는 표준 방법으로, 기본 콘셉트는 모든 데이터의 변경을 로깅 완료 후에 실행하는 것이다. WAL 기록을 영구적인 저장소에 먼저 기록한 후에 데이터의 변경 내용을 실행하는 것으로, 이 과정을 거치면 충돌 혹은 데이터에 문제가 있을 때 WAL 로깅 내용을 바탕으로 특정 시점으로 복구가 가능하여 데이터 무결성을 보장할 수 있다.
 &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 대량 데이터 인서트 시 성능 개선 및 주의 사항</title>
      <link>http://localhost:1313/posts/65/</link>
      <pubDate>Mon, 26 Feb 2024 14:31:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/65/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/65/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;대량-데이터-인서트-시-성능-개선&#34; ke-size=&#34;size26&#34;&gt;대량 데이터 인서트 시 성능 개선&lt;/h2&gt;
&lt;p&gt;최초 서비스 배포나 데이터 마이그레이션을 할 때 대량의 데이터를 한 번에 인서트 하는 경우가 있다. PostgreSQL 공식문서에서는 대량 인서트 시에 효율적으로 진행할 수 있는 방법을 제시해 준다. (대량 데이터를 인서트 할 때 효율적인 설정이지 데이터베이스 조회나 업데이트 등실제 운영 시에 사용할 방법은 아니다.)&lt;/p&gt;
&lt;h2 id=&#34;autocommit-옵션-해제&#34; style=&#34;color: #333333; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;1. Autocommit 옵션 해제&lt;/h2&gt;
&lt;p&gt;대량의 인서트 실행 시, Autocommit 옵션을 해제하고 한 트랜잭션에서 작업 후에 커밋을 진행해야 한다(일반적으로 SQL를 실행 시에 자동으로 시작 시 BEGIN, 끝날 때 COMMIT으로 트랜잭션 처리가 되지만, 확실히 되고 있는지 확인필요하다.). 대량 데이터 인서트의 각각을 별도로 commit 한다면, PostgreSQL은 인서트 되는 각 열에 대해 너무 많은 작업을 수행하게 된다. 또한 모든 인서트를 한 트랜잭션에 처리할 경우에는 한 INSERT가 실패할 경우 그 시점까지 인서트 된 모든 작업이 취소되기에 실패 작업에 대한 부분 보완 및 무결성을 고려하지 않아도 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 외래키(Foreign Keys) 개념, 사용법, 장단점, 적용검토</title>
      <link>http://localhost:1313/posts/64/</link>
      <pubDate>Thu, 22 Feb 2024 18:28:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/64/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/64/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;foreign-key-외래키란&#34; ke-size=&#34;size26&#34;&gt;1. Foreign Key 외래키란?&lt;/h2&gt;
&lt;p&gt;Foreign key constraint 외래키 제약은 특정 칼럼 혹은 칼럼들의 값이 다른 테이블의 특정 row와 매칭되어야 하는 제약조건이다. 이를 두 관련 테이블 사이의 참조 무결성 (referential integrity)를 유지한다고 말한다. 그렇게 복잡한 개념은 아니니 바로 사용법을 확인해 보도록 하자&lt;/p&gt;
&lt;h2 id=&#34;예제&#34; ke-size=&#34;size26&#34;&gt;2. 예제&lt;/h2&gt;
&lt;h3 id=&#34;기본-외래키foreign-keys-생성&#34; ke-size=&#34;size23&#34;&gt;2-1. 기본 외래키(Foreign Keys) 생성&lt;/h3&gt;
&lt;p&gt;products 테이블은 물품의 이름, 가격 정보 테이블이고, orders 테이블은 존재하는 물품 각각에 대한 순서 정보가 들어있는 테이블이다. orders, products 테이블의 product_no에 외래키 제약을 적용하는 예제이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 함수(Function)의 정의 및 상세 사용법 (다양한 예제)</title>
      <link>http://localhost:1313/posts/46/</link>
      <pubDate>Wed, 15 Nov 2023 17:12:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/46/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/46/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postgresql-function이란&#34; ke-size=&#34;size26&#34;&gt;1. PostgreSQL Function이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SQL 함수는 임의의 SQL문들을 실행하고 마지막 쿼리의 결과를 반환한다. 단순한 형태의 함수는 마지막 쿼리의 첫 번째 row가 리턴된다. (order by 를 사용하지 않는 경우 다중 row의 첫 번째 행은 별도 정의되지 않기에 결과 row가 매번 다를 수 있다.)&lt;/li&gt;
&lt;li&gt;마지막 쿼리가 row를 하나도 반환하지 않을 경우 null이 리턴된다.&lt;/li&gt;
&lt;li&gt;SQL 함수는 함수의 리턴 유형을 특정 타입의 집합 (SET)으로 선언하거나, 테이블로 선언하여 반환할 수 있다. 이 경우에는 마지막 쿼리의 모든 ROW가 리턴된다.&lt;/li&gt;
&lt;li&gt;SQL함수의 body는 세미콜론(;)으로 구분된 SQL구문의 집합이어야만 한다.&lt;/li&gt;
&lt;li&gt;마지막 구문 뒤의 세미콜론(;)은 생략하여도된다.&lt;/li&gt;
&lt;li&gt;함수가 void를 리턴하는 것으로 선언되지 않았다면, 마지막 구문은 반환절이 존재하는 select, insert, update, delete 여야만 한다.&lt;/li&gt;
&lt;li&gt;모든 종류의 SQL 언어의 명령 모음은 패키징 되어 함수로 정의될 수 있다.&lt;/li&gt;
&lt;li&gt;select쿼리 외에도 insert, update, delete, merge 등의 데이터 수정쿼리 및 기타 SQL을 포함할 수 있지만, 트랜잭션 제어 명령( ex. commit, savepoint) 및 vacutaion 등의 일부 유틸리티 명령은 사용할 수 없다.&lt;/li&gt;
&lt;li&gt;SQL이 작동은 하지만 특정 값을 리턴하지 않는 SQL 함수를 정의하고 싶다면, void를 리턴하는 것으로 정의할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;function-간단-예시&#34; ke-size=&#34;size23&#34;&gt;▶ 1-1. Function 간단 예시&lt;/h3&gt;
&lt;p&gt;다음은 emp 테이블에서 음수의 salary를 삭제하는 함수이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 명시적 JOIN 절로 플래너(Planner) 제어, 성능 향상</title>
      <link>http://localhost:1313/posts/44/</link>
      <pubDate>Wed, 08 Nov 2023 16:53:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/44/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/44/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;개요&#34; ke-size=&#34;size26&#34;&gt;1. 개요&lt;/h2&gt;
&lt;p&gt;PostgreSQL은 쿼리 Planner가 가장 효율적인 쿼리 플랜을 세워 쿼리를 실행시킨다. 이번 포스트는 쿼리 Planner가 플랜을 검색하는 과정을 의도적으로 제한하여 플랜 검색 시간을 단축시키는 방법에 대한 내용이다. 쿼리 선택지를 제한함으로써 시간을 줄이지만, 그만큼 모든 경우를 비교하는 것이기 아니라서 최고의 플랜을 찾을 수 없기에, 테이블 scan 방식 및 인덱스 등 쿼리의 작동방식을 명확히 이해한 후 설정이 필요하며, 설정전 성능비교, 설정 후의 데이터 증감에 따른 지속적인 모니터링이 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;플래너의-작동&#34; ke-size=&#34;size26&#34;&gt;2. 플래너의 작동&lt;/h2&gt;
&lt;h3 id=&#34;join&#34; ke-size=&#34;size23&#34;&gt;2-1. JOIN&lt;/h3&gt;
&lt;p&gt;Planner의 작동방식을 보기 위해 간단한 조인 쿼리를 확인해 보자&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 윈도우 함수(Window Functions)의 개념, 성능 및 사용법 (over, sum/rank/ntitle/cume_dist 등...)</title>
      <link>http://localhost:1313/posts/40/</link>
      <pubDate>Tue, 31 Oct 2023 13:58:57 +0000</pubDate>
      <guid>http://localhost:1313/posts/40/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/40/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;윈도우-함수-window-functions란&#34; ke-size=&#34;size26&#34;&gt;1. 윈도우 함수 (Window Functions)란?&lt;/h2&gt;
&lt;p&gt;윈도우 함수는 행과 행 간의 관계를 쉽게 정의하기 위해 만든 함수이다. 이 기능은 일반 집계함수의 연산과 유사하지만, 일반 집계함수가 행 각각을 단일 그룹화해서 출력하는 반면에, 윈도우 함수는 각각의 행들이 &lt;strong&gt;그룹화되지 않으며 별도의 ID&lt;/strong&gt;를 가진다. 그렇기에 윈도우 함수는 현재 row의 정보보다 더 많은 정보에 접근이 가능하다. 예를 들면 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;일반집계함수 :&lt;/strong&gt; COUNT() + GROUP BY-&amp;gt; 그룹별 1개의 행 출력 (그룹 개수만큼 출력, 자르기 + 집약)&lt;br&gt;
&lt;strong&gt;윈도우집계함수 :&lt;/strong&gt; COUNT() OVER (PARTITION BY) -&amp;gt; ID개수만큼 행 출력 (행의 개수가 줄어들지 않는다, 자르기)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 데이터베이스 상속(Inheritance)의 개념과 사용법 및 성능비교 (Inherits, Only)</title>
      <link>http://localhost:1313/posts/39/</link>
      <pubDate>Mon, 30 Oct 2023 18:22:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/39/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/39/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;데이터베이스-상속inheritance이란&#34; ke-size=&#34;size26&#34;&gt;1. 데이터베이스 상속(Inheritance)이란?&lt;/h2&gt;
&lt;p&gt;상속은 객체지향 데이터베이스의 개념 중 하나이다. PostgreSQL은 테이블 생성 시 하나 이상의 다른 테이블로부터의 상속 기능을 제공하며, 이를 잘 활용하면 데이터베이스 설계에 새로운 가능성들을 열어준다. 데이터뿐만 아니라 부모 테이블의 컬럼 속성 및 인덱스 등의 특징들도 자식 테이블로 상속되기에 상황에 따라 효율적인 설계가 가능하다.&lt;/p&gt;
&lt;h2 id=&#34;데이터베이스-상속inherits-방법&#34; ke-size=&#34;size26&#34;&gt;2.데이터베이스 상속(Inherits) 방법&lt;/h2&gt;
&lt;p&gt;다음 예제는 PostgreSQL 공식 문서의 예제이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Capitals -&lt;/strong&gt; 이름, 인구, 고도, 요약어를 포함한 수도의 정보가 포함된 테이블&lt;br&gt;
&lt;strong&gt;Cities -&lt;/strong&gt; 이름, 인구, 고도를 포함한 도시 정보가 포함된 테이블&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 날짜 형태 검증하기 (ERROR: date/time field value out of range)</title>
      <link>http://localhost:1313/posts/38/</link>
      <pubDate>Thu, 26 Oct 2023 14:11:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/38/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;![](![](/images/posts/38/img.png))&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;날짜-형태로-형변환&#34; ke-size=&#34;size26&#34;&gt;1. 날짜 형태로 형변환&lt;/h2&gt;
&lt;p&gt;데이터 베이스에서 날짜형태로 형 변환을 하는 것은 다음과 같은 방법으로 쉽게 가능하다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- Unix타임(int)형 변환
SELECT to_timestamp(1658792421)

-- varchar 타입 변환
SELECT to_timestamp(&amp;#39;20231026&amp;#39;,&amp;#39;yyyymmdd&amp;#39;)

-- 날짜형을 char로 변환
SELECT to_char(to_timestamp(1658792421), &amp;#39;DD-MM-YYYY&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[2. 유효한 날짜형태 검증]{style=&amp;ldquo;color: #000000; font-size: 1.62em; letter-spacing: -1px; font-family: -apple-system, BlinkMacSystemFont, &amp;lsquo;Helvetica Neue&amp;rsquo;, &amp;lsquo;Apple SD Gothic Neo&amp;rsquo;, Arial, sans-serif;&amp;rdquo;}&lt;/p&gt;
&lt;p&gt;데이터 정제가 완료되지 않아 조회하려는 데이터에 날짜유형에서 벗어난 데이터 [(&#39;20231301&#39;,202301&#39;, &#39;20231232&#39; 등)가]{style=&amp;ldquo;color: #333333; text-align: start;&amp;rdquo;} 하나라도 있을 경우 조회 자체가 안된다. 그럴 경우 날짜 규격에 맞지 않는 데이터를 보정 후 연산해야 하는 경우가 있는데 단순 월별 케이스문으로 분리하여 날짜 유형에 어긋나는 경우를 찾을 수도 있지만 row마다 날짜 유형이 다르거나 윤달을 체크할 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 쿼리 성능향상 (실행계획 보는 법, 상세 확인방법, Explain의 어떤 지표를 봐야할까?)</title>
      <link>http://localhost:1313/posts/26/</link>
      <pubDate>Thu, 12 Oct 2023 18:25:52 +0000</pubDate>
      <guid>http://localhost:1313/posts/26/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/26/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;실행-계획-확인&#34; ke-size=&#34;size26&#34;&gt;1. 실행 계획 확인&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--Synopsis
EXPLAIN [ ( option [, ...] ) ] 쿼리문
EXPLAIN [ ANALYZE ] [ VERBOSE ] 쿼리문

option 자리에 사용할 수 있는 것들:

    ANALYZE [ boolean ]
    VERBOSE [ boolean ]
    COSTS [ boolean ]
    BUFFERS [ boolean ]
    TIMING [ boolean ]
    FORMAT { TEXT | XML | JSON | YAML }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;* 이후 설명에서 사용될 테스트 데이터는 아래의 &amp;quot;7. 테스트 데이터 생성&amp;quot; 부분 쿼리 확인&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 뷰(VIEW) 테이블 개념 및 사용, 생성(CREATE), 수정(CREATE OR REPLACE), 삭제(DROP)</title>
      <link>http://localhost:1313/posts/25/</link>
      <pubDate>Wed, 11 Oct 2023 19:29:02 +0000</pubDate>
      <guid>http://localhost:1313/posts/25/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/25/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;뷰view-테이블의-사용-생성-삭제-수정&#34; ke-size=&#34;size26&#34;&gt;1. 뷰(VIEW) 테이블의 사용 (생성, 삭제, 수정)&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본 생성
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = &amp;#39;Comedy&amp;#39;;

-- 삭제
DROP VIEW comedies

--Synopsis
CREATE [ OR REPLACE ] VIEW name [ ( column_name [, ...] ) ] AS query
-- or
CREATE VIEW name [ ( column [, ...] ) ]
    AS query
    [ WITH [ CASCADE | LOCAL ] CHECK OPTION ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;뷰view의-개념-및-특징&#34; ke-size=&#34;size26&#34;&gt;2. 뷰(VIEW)의 개념 및 특징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;정의된 쿼리를 실행시켜 가상의 테이블 형태로 보여주며 테이블을 조회하는 것과 같은 방식으로 조회가 가능하다.&lt;/li&gt;
&lt;li&gt;VIEW는 물리적으로 생성되지 않는다.&lt;/li&gt;
&lt;li&gt;복잡한 쿼리를 단순화시키거나 반복된 쿼리 작업을 효율적으로 처리할 수 있게 해 준다.&lt;/li&gt;
&lt;li&gt;VIEW에 참조된 쿼리는 호출 시 매번 새로 실행되기에 실시간 결과물을 조회할 수 있다.&lt;/li&gt;
&lt;li&gt;CREATE OR REPLACE VIEW로 VIEW를 수정할 시, 완전히 일치하는 컬럼 셋을 조회하는 쿼리로만 대체가 가능하다. (같은 컬럼명과 데이터타입)&lt;/li&gt;
&lt;li&gt;Schema 명을 명시적으로 작성하면 해당 Schema에, 아니라면 현재 Schema에 생성된다.&lt;/li&gt;
&lt;li&gt;View, Table, Sequence, Index는 한 스키마에 중복된 명칭을 가질 수 없다.&lt;/li&gt;
&lt;li&gt;VIEW 결과물은 수정이 불가능하다.&lt;/li&gt;
&lt;li&gt;테이블의 전체 컬럼 및 정보를 직접적으로 노출시키지 않은 채로 사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;주의사항&#34; ke-size=&#34;size26&#34;&gt;3. 주의사항&lt;/h2&gt;
&lt;h3 id=&#34;read-only&#34; ke-size=&#34;size23&#34;&gt;          3-1. READ-ONLY&lt;/h3&gt;
&lt;p&gt;VIEW 자체에 insert, update, delete를 실행할 수 없다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] CREATE TABLE AS (결과물을 테이블로)</title>
      <link>http://localhost:1313/posts/24/</link>
      <pubDate>Wed, 11 Oct 2023 18:44:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/24/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/24/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;create-table-as-사용&#34; ke-size=&#34;size26&#34;&gt;1. CREATE TABLE AS 사용&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &amp;gt;= &amp;#39;2002-01-01&amp;#39;;

--Synopsis
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name [ (column_name [, ...] ) ] [ [ WITH | WITHOUT ] OIDS ]
    AS query
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;create-table-as-옵션&#34; ke-size=&#34;size26&#34;&gt;2. CREATE TABLE AS 옵션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;- TEMPORARY / TEMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        임시 테이블로 생성되며 세션이 종료될 시 삭제된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- WITH OIDS / WITHOUT OIDS&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 시퀀스(Sequence)의 개념과 사용법(생성, 삭제, 조회 등)</title>
      <link>http://localhost:1313/posts/23/</link>
      <pubDate>Wed, 11 Oct 2023 14:12:44 +0000</pubDate>
      <guid>http://localhost:1313/posts/23/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/23/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;시퀀스sequence의-사용&#34; ke-size=&#34;size26&#34;&gt;1. 시퀀스(Sequence)의 사용&lt;/h2&gt;
&lt;h3 id=&#34;생성-삭제-조회&#34; ke-size=&#34;size23&#34;&gt;          1-1. 생성, 삭제, 조회&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 101부터 시작하는 기본 시퀀스 생성
CREATE SEQUENCE serial START 101;
-- 시퀀스 다음값 조회
SELECT nextval(&amp;#39;serial&amp;#39;);
-- 시퀀스 현재값 조회
select currval(&amp;#39;serial&amp;#39;);
-- 시퀀스 삭제
DROP SEQUENCE serial;

-- 시퀀스로 INSERT하기
INSERT INTO distributors VALUES (nextval(&amp;#39;serial&amp;#39;), &amp;#39;nothing&amp;#39;);
-- COPY FROM 후에 시퀀스 시작값 변경하기
BEGIN;
COPY distributors FROM &amp;#39;input_file&amp;#39;;
SELECT setval(&amp;#39;serial&amp;#39;, max(id)) FROM distributors;
END;

-- Synopsis
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] 이름
    [ AS 자료형 ]
    [ INCREMENT [ BY ] 증가값 ]
    [ MINVALUE 최소값 | NO MINVALUE ] [ MAXVALUE 최대값 | NO MAXVALUE ]
    [ START [ WITH ] 시작값 ] [ CACHE 캐시 ] [ [ NO ] CYCLE ]
    [ OWNED BY { 테이블이름.칼럼이름 | NONE } ]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;사용-중인-시퀀스-확인&#34; ke-size=&#34;size23&#34;&gt;          1-2. 사용 중인 시퀀스 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select n.nspname as sequence_schema, 
          c.relname as sequence_name,
          u.usename as owner
from pg_class c 
     join pg_namespace n on n.oid = c.relnamespace
     join pg_user u on u.usesysid = c.relowner
where c.relkind = &amp;#39;S&amp;#39;
     and u.usename = current_user;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;시퀀스-생성시-상세-옵션&#34; ke-size=&#34;size26&#34;&gt;2. 시퀀스 생성시 상세 옵션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;- TEMPORARY or TEMP&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 역할 및 권한 (ROLE, USER, GROUP) 개념 및 설정</title>
      <link>http://localhost:1313/posts/22/</link>
      <pubDate>Wed, 11 Oct 2023 10:32:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/22/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/22/img.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;출처: https://blog.ex-em.com/1655&lt;/p&gt;
&lt;h2 id=&#34;role&#34; ke-size=&#34;size26&#34;&gt;1. ROLE&lt;/h2&gt;
&lt;h3 id=&#34;role-생성&#34; ke-size=&#34;size23&#34;&gt;        1-1. ROLE 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE ROLE jonathan LOGIN;
-- 비밀번호 포함
CREATE USER davide WITH PASSWORD &amp;#39;jw8s0F4&amp;#39;;
-- 권한 포함
CREATE ROLE admin WITH CREATEDB CREATEROLE;
-- 사용 기한 포함
CREATE ROLE miriam WITH LOGIN PASSWORD &amp;#39;jw8s0F4&amp;#39; VALID UNTIL &amp;#39;2005-01-01&amp;#39;;
-- 삭제
DELETE ROLE miriam;

-- Synopsis

CREATE ROLE name [ [ WITH ] option [ ... ] ]

where option can be:

      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | REPLICATION | NOREPLICATION
    | BYPASSRLS | NOBYPASSRLS
    | CONNECTION LIMIT connlimit
    | [ ENCRYPTED ] PASSWORD &amp;#39;password&amp;#39; | PASSWORD NULL
    | VALID UNTIL &amp;#39;timestamp&amp;#39;
    | IN ROLE role_name [, ...]
    | IN GROUP role_name [, ...]
    | ROLE role_name [, ...]
    | ADMIN role_name [, ...]
    | USER role_name [, ...]
    | SYSID uid
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;role-이란&#34; ke-size=&#34;size23&#34;&gt;        1-2. ROLE 이란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE ROLE은 PostgreSQL database cluster에 새로운 ROLE을 추가한다. &lt;/li&gt;
&lt;li&gt;ROLE은 데이터베이스 object, 권한을 가질 수 있는 엔티티이다.&lt;/li&gt;
&lt;li&gt;ROLE은 사용방법에 따라 USER, GROUP 혹은 둘다로 간주될 수 있다.&lt;/li&gt;
&lt;li&gt;CREATEROLE 권한이 있어야지만 사용 가능하다.&lt;/li&gt;
&lt;li&gt;ALTER ROLE, DELETE ROLE을 통해 권한을 수정, 삭제 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;role-권한별-특징&#34; ke-size=&#34;size23&#34;&gt;        1-3. ROLE 권한별 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SUPERUSER - 로그인을 제외한 모든 권한 포함 (ex. Role 생성 및 권한 부여)&lt;/li&gt;
&lt;li&gt;LOGIN - 데이터베이스에 로그인하기 위한 권한&lt;/li&gt;
&lt;li&gt;PASSWORD - 로그인 비밀번호 설정&lt;/li&gt;
&lt;li&gt;CREATEDB - 데이터베이스 생성&lt;/li&gt;
&lt;li&gt;CREATEROLE - ROLE 생성/삭제/수정&lt;/li&gt;
&lt;li&gt;REPLICATION - REPLICATION 권한&lt;/li&gt;
&lt;li&gt;CONNECTIONLIMIT - 데이터베이스 접속 카운트&lt;/li&gt;
&lt;li&gt;INHERIT - ROLE 권한들 상속&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;user&#34; ke-size=&#34;size26&#34;&gt;2. USER&lt;/h2&gt;
&lt;h3 id=&#34;user-생성&#34; ke-size=&#34;size23&#34;&gt;        2-1. USER 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 기본
CREATE USER jonathan;
-- 비밀번호 추가
CREATE USER davide WITH PASSWORD &amp;#39;jw8s0F4&amp;#39;;
-- 만료기한 추가
CREATE USER miriam WITH PASSWORD &amp;#39;jw8s0F4&amp;#39; VALID UNTIL &amp;#39;2005-01-01&amp;#39;;
-- 권한 추가
CREATE USER manuel WITH PASSWORD &amp;#39;jw8s0F4&amp;#39; CREATEDB;

--Synopsis
CREATE USER name [ [ WITH ] option [ ... ] ]

where option can be:
    
      SYSID uid 
    | CREATEDB | NOCREATEDB
    | CREATEUSER | NOCREATEUSER
    | IN GROUP groupname [, ...]
    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD &amp;#39;password&amp;#39;
    | VALID UNTIL &amp;#39;abstime&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;user란&#34; ke-size=&#34;size23&#34;&gt;        2-2. USER란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE ROLE은 PostgreSQL database cluster에 새로운 User을 추가한다.&lt;/li&gt;
&lt;li&gt;CREATEUSER 권한이 있어야지만 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;group&#34; ke-size=&#34;size26&#34;&gt;3. GROUP&lt;/h2&gt;
&lt;h3 id=&#34;group-생성&#34; ke-size=&#34;size23&#34;&gt;        3-1. GROUP 생성&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--기본
CREATE GROUP staff;
--유저 추가
CREATE GROUP marketing WITH USER jonathan, david;
--그룹 삭제
DROP GROUP staff;

-- Synopsis
CREATE GROUP name [ [ WITH ] option [ ... ] ]

where option can be:

     SYSID gid
   | USER  username [, ...]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;group이란&#34; ke-size=&#34;size23&#34;&gt;        3-2. GROUP이란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CREATE GROUP은 USER 그룹을 생성한다. &lt;/li&gt;
&lt;li&gt;SUPERUSER 권한이 있어야지만 생성가능하다.&lt;/li&gt;
&lt;li&gt;데이터베이스의 cluster 레벨에 접근 가능하기 위해 GROUP, USER, ROLE은 모두 cluster단에서 정의되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;role-user-group-차이&#34; ke-size=&#34;size26&#34;&gt;4. ROLE, USER, GROUP 차이&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ROLE은 Postgresql Database 관련 권한들을 모아 놓은 것으로, 8.1버전부터 USER와 GROUP의 개념이 ROLE로 통합되었다.&lt;/li&gt;
&lt;li&gt;현재 버전에서는 USER와 ROLE의 기능은 동일하며, USER는 login 권한이 default, ROLE은 login 권한을 별도로 부여해야 하는 차이점만 있다. &lt;/li&gt;
&lt;li&gt;CREATE GROUP의 경우 PostgreSQL의 SQL 표준에는 존재하지 않으며, ROLE과 비슷한 개념을 가지고 있다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 제약조건 (Constraint) 개념 및 설정 (Primary Keys, Foreign Keys, Unique, Not null, Check)</title>
      <link>http://localhost:1313/posts/21/</link>
      <pubDate>Tue, 10 Oct 2023 15:41:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/21/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/21/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;postgresql-제약조건-constrant란&#34; ke-size=&#34;size26&#34;&gt;PostgreSQL 제약조건 (Constrant)란?&lt;/h2&gt;
&lt;p&gt;데이터베이스는 데이터 타입 외에 제약조건들을 통해 데이터의 무결성을 유지한다.&lt;/p&gt;
&lt;p&gt;제약조건에는 여러 가지 종류가 있으며 DMBS에 마다 다양하지만, 이번 포스트는 PostgreSQL의 5가지 제약 조건들을 설명하겠다.
 &lt;/p&gt;
&lt;p&gt;1. #scrollPkPrimary Keys(PK)&lt;/p&gt;
&lt;p&gt;2. #scrollFkForeign Keys(FK)&lt;/p&gt;
&lt;p&gt;3. #scrollCheckCheck&lt;/p&gt;
&lt;p&gt;4. #scrollNotNullNot-null&lt;/p&gt;
&lt;p&gt;5. #scrollUniqueUnique&lt;/p&gt;
&lt;h2 id=&#34;primary-keys-pk&#34; ke-size=&#34;size26&#34;&gt;1. Primary Keys (PK)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Primary Keys는 테이블의 각 ROW를 구분하는 유니크한 컬럼 혹은 컬럼의 조합이다.&lt;/li&gt;
&lt;li&gt;Not- null, Unique Constraints의 조합이다. 테이블인 단 1개의 PK만 가질 수 있다.&lt;/li&gt;
&lt;li&gt;PK 생성 시 Postgresql은 B-tree 인덱스를 자동으로 부여한다.&lt;/li&gt;
&lt;li&gt;B-tree 인덱스를 사용하기 때문에 컬럼의 조합으로 PK를 설정 시 순서가 중요하다. (상세 내용은 다음 포스트에서 확인이 가능하다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2023.09.12 - [Postgresql] - [PostgreSQL] B-tree 인덱스의 원리 및 특징&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 트랜잭션(Transaction)의 개념 및 사용</title>
      <link>http://localhost:1313/posts/20/</link>
      <pubDate>Tue, 10 Oct 2023 14:42:53 +0000</pubDate>
      <guid>http://localhost:1313/posts/20/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/20/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션transaction이란&#34; ke-size=&#34;size26&#34;&gt;1. 트랜잭션(Transaction)이란?&lt;/h2&gt;
&lt;p&gt;트랜잭션은 데이터베이스에서 실행되는 일련의 작업들이다. 트랜잭션은 데이터베이스의 무결성 및 작업 간 충돌방지, 데이터 검증을 위해 필수적인 요소이다. 단순한 DML 작업의 롤백 용도뿐 아니라, 대용량 데이터 처리의 무결성, 에러발생 시, 여러 유저의 동시작업 등에서 사용된다.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션-적용&#34; ke-size=&#34;size26&#34;&gt;2. 트랜잭션 적용&lt;/h2&gt;
&lt;p&gt;트랜잭션을 사용하는 커맨드 예제이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--COMMIT 혹은 ROLLBACK으로 트랜잭션을 종료하지 않으면, 해당 업데이트 건은 데이터베이스에 적용되지 않는다.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = &amp;#39;Alice&amp;#39;;
COMMIT;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;트랜잭션 COMMIT 전에 다른 유저가 동일한 row의 balance를 업데이트하려고 한다면, 그전 트랜잭션이 commit 혹은 rollback 되는 것을 대기해야하며 이를 lock 상태라고 한다. (Lock의 개념 및 상세는 다음 포스트에 상세하게 정리되어 있다.)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Vacuum 개념 및 적절한 사용</title>
      <link>http://localhost:1313/posts/17/</link>
      <pubDate>Mon, 09 Oct 2023 13:33:14 +0000</pubDate>
      <guid>http://localhost:1313/posts/17/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/17/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;vacuum-이란&#34; ke-size=&#34;size26&#34;&gt;1. Vacuum 이란?&lt;/h2&gt;
&lt;p&gt;Vacuum은 postgresql에서 dead tuple이 차지하는 저장공간을 회수한다. 일반적으로 Postgresql에서 update, delete tuple 은 물리적으로 삭제되지 않으며 vacuum이 완료될 때까지 계속 존재한다. &lt;/p&gt;
&lt;p&gt;(update, delete 시 tuple의 순환은 MVCC 개념에서 확인할 수 있다.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/152023.10.06&#34;&gt;https://junhkang.tistory.com/152023.10.06&lt;/a&gt; - [Postgresql] - [PostgreSQL] MVCC (Multi-Version Concurrency Control)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/15&#34;&gt;https://junhkang.tistory.com/15&lt;/a&gt;
 &lt;/p&gt;
&lt;p&gt;[PostgreSQL] MVCC (Multi-Version Concurrency Control)&lt;/p&gt;
&lt;p&gt;1. MVCC란? 동시성 제어를 위해 lock을 사용하는 대부분의 다른 데이터베이스 시스템과 달리 Postgres는 다중 버전 모델(multiversion model)을 사용하여 데이터 일관성을 유지한다. 각 트랜잭션이 데이터&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] MVCC (Multi-Version Concurrency Control)</title>
      <link>http://localhost:1313/posts/15/</link>
      <pubDate>Fri, 06 Oct 2023 18:53:47 +0000</pubDate>
      <guid>http://localhost:1313/posts/15/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/15/img.png&#34;&gt;
 &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&#34;1-mvcc란&#34;&gt;1.  MVCC란?&lt;/h2&gt;
&lt;p&gt;[동시성 제어를 위해 lock을 사용하는 대부분의 다른 데이터베이스 시스템과 달리 Postgres는 다중 버전 모델(multiversion model)을 사용하여 데이터 일관성을 유지한다. 각 트랜잭션이 데이터베이스를 쿼리 하는 동안 데이터의 현재 상태에 관계없이 얼마 전의 데이터 스냅샷을 볼 수 있음을 의미한다. ]{style=&amp;ldquo;background-color: #fdfdfd; color: #000000; text-align: start;&amp;quot;}데이터를 쿼리 하기 위해 트랜잭션을 만들었다면 해당 Transaction은 데이터의 스냅샷을 보고 있는 것이다.
 &lt;/p&gt;
&lt;p&gt;동일한 행에 서로 다른 트랜잭션이 동시에 업데이트를 시도할 때, 일관성 없는 데이터가 조회되지 않도록 트랜잭션을 보호하여 각 데이터베이스 세션에 대한 트랜잭션 격리를 제공한다. [Multiversion과 Lock model의 주요 차이점은 MVCC에서 데이터 read를 위해 획득한 lock과 데이터 쓰기를 위해 획득한 lock이 충돌하지 않는다는 것이다. (따라서 read와 write는 서로 block 하지 않는다.) ]{style=&amp;ldquo;background-color: #fdfdfd; color: #000000; text-align: start;&amp;rdquo;}[이러한 방식을 통해서 Reading 하는 작업에 대해서 Lock을 걸지 않기에 높은 성능을 얻을 수 있게 된다.]{style=&amp;ldquo;background-color: #ffffff; color: #212529; text-align: start;&amp;rdquo;}[]{style=&amp;ldquo;background-color: #ffffff; color: #212529; text-align: start;&amp;rdquo;}&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 미사용 인덱스(INDEX) 찾기 및 삭제, 성능향상</title>
      <link>http://localhost:1313/posts/14/</link>
      <pubDate>Fri, 06 Oct 2023 16:52:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/14/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;img src=&#34;0&#34; /&gt;
&lt;h2 id=&#34;인덱스index-상세-개념&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스(INDEX) 상세 개념&lt;/h2&gt;
&lt;p&gt;2023.09.12 - [Postgresql] - [PostgreSQL] 인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://junhkang.tistory.com/5&#34;&gt;https://junhkang.tistory.com/5&lt;/a&gt;
 &lt;/p&gt;
&lt;p&gt;[PostgreSQL] 인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법&lt;/p&gt;
&lt;p&gt;1. 인덱스 컨트롤 1-1. 인덱스 조회 SELECT * FROM pg_indexes WHERE tablename = &#39;{테이블명}&#39;; -- 테이블명에 &#39;&#39; 필요 1-2. 인덱스 생성 -- 단일 인덱스 CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명}); -- 결&lt;/p&gt;
&lt;p&gt;junhkang.tistory.com&lt;/p&gt;
&lt;h2 id=&#34;미사용-인덱스&#34; ke-size=&#34;size26&#34;&gt;2. 미사용 인덱스&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;간단히 말해, 인덱스는 지정 컬럼에 매핑된 정보를 별도로 저장하고 있다. 보통 플랜 확인을 통해 효율적으로 인덱스를 추가하여 쿼리 최적화를 진행하게 된다. 오래되고 변경이 잦은 어플리케이션일수록 미사용 인덱스는 늘어나고, 인덱스가 사용되지 않는 경우를 매번 모니터링하여 삭제하는 것은 힘든 일이다. 하지만 불필요 인덱스는 디비 성능저하 및 vacuum 코스트를 증가시키기에, 최적화된 인덱스 생성만큼 최적화된 인덱스 삭제도 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ERROR: text search configuration name \&#34;english\&#34; must be schema-qualified</title>
      <link>http://localhost:1313/posts/13/</link>
      <pubDate>Thu, 05 Oct 2023 13:53:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/13/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/13/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;발생&#34; ke-size=&#34;size26&#34;&gt;1. 발생&lt;/h2&gt;
&lt;p&gt;해당 에러는 Postgresql에서 Full Text Search를 위해 tsvector 컬럼을 업데이트할 때 발생한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 특정 컬럼을 ts_vector로 변경하여 업데이트
UPDATE
    TABLE
SET
    tsvec_words = to_tsvector(&amp;#39;english&amp;#39;,COLUMN);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;원인&#34; ke-size=&#34;size26&#34;&gt;2. 원인&lt;/h2&gt;
&lt;p&gt;해당 컬럼 (혹은 다른 컬럼) 에 테이블 row 업데이트/인서트 시 ts_vector를 자동으로 업데이트하는 trigger가 걸려 있기 때문에 업데이트 간 충돌이 생겨 발생한다.&lt;/p&gt;
&lt;h2 id=&#34;해결&#34; ke-size=&#34;size26&#34;&gt;3. 해결&lt;/h2&gt;
&lt;p&gt;트러거를 삭제 후 데이터 업데이트 후에 트리거를 재설정하면 해결된다.&lt;/p&gt;
&lt;h4 id=&#34;트리거-삭제&#34; ke-size=&#34;size20&#34;&gt;       3-1. 트리거 삭제&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drop trigger TABLE_TRGGER on TABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;트리거-생성&#34; ke-size=&#34;size20&#34;&gt;       3-2. 트리거 생성&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE TRIGGER
  TABLE_TRIGGER
BEFORE INSERT OR UPDATE ON
  TABLE
FOR EACH ROW EXECUTE PROCEDURE
  tsvector_update_trigger(tsvec_words, &amp;#39;english&amp;#39;,COLUMN);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] 문자열내 중복 공백, 단어 제거</title>
      <link>http://localhost:1313/posts/12/</link>
      <pubDate>Wed, 04 Oct 2023 19:34:40 +0000</pubDate>
      <guid>http://localhost:1313/posts/12/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/12/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;중복-공백-제거&#34; ke-size=&#34;size26&#34;&gt;1. 중복 공백 제거&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;특정 문자열에 대해서 중복 공백 제거를 하고 싶다면 postgresql 정규식을 사용해서 가능하다.&lt;br&gt;
(공백 외에 단일 문자에 대한 중복제거도 동일한 방법으로 가능하다.)&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select regexp_replace(name, &amp;#39; +&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;g&amp;#39;) from TABLE; -- &amp;#39;g&amp;#39; 옵션을 제거할 경우 최초 건에 대에서만 변경
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;중복-단어-제거&#34; style=&#34;color: #333333; text-align: start;&#34; ke-size=&#34;size26&#34;&gt;2. 중복 단어 제거&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;컬럼 단위 중복제거는 distinct, group by를 통해 쉽게 가능하지만, 컬럼 내 문자열의 중복 단어 제거의 경우 다음과 같다.&lt;br&gt;
(쉼표 기준으로 컬럼을 분리, 중복을 제거한 후 다시 연결)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] BRIN 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/11/</link>
      <pubDate>Mon, 18 Sep 2023 19:03:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/11/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;img src=&#34;0&#34; /&gt;
&lt;h2 id=&#34;brin-인덱스란&#34; ke-size=&#34;size26&#34;&gt;&lt;strong&gt;1. BRIN 인덱스란?&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[▪]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;rdquo;}[ ]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;quot;}Block range index의 약자&lt;br&gt;
[▪]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;rdquo;}[ ]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;quot;}Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값)
[▪]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;rdquo;}[ ]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif; color: #666666; text-align: left;&amp;quot;}특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우 큰 테이블을 다루기 위해 설계 (타임시쿼스한 대용량 데이터 조회에 유용)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] GIN인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/10/</link>
      <pubDate>Wed, 13 Sep 2023 19:45:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/10/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;gin-인덱스란&#34; ke-size=&#34;size26&#34;&gt;[1. GIN 인덱스란?]{style=&amp;ldquo;color: #333333;&amp;rdquo;}&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Generalized Inverted Index의 약자이다. 이전 포스트인 full text search에서 사용하는 인덱스의 유형. 기본 구조는 B-tree와 유사하지만, 저장 형태가 다르다.  저장된 요소 자제에 대한 검색이 아닌 인덱스 컬럼의 값을 split 한 token인 lexeme 배열에 대해서 검색을 한다. array_ops, tsvector_ops, jsonb_ops, jsonb_path_ops 등 의 built-in operators를 통해 접근이 가능하다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;full-text-search에서의-적용&#34; ke-size=&#34;size26&#34;&gt;[2. full text search에서의 적용]{style=&amp;ldquo;color: #333333;&amp;rdquo;}&lt;/h2&gt;
&lt;h3 id=&#34;샘플-테이블-및-데이터-생성&#34; ke-size=&#34;size23&#34;&gt;[2-1. 샘플 테이블 및 데이터 생성]{style=&amp;ldquo;color: #333333;&amp;rdquo;}&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create table ts(doc text, doc_tsv tsvector);

insert into ts(doc) values
  (&amp;#39;Can a sheet slitter slit sheets?&amp;#39;), 
  (&amp;#39;How many sheets could a sheet slitter slit?&amp;#39;),
  (&amp;#39;I slit a sheet, a sheet I slit.&amp;#39;),
  (&amp;#39;Upon a slitted sheet I sit.&amp;#39;), 
  (&amp;#39;Whoever slit the sheets is a good sheet slitter.&amp;#39;), 
  (&amp;#39;I am a sheet slitter.&amp;#39;),
  (&amp;#39;I slit sheets.&amp;#39;),
  (&amp;#39;I am the sleekest sheet slitter that ever slit sheets.&amp;#39;),
  (&amp;#39;She slits the sheet she sits on.&amp;#39;);

update ts set doc_tsv = to_tsvector(doc);
create index on ts using gin(doc_tsv);

select doc from ts where doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;조회-결과-및-플랜-확인&#34; ke-size=&#34;size23&#34;&gt;2-2. 조회 결과 및 플랜 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;                             QUERY PLAN                              
---------------------------------------------------------------------
 Bitmap Heap Scan on ts
   Recheck Cond: (doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;::text))
   -&amp;gt;  Bitmap Index Scan on ts_doc_tsv_idx
         Index Cond: (doc_tsv @@ to_tsquery(&amp;#39;many &amp;amp; slitter&amp;#39;::text))
(4 rows)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] SP-GiST인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/9/</link>
      <pubDate>Wed, 13 Sep 2023 18:11:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/9/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;sp-gist-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. SP-GiST 인덱스란?&lt;/h2&gt;
&lt;p&gt;Space-Partitioned Generalized Search Tree의 약자이다. [GiST인덱스와 같이 지리, 좌표, ip주소 데이터 등 복잡한 유형의 데이터를 처리하는 인덱스 유형이다. GiST가 B-tree 인덱스를 통해 보관 데이터를 세분화할 때, 위계적 순서를 따라야 하기에, 이를 보완하기 위해 만들어진 유형으로, GiST로 분리된 공간을 다시 한번 공간 단위로 나누어 관리하는 개념이다. ]{style=&amp;ldquo;color: #333333; font-family: -apple-system, BlinkMacSystemFont, &amp;lsquo;Helvetica Neue&amp;rsquo;, &amp;lsquo;Apple SD Gothic Neo&amp;rsquo;, Arial, sans-serif; font-size: 16px; letter-spacing: 0px;&amp;rdquo;}[SP-GiST는 겹치지 않는 영역으로 재귀적 분할을 할 수 있는 구조에 적합하다. ]{style=&amp;ldquo;background-color: #fdfdfd; color: #000000; text-align: start;&amp;quot;}기본적으로 SP-GiST는 다양한 데이터 유형, 복잡한 쿼리를 지원하도록 설계되었다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] GiST인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/8/</link>
      <pubDate>Wed, 13 Sep 2023 16:27:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/8/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;gist-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. GiST 인덱스란?&lt;/h2&gt;
&lt;p&gt;Generalized Search Tree의 약자이며 B-tree와 같은 balanced search tree의 형태이다. B-tree인덱스는 정렬된 채로 비교&amp;amp;일치의 연산에 최적화된 채로 연결되어있다. 하지만 현대의 다양한 데이터 종류 (기하학적, 텍스트문서, 이미지 등)를 연산하는 데는 적합하지 않다.&lt;/p&gt;
&lt;p&gt;GiST 인덱스는 이러한 데이터 타입의 인덱싱을 위해 설계되었다. GiST 인덱스는 각 유형의 데이터를 Balanced tree 형태로 구성하게하고, tree에 접근하는 연산자를 정의해 준다. 각각 leaf node는 table row(TID)와 boolean 형태의 predicate를 가지고 있고 인덱스 데이터(key)는 이 predicate와 부합한다. 그 후는 일반적인 tree search처럼, 루트노드에서 시작하여, 어떤 child node로 진입할지를 결정한다. 그러다가 leaf node를 발견하면, 그 결과들을 반환한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Hash 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/7/</link>
      <pubDate>Wed, 13 Sep 2023 14:28:16 +0000</pubDate>
      <guid>http://localhost:1313/posts/7/</guid>
      <description>&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;img src=&#34;0&#34; /&gt;
&lt;h2 id=&#34;hash-인덱스란&#34; ke-size=&#34;size26&#34;&gt;1. Hash 인덱스란?&lt;/h2&gt;
&lt;p&gt;해쉬 인덱스의 기본 아이디어는, hash function을 통해 작은 숫자를 데이터와 조합하여 integer 형태의 해쉬값 (최대 2^32 = 4B)을 생성하고 해쉬값을 테이블 행 정보(TID)가 저장될 배열의 인덱스 값으로 사용하는 것이다. 이 배열의 각 요소를 해시 테이블 버킷(hash table bucket)이라고 한다. 데이터 조회 시, hash function을 통해 생성된 key가 포함된 bucket을 찾고, 그 bucket만 확인하면 실제 데이터의 위치를 바로 확인할 수 있다. 데이터의 크기에 상관없이 인덱스의 크기가 작고 검색이 빠르다. 1개의 데이터를 조회하는 시간은 O(1)로 빠르지만 해쉬 테이블 내의 값들은 정렬이 되어있지 않기 때문에 범위 비교나 부정형 비교가 포함된 조건에서는 인덱스를 사용할 수 없다. Hash function이 버킷 단위로 소스 값을 더 균일하게 분배할수록 효율이 좋다. &lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] B-tree 인덱스의 원리 및 특징</title>
      <link>http://localhost:1313/posts/6/</link>
      <pubDate>Tue, 12 Sep 2023 19:12:12 +0000</pubDate>
      <guid>http://localhost:1313/posts/6/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;[PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다.]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}&lt;/p&gt;
&lt;p&gt;[그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에 대해 알아보자.]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}&lt;/p&gt;
&lt;h2 id=&#34;b-tree-인덱스란&#34; ke-size=&#34;size26&#34;&gt;[1. B-tree 인덱스란?]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[▪ 트리의 노드를 밸런스 있게 재정렬한 트리형태의 자료구조]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}&lt;br&gt;
[▪ B-tree는 Binary 가 아닌 Balanced의 약자]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}
[▪ 컬럼의 기존 데이터를 변형하지 않음]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}
[▪ 인덱스 구조체 내에서는 항상 정렬된 상태를 유지]{style=&amp;ldquo;font-family: AppleSDGothicNeo-Regular, &amp;lsquo;Malgun Gothic&amp;rsquo;, &amp;lsquo;맑은 고딕&amp;rsquo;, dotum, 돋움, sans-serif;&amp;rdquo;}&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL]  인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법</title>
      <link>http://localhost:1313/posts/5/</link>
      <pubDate>Tue, 12 Sep 2023 17:50:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/5/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/5/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;인덱스-컨트롤&#34; ke-size=&#34;size26&#34;&gt;1. 인덱스 컨트롤&lt;/h2&gt;
&lt;h3 id=&#34;인덱스-조회&#34; ke-size=&#34;size23&#34;&gt;1-1. 인덱스 조회 &lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM pg_indexes WHERE tablename = &amp;#39;{테이블명}&amp;#39;; -- 테이블명에 &amp;#39;&amp;#39; 필요
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-생성&#34; ke-size=&#34;size23&#34;&gt;1-2. 인덱스 생성 &lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 단일 인덱스
CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명});

-- 결합 인덱스
CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명1}, {컬럼명2});

-- 유니크 인덱스
CREATE UNIQUE INDEX {인덱스명} ON table_name ({컬럼명});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-삭제&#34; ke-size=&#34;size23&#34;&gt;1-3. 인덱스 삭제&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DROP INDEX {인덱스명};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-사용-빈도-확인&#34; ke-size=&#34;size23&#34;&gt;1-4. 인덱스 사용 빈도 확인&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT schemaname, relname, indexrelname, idx_scan as idx_scan_cnt FROM pg_stat_user_indexes ORDER BY idx_scan;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;인덱스-손상-시-재인덱싱&#34; ke-size=&#34;size23&#34;&gt;1-5. 인덱스 손상 시 재인덱싱&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;REINDEX INDEX {인덱스명}

REINDEX TABLE {테이블명}

REINDEX DATABASE {데이터베이스명}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>Postgresql Lock이란? (조회 및 kill, Dead lock)</title>
      <link>http://localhost:1313/posts/4/</link>
      <pubDate>Mon, 11 Sep 2023 18:02:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/4/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/4/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;lock-확인방법&#34; ke-size=&#34;size26&#34;&gt;[1. Lock 확인방법]{style=&amp;ldquo;font-family: &amp;lsquo;Noto Sans Demilight&amp;rsquo;, &amp;lsquo;Noto Sans KR&amp;rsquo;;&amp;rdquo;}&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT PSAT.RELNAME,
       PL.LOCKTYPE,
       PL.PID,
       PL.MODE,
       PL.GRANTED
FROM PG_LOCKS PL,
     PG_STAT_ALL_TABLES PSAT
WHERE PL.RELATION = PSAT.RELID
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;lock-kill-방법&#34; ke-size=&#34;size26&#34;&gt;[2. Lock Kill 방법]{style=&amp;ldquo;font-family: &amp;lsquo;Noto Sans Demilight&amp;rsquo;, &amp;lsquo;Noto Sans KR&amp;rsquo;;&amp;rdquo;}&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT PG_CANCEL_BACKEND([PID])

SELECT PG_TERMINATE_BACKEND([PID])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[Lock 리스트에서 조회된 PID를 넣고 cancel, 혹은 terminate 시켜주면 된다. cancel은 해당 프로세스만을, terminate는 상위 프로세스들까지 종료시킨다.]{style=&amp;ldquo;font-family: &amp;lsquo;Noto Sans Demilight&amp;rsquo;, &amp;lsquo;Noto Sans KR&amp;rsquo;;&amp;rdquo;}&lt;/p&gt;
&lt;h2 id=&#34;lock-이란-postgresql&#34; ke-size=&#34;size26&#34;&gt;[3. Lock 이란? (Postgresql)]{style=&amp;ldquo;font-family: &amp;lsquo;Noto Sans Demilight&amp;rsquo;, &amp;lsquo;Noto Sans KR&amp;rsquo;;&amp;rdquo;}&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[Postgresql은 다양한 종류의 lock 기능을 제공한다. 애플리케이션 단에서 제어도 가능하지만, 대부분 기본적인 SQL 실행 시 적절한 락을 자동실행시켜 관련 테이블의 무결성 유지한다.]{style=&amp;ldquo;font-family: &amp;lsquo;Noto Sans Demilight&amp;rsquo;, &amp;lsquo;Noto Sans KR&amp;rsquo;;&amp;rdquo;}&lt;/p&gt;</description>
    </item>
    <item>
      <title>[PostgreSQL] Trigger, Procedure, Function (history 관리하기)</title>
      <link>http://localhost:1313/posts/3/</link>
      <pubDate>Fri, 08 Sep 2023 13:37:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/3/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/3/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;가장-보편적으로-쓰이는-간단한-history-저장-트리거-생성-예제&#34; ke-size=&#34;size26&#34;&gt;* 가장[ ]{style=&amp;ldquo;color: #333333; text-align: start;&amp;quot;}보편적으로[ ]{style=&amp;ldquo;color: #333333; text-align: start;&amp;quot;}쓰이는 간단한 history 저장 트리거[ ]{style=&amp;ldquo;color: #333333; text-align: start;&amp;quot;}생성[ ]{style=&amp;ldquo;color: #333333; text-align: start;&amp;quot;}예제&lt;/h2&gt;
&lt;p&gt;특정 테이블에 insert, update가 수행될 경우 무조건 내역에 &amp;ldquo;insert&amp;quot;를 하는 간단한 트리거 생성 예제이다.&lt;/p&gt;
&lt;h4 id=&#34;함수를-실행할-트리거-생성&#34; ke-size=&#34;size20&#34;&gt;1-1. 함수를 실행할 트리거 생성&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create trigger trigger_save_history
after insert or update on A
for each row
execute procedure trigger_insert();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;실제-insert문이-실행되는-함수&#34; ke-size=&#34;size20&#34;&gt;1-2. 실제 insert문이 실행되는 함수 &lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE OR REPLACE FUNCTION trigger_insert()
returns trigger
AS $$
DECLARE
BEGIN
    insert into B
        (id, values, date)
    values
        (new.id, new.values, current_timestamp());
    return NULL;
END; $$
LANGUAGE &amp;#39;plpgsql&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>Full Text Search를 활용한 데이터베이스 성능 향상</title>
      <link>http://localhost:1313/posts/2/</link>
      <pubDate>Thu, 07 Sep 2023 17:25:06 +0000</pubDate>
      <guid>http://localhost:1313/posts/2/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/posts/2/img.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;문제상황&#34; ke-size=&#34;size26&#34;&gt;1. 문제상황&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색&lt;br&gt;
(Ex. Susan loves hiking 을 &amp;ldquo;love hike&amp;rdquo; 이라는 키워드로 검색하고자 함)&lt;/li&gt;
&lt;li&gt;RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;full-text-search전문검색란&#34; ke-size=&#34;size26&#34;&gt;2. Full Text Search(전문검색)란?&lt;/h2&gt;
&lt;p&gt;게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
