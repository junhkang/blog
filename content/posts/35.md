---
title: '[Java] 클래스 로딩 과정(Java Class Loading Process)이란?'
date: '2023-10-23 17:30:32'
categories: ['Java']
tags: ['Java', 'jvm', '클래스']
---

------------------------------------------------------------------------

## **1. 클래스 로딩 과정 (Java Class Loading Process) 이란?** {#클래스-로딩-과정-java-class-loading-process-이란 ke-size="size26"}

자바 클래스 로딩 과정 (Java Class Loading Process)은 클래스 로더가 클래스 파일을 찾아 동적으로 JVM의 메모리 영역인 Runtime Data Areas에 올려놓는 과정을 말한다.
 

자바에서 객체가 어떻게 형성/관리 되는지 이해하려면. java 파일의 소스코드가 어떻게 JVM 위에 로딩되는지 아는 것이 중요하고, 클래스 로딩할 때 발생하는 문제 ('java.lang.ClassNotFoundException\'과 같은 에러)를 쉽게 해결하고, 코드상 동적으로 클래스 로딩하는 구문 이해하는데 필요하다.

## **2. 클래스 로더 3단계 과정** {#클래스-로더-3단계-과정 ke-size="size26"}

클래스 로더는 다음 3단계 과정을 거쳐 클래스 파일을 로딩한다.

![](/images/posts/35/img.png)


> **1. Loading**\
> 클래스 파일을 읽어 바이너리 코드로 만들고 JVM의 메모리에 로드\
> **2. Linking**\
> 클래스파일 사용을 위한 검증\
> 코드 내부의 러퍼런스를 연결\
> **3. Initialization**\
> Static 변수들의 초기화 및 값 할당
 

## **3. 클래스 로드 시점**

Loading 시점에서 JVM은 실행 시점에 모든 클래스를 메모리에 올려놓지 않고 필요한 클래스를 동적으로 메모리에 적재하여 효율적으로 관리한다.

> **1. 인스턴스 생성시**\
> **2. Static 변수 할당**\
> **3. Static 메서드 호출**\
> **4. Static final 상수 호출** 
> (Static 변수, 메소드 호출과 다르게 Outer 클래스가 로딩되지 않는다, JVM의 Method Area에 Constant Pool에 따로 저장되어 관리되기 때문이다.)

## **4. 클래스 로더의 종류** {#클래스-로더의-종류 ke-size="size26"}

![](/images/posts/35/img_1.png)


JVM을 실행했을 때 각 클래스 로더들은 자신이 호출할 수 있는 클래스들을 호출하여 JVM에 로딩하게 된다.

> **1. 부트스트랩 클래스 로더**\
> \$JAVA_HOME/jre/lib/rt.jar 에서 rt.jar에 있는 JVM을 실행시키기 위한 최소한의 핵심 클래스들을 로딩한다.\
> -verbose:class JVM 옵션을 주고 자바 애플리케이션을 실행시키면 rt.jar에 있는 파일 로딩되는 것을 확인할 수 있다.\
> Java 9 이후로는 rt.jar 등이 없어짐에 따라 로딩할 수 있는 클래스의 범위가 축소되어 정확하게 ClassLoader 내 최상위 클래스들만 로드한다.\
> **2. 확장 클래스로더**\
> \$JAVA_HOME/jre/lib/ext 경로의 자바 확장 클래스들을 로딩한다\
> **3. 애플리케이션  클래스 로더**\
> 자바 프로그램 실행 시\$CLASSPATH에 설정된 경로의 클래스들을 로딩하게 된다. 이 시점에 개발된. class파일들이 로딩된다.

클래스 로더들은 계층 구조를 가지도록 생성이 가능하고 각 부모 클래스 로더에서 자식클래스 로더를 가지는 형태로 클래스 로더를 만들 수 있다. 

## **5. 클래스 로더의 작동원칙** {#클래스-로더의-작동원칙 ke-size="size26"}

**위임 원칙 (Delegate Load Request)**

![](/images/posts/35/img_2.png)

System Loader가 A라는 클래스를 로딩할 때 그 요청은 부모로더들로 거슬러 올라가 부트스트랩 로더에 도착한 후 그 밑으로 로딩 요청을 수행한다. 최상위 클래스 로더에 요청을 위임한 후, 파일을 찾으며 자식 클래스 로더에게 넘기며, 클래스로더 중 하나라도 파일 찾는 데 성공하면 자식 로더에게 넘겨준다.
 

**가시성 제약 조건(Have Visibility Constraint)**

부모 로더에서 찾지 못한 클래스는 자식 로더로 찾지 못하고, 자식로더가 찾지 못한 것은 부모로더에 위임해서 찾을 수 있다
 

**언로드 불가 (Cannot unload classes)**

클래스 로더로 로딩된 클래스들은 JVM 상에서 없앨 수 없다
 

**유일성 원칙 (Uniqueness Principle)**

하위 클래스 로더가 상위 클래스 로더에서 로드한 클래스를 다시 로드하지 않아야 한다.

상위 클래스로만 책임을 위임하기에 고유한 클래스를 보장할 수 있게 해주는 원칙이다.
 

 

 


 

참고

- https://co-no.tistory.com/103

- https://engkimbs.tistory.com/entry/Java-Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95Java-Class-Loading-Process

- 클래스 로더 시스템의 3단계 동작 과정 / 출처 :https://dailyheumsi.tistory.com/196

- 클래스 로더 동작순서 (출처 : https://engkimbs.tistory.com/)