<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=50666&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라 | Jun Kang's Blog</title>
<meta name=keywords content="Effective"><meta name=description content="
1. 개념
equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.
2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우
2-1. equals를 재정의하지 말아야 할 경우

각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.
논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.
상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.
접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.

2-2. equals를 재정의해야 할 경우

논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.

3. equals 메서드의 규약
Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:"><meta name=author content="Jun Kang"><link rel=canonical href=http://localhost:50666/posts/90/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:50666/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:50666/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:50666/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:50666/apple-touch-icon.png><link rel=mask-icon href=http://localhost:50666/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:50666/posts/90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:50666/posts/90/"><meta property="og:title" content="[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라 | Jun Kang's Blog"><meta property="og:description" content="
1. 개념
equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.
2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우
2-1. equals를 재정의하지 말아야 할 경우

각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.
논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.
상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.
접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.

2-2. equals를 재정의해야 할 경우

논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.

3. equals 메서드의 규약
Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:"><meta property="og:image" content="http://localhost:50666/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="http://localhost:50666/posts/90/"><meta property="twitter:title" content="[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라 | Jun Kang's Blog"><meta property="twitter:description" content="
1. 개념
equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.
2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우
2-1. equals를 재정의하지 말아야 할 경우

각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.
논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.
상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.
접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.

2-2. equals를 재정의해야 할 경우

논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.

3. equals 메서드의 규약
Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:"><meta property="twitter:image" content="http://localhost:50666/images/og_img.jpg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-LE7D0WZLFJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LE7D0WZLFJ")}</script><meta property="og:url" content="http://localhost:50666/posts/90/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라"><meta property="og:description" content=" 1. 개념 equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.
2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우 2-1. equals를 재정의하지 말아야 할 경우 각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다. 논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다. 상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다. 접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다. 2-2. equals를 재정의해야 할 경우 논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다. 3. equals 메서드의 규약 Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-29T18:13:10+00:00"><meta property="article:modified_time" content="2024-06-29T18:13:10+00:00"><meta property="article:tag" content="Effective"><meta name=twitter:card content="summary"><meta name=twitter:title content="[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라"><meta name=twitter:description content="
1. 개념
equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.
2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우
2-1. equals를 재정의하지 말아야 할 경우

각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.
논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.
상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.
접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.

2-2. equals를 재정의해야 할 경우

논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.

3. equals 메서드의 규약
Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:50666/posts/"},{"@type":"ListItem","position":2,"name":"[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라","item":"http://localhost:50666/posts/90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라","name":"[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라","description":" 1. 개념 equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.\n2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우 2-1. equals를 재정의하지 말아야 할 경우 각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다. 논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다. 상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다. 접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다. 2-2. equals를 재정의해야 할 경우 논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다. 3. equals 메서드의 규약 Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:\n","keywords":["Effective"],"articleBody":" 1. 개념 equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.\n2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우 2-1. equals를 재정의하지 말아야 할 경우 각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다. 논리적 동치성 검사가 필요 없는 경우: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다. 상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다. 접근이 제한된 클래스: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다. 2-2. equals를 재정의해야 할 경우 논리적 동치성 비교가 필요한 경우: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다. 3. equals 메서드의 규약 Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:\n반사성 (Reflexivity): 모든 null이 아닌 참조 값 x에 대해, x.equals(x)는 true여야 한다. 대칭성 (Symmetry): 모든 null이 아닌 참조 값 x, y에 대해, x.equals(y)가 true이면 y.equals(x)도 true여야 한다. 추이성 (Transitivity): 모든 null이 아닌 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true여야 한다. 일관성 (Consistency): 모든 null이 아닌 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true 또는 항상 false를 반환해야 한다. null-아님 (Non-nullity): 모든 null이 아닌 참조 값 x에 대해, x.equals(null)은 항상 false여야 한다. 4. equals 구현 방법 == 연산자를 사용하여 입력이 자기 자신의 참조인지 확인한다. instanceof 연산자로 입력이 올바른 타입인지 확인한다. 입력을 올바른 타입으로 형변환한다. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다. 5. equals 구현 후 점검 새로 구현된 equals 메서드가 대치성, 추이성, 일관성을 유지하는지 확인해야한다.\n6. equals를 재정의하는 예 경험했던 equals를 재정의하는 예로는 보통 값 객체(value object, VO)가 있다. 예를 들어 User 클래스에서 식별자 id가 같으면 같은 사용자로 간주할 수 있다. 이 경우, equals를 id 필드를 기준으로 재정의하여 사용자 객체의 논리적 동치성을 정확히 비교할 수 있다.\n7. 정리 꼭 필요한 경우가 아니면 equals를 재정의하지 말아야 한다. Object의 기본 equals 메서드가 대개 원하는 비교를 수행해 준다. 꼭 필요한 경우라면 앞서 정리한 다섯 가지 규약을 반드시 지켜가며 equals를 구현해야 한다. ","wordCount":"350","inLanguage":"en","datePublished":"2024-06-29T18:13:10Z","dateModified":"2024-06-29T18:13:10Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:50666/posts/90/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"http://localhost:50666/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:50666/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:50666/about/ title=About><span>About</span></a></li><li><a href=http://localhost:50666/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=http://localhost:50666/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:50666/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:50666/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:50666/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:50666/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라</h1><div class=post-meta><span title='2024-06-29 18:13:10 +0000 UTC'>June 29, 2024</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><h2 id=개념 ke-size=size26>1. 개념<a hidden class=anchor aria-hidden=true href=#개념>#</a></h2><p>equals를 단순히 재정의 하는 것은 쉽지만 함정이 많다. 이번 장에서는 equals를 재정의 할 때 고려해야 하는 점과, 재정의가 완료된 후 확인해야 하는 부분들에 대해 다루고 있다.</p><h2 id=equals를-재정의하는-경우와-재정의하지-말아야-하는-경우 ke-size=size26>2. equals를 재정의하는 경우와 재정의하지 말아야 하는 경우<a hidden class=anchor aria-hidden=true href=#equals를-재정의하는-경우와-재정의하지-말아야-하는-경우>#</a></h2><h3 id=equals를-재정의하지-말아야-할-경우 ke-size=size23>2-1. equals를 재정의하지 말아야 할 경우<a hidden class=anchor aria-hidden=true href=#equals를-재정의하지-말아야-할-경우>#</a></h3><ul><li><strong>각 인스턴스가 본질적으로 고유한 값을 표현하는 클래스</strong>: 예를 들어, Thread 클래스는 각 인스턴스가 고유한 ID를 가지므로 equals를 재정의할 필요가 없다.</li><li><strong>논리적 동치성 검사가 필요 없는 경우</strong>: 대부분의 경우 객체 식별성만 중요하며, 논리적 동치성은 필요하지 않을 수 있다.</li><li><strong>상위 클래스에서 재정의한 equals가 하위 클래스에 적절한 경우</strong>: 상위 클래스에서 이미 equals를 적절히 구현했고, 이를 하위 클래스에서 그대로 사용해도 무방한 경우이다.</li><li><strong>접근이 제한된 클래스</strong>: equals를 호출할 일이 없는 private이나 package-private 클래스일 경우, 재정의할 필요가 없다.</li></ul><h3 id=equals를-재정의해야-할-경우 ke-size=size23>2-2. equals를 재정의해야 할 경우<a hidden class=anchor aria-hidden=true href=#equals를-재정의해야-할-경우>#</a></h3><ul><li><strong>논리적 동치성 비교가 필요한 경우</strong>: 객체의 내용이 같은지를 비교해야 할 때, 상위 클래스의 equals가 이를 충족시키지 않을 때 재정의가 필요하다.</li></ul><h2 id=equals-메서드의-규약 ke-size=size26>3. equals 메서드의 규약<a hidden class=anchor aria-hidden=true href=#equals-메서드의-규약>#</a></h2><p>Object 기본 명세의 equals 메서드는 다음의 규약을 준수해야 한다:</p><ul><li><strong>반사성 (Reflexivity)</strong>: 모든 null이 아닌 참조 값 x에 대해, x.equals(x)는 true여야 한다.</li><li><strong>대칭성 (Symmetry)</strong>: 모든 null이 아닌 참조 값 x, y에 대해, x.equals(y)가 true이면 y.equals(x)도 true여야 한다.</li><li><strong>추이성 (Transitivity)</strong>: 모든 null이 아닌 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true여야 한다.</li><li><strong>일관성 (Consistency)</strong>: 모든 null이 아닌 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true 또는 항상 false를 반환해야 한다.</li><li><strong>null-아님 (Non-nullity)</strong>: 모든 null이 아닌 참조 값 x에 대해, x.equals(null)은 항상 false여야 한다.</li></ul><h2 id=equals-구현-방법 ke-size=size26>4. equals 구현 방법<a hidden class=anchor aria-hidden=true href=#equals-구현-방법>#</a></h2><ul><li>== 연산자를 사용하여 입력이 자기 자신의 참조인지 확인한다.</li><li>instanceof 연산자로 입력이 올바른 타입인지 확인한다.</li><li>입력을 올바른 타입으로 형변환한다.</li><li>입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.</li></ul><h2 id=equals-구현-후-점검 ke-size=size26>5. equals 구현 후 점검<a hidden class=anchor aria-hidden=true href=#equals-구현-후-점검>#</a></h2><p>새로 구현된 equals 메서드가 대치성, 추이성, 일관성을 유지하는지 확인해야한다.</p><h2 id=equals를-재정의하는-예 ke-size=size26>6. equals를 재정의하는 예<a hidden class=anchor aria-hidden=true href=#equals를-재정의하는-예>#</a></h2><p>경험했던 equals를 재정의하는 예로는 보통 값 객체(value object, VO)가 있다. 예를 들어 User 클래스에서 식별자 id가 같으면 같은 사용자로 간주할 수 있다. 이 경우, equals를 id 필드를 기준으로 재정의하여 사용자 객체의 논리적 동치성을 정확히 비교할 수 있다.</p><h2 id=정리 ke-size=size26>7. 정리 <a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><ul><li>꼭 필요한 경우가 아니면 equals를 재정의하지 말아야 한다. Object의 기본 equals 메서드가 대개 원하는 비교를 수행해 준다.</li><li>꼭 필요한 경우라면 앞서 정리한 다섯 가지 규약을 반드시 지켜가며 equals를 구현해야 한다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:50666/tags/effective/>Effective</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>