<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Full Text Search를 활용한 데이터베이스 성능 향상 | Jun Kang's Blog</title>
<meta name=keywords content="PostgreSQL,full"><meta name=description content="

1. 문제상황

긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색
(Ex. Susan loves hiking 을 &ldquo;love hike&rdquo; 이라는 키워드로 검색하고자 함)
RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상

2. Full Text Search(전문검색)란?
게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다."><meta name=author content="Jun Kang"><link rel=canonical href=https://junhkang.com/posts/2/><meta name=google-site-verification content="G-PV53RL6R3L"><link crossorigin=anonymous href=/assets/css/stylesheet.74700298e7318c6a254db46da1e4db20401442caa2ca390299eb96ba781bad05.css integrity="sha256-dHACmOcxjGolTbRtoeTbIEAUQsqiyjkCmeuWungbrQU=" rel="preload stylesheet" as=style><link rel=icon href=https://junhkang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junhkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junhkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://junhkang.com/apple-touch-icon.png><link rel=mask-icon href=https://junhkang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://junhkang.com/posts/2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.social-icons{display:flex;align-items:center;gap:15px;margin-top:15px}.profile-visitor-count{display:flex;align-items:center;margin-left:auto;padding:6px 10px;background-color:var(--entry);border-radius:6px;font-size:.9em;color:var(--secondary);border:1px solid var(--border);transition:all .3s ease;gap:6px;text-decoration:none}.profile-visitor-count:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.1);text-decoration:none}.visitor-label{display:flex;align-items:center;gap:4px}@media screen and (max-width:768px){.social-icons{flex-wrap:wrap;justify-content:center}.profile-visitor-count{margin-left:0;margin-top:10px}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=window.location.pathname;if(e==="/"){{const e=document.querySelector(".social-icons");if(e){const t=document.createElement("a");t.href="https://hits.sh/junhkang.com/",t.target="_blank",t.className="profile-visitor-count",t.innerHTML=`
                <span class="visitor-label">👥 총 방문자</span>
                <img alt="방문자" src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square&label=&color=000000&labelColor=ffffff&background=ffffff"/>
            `,e.appendChild(t)}}}else{const e=document.createElement("img");e.style.opacity="0",e.style.position="absolute",e.style.pointerEvents="none",e.src="https://hits.sh/junhkang.com.svg?view=today-total&style=flat-square",document.body.appendChild(e)}})</script><meta property="og:type" content="article"><meta property="og:url" content="https://junhkang.com/posts/2/"><meta property="og:title" content="Full Text Search를 활용한 데이터베이스 성능 향상 | Jun Kang's Blog"><meta property="og:description" content="

1. 문제상황

긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색
(Ex. Susan loves hiking 을 &ldquo;love hike&rdquo; 이라는 키워드로 검색하고자 함)
RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상

2. Full Text Search(전문검색)란?
게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다."><meta property="og:image" content="https://junhkang.com/images/og_img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://junhkang.com/posts/2/"><meta property="twitter:title" content="Full Text Search를 활용한 데이터베이스 성능 향상 | Jun Kang's Blog"><meta property="twitter:description" content="

1. 문제상황

긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색
(Ex. Susan loves hiking 을 &ldquo;love hike&rdquo; 이라는 키워드로 검색하고자 함)
RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상

2. Full Text Search(전문검색)란?
게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다."><meta property="twitter:image" content="https://junhkang.com/images/og_img.jpg"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9413249746505723" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PV53RL6R3L"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PV53RL6R3L")}</script><meta property="og:url" content="https://junhkang.com/posts/2/"><meta property="og:site_name" content="Jun Kang's Blog"><meta property="og:title" content="Full Text Search를 활용한 데이터베이스 성능 향상"><meta property="og:description" content=" 1. 문제상황 긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색
(Ex. Susan loves hiking 을 “love hike” 이라는 키워드로 검색하고자 함) RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상 2. Full Text Search(전문검색)란? 게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-07T17:25:06+00:00"><meta property="article:modified_time" content="2023-09-07T17:25:06+00:00"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="Full"><meta name=twitter:card content="summary"><meta name=twitter:title content="Full Text Search를 활용한 데이터베이스 성능 향상"><meta name=twitter:description content="

1. 문제상황

긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색
(Ex. Susan loves hiking 을 &ldquo;love hike&rdquo; 이라는 키워드로 검색하고자 함)
RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상

2. Full Text Search(전문검색)란?
게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://junhkang.com/posts/"},{"@type":"ListItem","position":2,"name":"Full Text Search를 활용한 데이터베이스 성능 향상","item":"https://junhkang.com/posts/2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Full Text Search를 활용한 데이터베이스 성능 향상","name":"Full Text Search를 활용한 데이터베이스 성능 향상","description":" 1. 문제상황 긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색\n(Ex. Susan loves hiking 을 \u0026ldquo;love hike\u0026rdquo; 이라는 키워드로 검색하고자 함) RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상 2. Full Text Search(전문검색)란? 게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다.\n","keywords":["PostgreSQL","full"],"articleBody":" 1. 문제상황 긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색\n(Ex. Susan loves hiking 을 “love hike” 이라는 키워드로 검색하고자 함) RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상 2. Full Text Search(전문검색)란? 게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다.\n2-1. Gin Index GIN stands for \"Generalized Inverted index\". \"Inverted\" refers to the way that the index structure is set up, building a table-encompassing tree of all column values, where a single row can be represented in many places within the tree. By comparison, a B-tree index generally has one location where an index entry points to a specific row.\n인덱스를 적용하는 column의 값을 일정한 규칙에 따라 split 후 사용한다. 데이터 내의 각 token들을 indexing하여 등장 위치와 상관없이 해당 찾고자 하는 값이 데이터의 중간에 등장하더라도 인덱스가 가능하다.\n3. 원리 document를 형태소 단위로 해체하여 각 토큰들을 숫자, 단어, 이메일 등으로 분류한다. 분류된 토큰들을 정규화(대문자를 소문자로 바꾸거나, 복수형들을 단수형으로 바꾸는 등) 를 통해 lexem 형태로 분류한다. 이 과정을 통해 전처리 된 document를 lexem 배열 형태로 저장 후 검색에 사용한다. Postgresql 의 경우 to_tsvector 함수를 통해 document 를 tsvector 타입으로 변환이 가능하다. 변환 후에는 tsquery를 사용하여 매칭 여부를 확인가능하다\nSELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat \u0026 rat'::tsquery; 3-1. 참고 (한국어 처리) 각 lexem이 정규화 되어있기에 문장 내에 과거형, 복수형 등 유사언어에 대한 검색이 가능하지만 기본적으로 영단어만 제공되며, 한글의 경우 hunspell과 같은 한글 언어팩을 별도로 설치해야 사용 가능하다.\nRDS 현재 설치된 extension 확인\nSHOW rds.extensions 해당 언어팩을 사용하려면 plpythonu3u 와 같은 extension을 설치해야하나, AWS RDS의 경우 보안상의 이유로 특정 extension들의 별도 설치를 제한하고 있어 한글팩 설치가 불가하다. 다만 한글 버전의 유사도 검색이 꼭 필요하다면 AWS Lamda 함수를 통해 우회하여 한글 단어팩을 사용하는 방법은 가능하다.\n4.데이터 타입 4-1. Tsvector Document를 token으로 분리한 후 정형화(복수형, 과거형,대소문자 등의 데이터를 정리 후 ) 중복제거된 lexemes list 유형\nSELECT 'a:1A fat:2B,3C cat:4D'::tsvector; **tsvector ----------------------------** 'a':1A 'cat':4 'fat':2B,3C 4-2. Tsquery lexemes 내에 조건에 맞는 결과가 있는지 여부를 나타내는 유형\nSELECT 'fat \u0026 rat \u0026 ! cat'::tsquery; **tsquery ------------------------** 'fat' \u0026 'rat' \u0026 !'cat' 4-3. 테이블에 적용 - Tsvector 컬럼 추가 ALTER TABLE table ADD COLUMN tsvec_words tsvector - Tsvector 데이터 추가 UPDATE table SET tsvec_words = to_tsvector(column); - Tsvector 인덱스 추가 CREATE INDEX example_idx ON table USING gin(tsvec_words); 5. 연산자 문법의 경우 https://www.postgresql.org/docs/current/textsearch-controls.html공식문서를 참고하는 것이 가장 정확하지만, 직접 적용해본 후 가장 기본적이고 유용한 문법을 정리해보자면\n1. \u0026 : and 2. | : or 3. ! : not 4. :* : like (sql의 %%와 동일) 5. \u003c-\u003e : 문자 사이의 간격 확인 예를들어 cat과 dog의 lexem을 모두 포함하고 있는 document를 검색하고 싶다면,\nSELECT * FROM Table WHERE tsvec_words @@ to_tsquery(‘cat:*\u0026dog:*’) 6. 구문 분석 쿼리 PostgreSQL은 쿼리를 tsquery 데이터 형식으로 변환하기 위해 to_tsquery , plainto_tsquery , phraseto_tsquery 및 websearch_to_tsquery 함수를 제공한다.\n6-1. plainto_tsquery plainto_tsquery는 and, a, or 등의 단어를 제외한 형식화되지 않은 텍스트만을 tsquery로 변환 후 단어 사이에 \u0026 연산자를 포함하여 리턴한다. (연산자는 인식하지 않음)\nSELECT plainto_tsquery('english', 'the Fat Rats eat ttt a and young bean'); 'fat' \u0026 'rat' \u0026 'eat' \u0026 'ttt' \u0026 'young' \u0026 'bean' 6-2. phraseto_tsquery phraseto_tsquery는 plainto_tsquery와 유사하지만, \u0026 대신 \u003c-\u003e(followed by) 연산자로 구분된다. 사이에 삭제되는단어가 있다면 으로 표현되기에 lexeme의 시퀀스를 확인할때 유용하다.\n(연산자는 인식하지 않음)\nSELECT phraseto_tsquery('english', 'the Fat Rats eat ttt a and young a bean'); 'fat' \u003c-\u003e 'rat' \u003c-\u003e 'eat' \u003c-\u003e 'ttt' \u003c-\u003e 'young' \u003c2\u003e 'bean' 6-3. websearch_to_tsquery websearch_to_tsquery는 plainto_tsquery와 동일 (연산자 인식)\nSELECT websearch_to_tsquery('\"\"\" )( dummy \\ query \u003c-\u003e'); websearch_to_tsquery ---------------------- 'dummy' \u003c-\u003e 'query' 7. 검색결과 순위 보통 유사 검색을 실행할 시 가장 유사도가 높은( 검색결과에 가장 부합하는) 결과를 최우선적으로 노출시켜야한다.\nFull Text Search를 통해 조회할 경우 우선 순위를 검색 결과에 가장 부합한다는 지표를 어떻게 확인할 수 있을까?\nts_rank_cd 함수는 쿼리와 매칭 결과 간의 유사도를 점수화하여 보여준다.\nSELECT title, ts_rank_cd(textsearch, query) AS rank FROM apod, to_tsquery(‘test|white\u0026’blue’) query WHERE query @@ textsearch ORDER BY rank DESC 해당 쿼리를 사용하면 ’test|white\u0026‘blue’ 조건에 부합하면서, 관련도를 추출할수 있어\n관련성 높은 document를 최우선적으로 리스트업 할 수 있다.\n마무리 full text search를 사용시 like문의 결합으로 텍스트를 검색할 시보다 효율 높음\na. full Text Search(gin index) 사용시 b. 기본 like절 사용시 150만건 데이터 기준 실행시간 9초 -\u003e 1초 향상.\n데이터 수량이 더 많을 경우 향상될 것으로 보임\n정교한 유사단어 검색 가능 (시제, 단복수, 줄임말 등이 고려된 유사어에 대한 검색이 가능)\n“키워드%”, 짧은 단어 내 검색, 숫자형태 검색 등 b-tree 인덱스의 효율을 살릴 수 있는 검색의 경우 충분한 검토 후 도입이 필요\n참고\n이미지 출처: https://pganalyze.com/blog/gin-index ","wordCount":"759","inLanguage":"en","datePublished":"2023-09-07T17:25:06Z","dateModified":"2023-09-07T17:25:06Z","author":{"@type":"Person","name":"Jun Kang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://junhkang.com/posts/2/"},"publisher":{"@type":"Organization","name":"Jun Kang's Blog","logo":{"@type":"ImageObject","url":"https://junhkang.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junhkang.com/ accesskey=h title="Jun Kang's Blog (Alt + H)">Jun Kang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://junhkang.com/about/ title=About><span>About</span></a></li><li><a href=https://junhkang.com/sankun/ title=Sankun><span>Sankun</span></a></li><li><a href=https://junhkang.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://junhkang.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://junhkang.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://junhkang.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://junhkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://junhkang.com/guestbook/ title=Guestbook><span>Guestbook</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Full Text Search를 활용한 데이터베이스 성능 향상</h1><div class=post-meta><span title='2023-09-07 17:25:06 +0000 UTC'>September 7, 2023</span>&nbsp;·&nbsp;Jun Kang</div></header><div class=post-content><hr><p><img loading=lazy src=/images/posts/2/img.png></p><h2 id=문제상황 ke-size=size26>1. 문제상황<a hidden class=anchor aria-hidden=true href=#문제상황>#</a></h2><ol><li>긴 텍스트에서 단순 like 조합 외 방법으로 유사 문자열 검색<br>(Ex. Susan loves hiking 을 &ldquo;love hike&rdquo; 이라는 키워드로 검색하고자 함)</li><li>RDBMS에서 수천만 건의 데이터 처리 시 긴 문자열 검색 속도 향상</li></ol><h2 id=full-text-search전문검색란 ke-size=size26>2. Full Text Search(전문검색)란?<a hidden class=anchor aria-hidden=true href=#full-text-search전문검색란>#</a></h2><p>게시물의 내용/제목 등 문장, 문서 전체에서 키워드를 검색하는 기능이다. 단순한 like, 비교연산자와 달리 각 단어의 Token화 및 정규화를 통해 긴 문장내에서의 유사 검색을 가능하게 한다. Postgresql 기본 인덱스인 b-tree인덱스로는 Like 와 같은 패턴 매칭 검색시 양쪽에 %%를 거는 경우는 인덱스를 타지 않지만, gin 인덱스를 사용하여 빠른 검색이 가능하다.</p><h4 id=gin-index ke-size=size20>2-1. Gin Index<a hidden class=anchor aria-hidden=true href=#gin-index>#</a></h4><p>GIN stands for "Generalized Inverted index". "Inverted" refers to the way that the index structure is set up, building a table-encompassing tree of all column values, where a single row can be represented in many places within the tree. By comparison, a B-tree index generally has one location where an index entry points to a specific row.</p><p>인덱스를 적용하는 column의 값을 일정한 규칙에 따라 split 후 사용한다. 데이터 내의 각 token들을 indexing하여 등장 위치와 상관없이 해당 찾고자 하는 값이 데이터의 중간에 등장하더라도 인덱스가 가능하다.</p><p><img loading=lazy src=/images/posts/2/img_1.png></p><h2 id=원리 ke-size=size26>3. 원리<a hidden class=anchor aria-hidden=true href=#원리>#</a></h2><p>document를 형태소 단위로 해체하여 각 토큰들을 숫자, 단어, 이메일 등으로 분류한다. 분류된 토큰들을 정규화(대문자를 소문자로 바꾸거나, 복수형들을 단수형으로 바꾸는 등) 를 통해 lexem 형태로 분류한다. 이 과정을 통해 전처리 된 document를 lexem 배열 형태로 저장 후 검색에 사용한다. Postgresql 의 경우 to_tsvector 함수를 통해 document 를 tsvector 타입으로 변환이 가능하다. 변환 후에는 tsquery를 사용하여 매칭 여부를 확인가능하다</p><pre tabindex=0><code class=language-lasso data-lang=lasso>SELECT &#39;a fat cat sat on a mat and ate a fat rat&#39;::tsvector @@ &#39;cat &amp; rat&#39;::tsquery;
</code></pre><h4 id=참고-한국어-처리 ke-size=size20>3-1. 참고 (한국어 처리)<a hidden class=anchor aria-hidden=true href=#참고-한국어-처리>#</a></h4><p>각 lexem이 정규화 되어있기에 문장 내에 과거형, 복수형 등 유사언어에 대한 검색이 가능하지만 기본적으로 영단어만 제공되며, 한글의 경우 hunspell과 같은 한글 언어팩을 별도로 설치해야 사용 가능하다.</p><ul><li><p>RDS 현재 설치된 extension 확인</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>SHOW</span> <span style=color:#f92672>rds</span>.<span style=color:#a6e22e>extensions</span>
</span></span></code></pre></div><p>해당 언어팩을 사용하려면 plpythonu3u 와 같은 extension을 설치해야하나, AWS RDS의 경우 보안상의 이유로 특정 extension들의 별도 설치를 제한하고 있어 한글팩 설치가 불가하다. 다만 한글 버전의 유사도 검색이 꼭 필요하다면 AWS Lamda 함수를 통해 우회하여 한글 단어팩을 사용하는 방법은 가능하다.</p></li></ul><h2 id=데이터-타입 ke-size=size26>4.데이터 타입<a hidden class=anchor aria-hidden=true href=#데이터-타입>#</a></h2><h4 id=tsvector ke-size=size20>4-1. Tsvector<a hidden class=anchor aria-hidden=true href=#tsvector>#</a></h4><p>Document를 token으로 분리한 후 정형화(복수형, 과거형,대소문자 등의 데이터를 정리 후 ) 중복제거된 lexemes list 유형</p><pre tabindex=0><code class=language-pgsql data-lang=pgsql>SELECT &#39;a:1A fat:2B,3C cat:4D&#39;::tsvector;
          **tsvector
----------------------------**
&#39;a&#39;:1A &#39;cat&#39;:4 &#39;fat&#39;:2B,3C
</code></pre><h4 id=tsquery ke-size=size20>4-2. Tsquery<a hidden class=anchor aria-hidden=true href=#tsquery>#</a></h4><p>lexemes 내에 조건에 맞는 결과가 있는지 여부를 나타내는 유형</p><pre tabindex=0><code class=language-pgsql data-lang=pgsql>SELECT &#39;fat &amp; rat &amp; ! cat&#39;::tsquery;
        **tsquery
------------------------**
 &#39;fat&#39; &amp; &#39;rat&#39; &amp; !&#39;cat&#39;
</code></pre><h4 id=테이블에-적용 ke-size=size20>4-3. 테이블에 적용<a hidden class=anchor aria-hidden=true href=#테이블에-적용>#</a></h4><h5 id=--tsvector-컬럼-추가>- Tsvector 컬럼 추가<a hidden class=anchor aria-hidden=true href=#--tsvector-컬럼-추가>#</a></h5><pre tabindex=0><code class=language-pgsql data-lang=pgsql>ALTER TABLE
    table
ADD COLUMN
    tsvec_words tsvector
</code></pre><h5 id=--tsvector-데이터-추가>- Tsvector 데이터 추가<a hidden class=anchor aria-hidden=true href=#--tsvector-데이터-추가>#</a></h5><pre tabindex=0><code class=language-pgsql data-lang=pgsql>UPDATE
    table
SET
    tsvec_words = to_tsvector(column);
</code></pre><h5 id=--tsvector-인덱스-추가>- Tsvector 인덱스 추가<a hidden class=anchor aria-hidden=true href=#--tsvector-인덱스-추가>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span>
</span></span><span style=display:flex><span>    example_idx
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>table</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>USING</span>
</span></span><span style=display:flex><span>    gin(tsvec_words);
</span></span></code></pre></div><h2 id=연산자 ke-size=size26>5. 연산자<a hidden class=anchor aria-hidden=true href=#연산자>#</a></h2><p>문법의 경우 <a href=https://www.postgresql.org/docs/current/textsearch-controls.html>https://www.postgresql.org/docs/current/textsearch-controls.html</a>공식문서를 참고하는 것이 가장 정확하지만, 직접 적용해본 후 가장 기본적이고 유용한 문법을 정리해보자면</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ada data-lang=ada><span style=display:flex><span><span style=color:#ae81ff>1.</span> <span style=color:#f92672>&amp;</span> : <span style=color:#f92672>and</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.</span> | : <span style=color:#66d9ef>or</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.</span> <span style=color:#960050;background-color:#1e0010>!</span> : <span style=color:#f92672>not</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>4.</span> :<span style=color:#f92672>*</span> : like (sql의 <span style=color:#960050;background-color:#1e0010>%%</span>와 동일)
</span></span><span style=display:flex><span><span style=color:#ae81ff>5.</span> <span style=color:#f92672>&lt;-&gt;</span> : 문자 사이의 간격 확인
</span></span></code></pre></div><p>예를들어 cat과 dog의 lexem을 모두 포함하고 있는 document를 검색하고 싶다면,</p><pre tabindex=0><code class=language-pgsql data-lang=pgsql>SELECT
  *
FROM
  Table
WHERE
  tsvec_words @@ to_tsquery(‘cat:*&amp;dog:*’)
</code></pre><h2 id=구문-분석-쿼리 ke-size=size26>6. 구문 분석 쿼리<a hidden class=anchor aria-hidden=true href=#구문-분석-쿼리>#</a></h2><p>PostgreSQL은 쿼리를 tsquery 데이터 형식으로 변환하기 위해 to_tsquery , plainto_tsquery , phraseto_tsquery 및 websearch_to_tsquery 함수를 제공한다.</p><h4 id=plainto_tsquery ke-size=size20>6-1. plainto_tsquery<a hidden class=anchor aria-hidden=true href=#plainto_tsquery>#</a></h4><p>plainto_tsquery는 and, a, or 등의 단어를 제외한 형식화되지 않은 텍스트만을 tsquery로 변환 후 단어 사이에 & 연산자를 포함하여 리턴한다. (연산자는 인식하지 않음)</p><pre tabindex=0><code class=language-pgsql data-lang=pgsql>SELECT plainto_tsquery(&#39;english&#39;, &#39;the Fat Rats eat ttt a and young bean&#39;);
&#39;fat&#39; &amp; &#39;rat&#39; &amp; &#39;eat&#39; &amp; &#39;ttt&#39; &amp; &#39;young&#39; &amp; &#39;bean&#39;
</code></pre><h4 id=phraseto_tsquery ke-size=size20>6-2. phraseto_tsquery<a hidden class=anchor aria-hidden=true href=#phraseto_tsquery>#</a></h4><p>phraseto_tsquery는 plainto_tsquery와 유사하지만, & 대신 &lt;->(followed by) 연산자로 구분된다. 사이에 삭제되는단어가 있다면 으로 표현되기에 lexeme의 시퀀스를 확인할때 유용하다.<br>(연산자는 인식하지 않음)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sml data-lang=sml><span style=display:flex><span> SELECT phraseto_tsquery(<span style=color:#a6e22e>&#39;english&#39;</span>, <span style=color:#a6e22e>&#39;the</span> Fat Rats eat ttt a <span style=color:#66d9ef>and</span> young a bean&#39;);
</span></span><span style=display:flex><span><span style=color:#a6e22e>&#39;fat&#39;</span> &lt;-&gt; <span style=color:#a6e22e>&#39;rat&#39;</span> &lt;-&gt; <span style=color:#a6e22e>&#39;eat&#39;</span> &lt;-&gt; <span style=color:#a6e22e>&#39;ttt&#39;</span> &lt;-&gt; <span style=color:#a6e22e>&#39;young&#39;</span> &lt;<span style=color:#ae81ff>2</span>&gt; <span style=color:#a6e22e>&#39;bean&#39;</span>
</span></span></code></pre></div><h4 id=websearch_to_tsquery ke-size=size20>6-3. websearch_to_tsquery<a hidden class=anchor aria-hidden=true href=#websearch_to_tsquery>#</a></h4><p>websearch_to_tsquery는 plainto_tsquery와 동일 (연산자 인식)</p><pre tabindex=0><code class=language-asciidoc data-lang=asciidoc>SELECT websearch_to_tsquery(&#39;&#34;&#34;&#34; )( dummy \ query &lt;-&gt;&#39;);
 websearch_to_tsquery
----------------------
&#39;dummy&#39; &lt;-&gt; &#39;query&#39;
</code></pre><h2 id=검색결과-순위 ke-size=size26>7. 검색결과 순위<a hidden class=anchor aria-hidden=true href=#검색결과-순위>#</a></h2><p>보통 유사 검색을 실행할 시 가장 유사도가 높은( 검색결과에 가장 부합하는) 결과를 최우선적으로 노출시켜야한다.<br>Full Text Search를 통해 조회할 경우 우선 순위를 검색 결과에 가장 부합한다는 지표를 어떻게 확인할 수 있을까?</p><p>ts_rank_cd 함수는 쿼리와 매칭 결과 간의 유사도를 점수화하여 보여준다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> 
</span></span><span style=display:flex><span>  title, 
</span></span><span style=display:flex><span>  ts_rank_cd(textsearch, query) <span style=color:#66d9ef>AS</span> rank
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> apod, to_tsquery(<span style=color:#960050;background-color:#1e0010>‘</span>test<span style=color:#f92672>|</span>white<span style=color:#f92672>&amp;</span><span style=color:#960050;background-color:#1e0010>’</span>blue<span style=color:#960050;background-color:#1e0010>’</span>) query
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> query <span style=color:#f92672>@@</span> textsearch
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> rank <span style=color:#66d9ef>DESC</span>
</span></span></code></pre></div><p>해당 쿼리를 사용하면 &rsquo;test|white&&lsquo;blue&rsquo; 조건에 부합하면서, 관련도를 추출할수 있어<br>관련성 높은 document를 최우선적으로 리스트업 할 수 있다.</p><h2 id=마무리 ke-size=size26>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h2><ul><li><p>full text search를 사용시 like문의 결합으로 텍스트를 검색할 시보다 효율 높음<br>a. full Text Search(gin index) 사용시
<img loading=lazy src=/images/posts/2/img_2.png></p><p><br>b. 기본 like절 사용시
<img loading=lazy src=/images/posts/2/img_3.png></p><p>150만건 데이터 기준 실행시간 9초 -> 1초 향상.<br>데이터 수량이 더 많을 경우 향상될 것으로 보임</p></li><li><p>정교한 유사단어 검색 가능
(시제, 단복수, 줄임말 등이 고려된 유사어에 대한 검색이 가능)</p></li><li><p>&ldquo;키워드%&rdquo;, 짧은 단어 내 검색, 숫자형태 검색 등 b-tree 인덱스의 효율을 살릴 수 있는 검색의 경우 충분한 검토 후 도입이 필요</p></li></ul><p>참고</p><ul><li>이미지 출처: <a href=https://pganalyze.com/blog/gin-index>https://pganalyze.com/blog/gin-index</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junhkang.com/tags/postgresql/>PostgreSQL</a></li><li><a href=https://junhkang.com/tags/full/>Full</a></li></ul></footer><div class=giscus><script src=https://giscus.app/client.js data-repo=junhkang/blog data-repo-id=R_kgDON3GHLw data-category=General data-category-id=DIC_kwDON3GHL84Cm5Fc data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>