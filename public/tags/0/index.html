<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>0 | Jun Kang&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="Jun Kang">
<link rel="canonical" href="http://localhost:1313/tags/0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/0/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Jun Kang&#39;s Blog (Alt + H)">Jun Kang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    0
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[AWS] Elastic IP (탄력적 IP)의 개념 및 적용
    </h2>
  </header>
  <div class="entry-content">
    <p>EIP(Elastic Ip Address)란 인터넷으로 접속이 가능한 공인 IP를 할당하여, 인스턴스에 탈부착할 수 있는 서비스이다. 인스턴스 혹은 네트워크 인터페이스에 연결이 가능하며 삭제 전까지 해당 IP를 유지할 수 있다.EC2 인스턴스 생성 시 공인 IP 사용 설정을 Enable로 변경 (default는 Disable)할 경우 인스턴스 자체에 공인 IP를 할당받을 수 있는데 왜 굳이 Elastic IP를 사용하는 것일까?![](/images/posts/18/스크린샷 2023-10-09 오후 1.56.51.png)인스턴스가 stop 후 재시작될 경우 공인 IP가 변경되는 경우가 발생한다. 인스턴스 자체의 공인 IP가 변경될 경우 큰 문제로 이어질 수 있어EIP를 인스턴스에 연결함으로써 인스턴스의 공인IP를 고정시켜 준다.## 2. Elastic IP 개념 및 특징- 탄력적 IP 주소는 정적이며 시간이 지남에 따라 변경되지 않는다.- 탄력적 IP 주소는 특정 리전에서만 사용할 수 있으며 다른 리전으로 이전할 수 없다.- IPv4 주소의 Amazon 풀 또는 AWS 계정으로 가져온 사용자 지정 IPv4 주소 풀에서 탄력적 IP 주소를 할당할 수 있다. (3-3. EIP 옵션 설정 시 선택 가능)- 탄력적 IP 주소를 사용하려면 먼저 계정에 주소를 할당한 후 인스턴스 또는 네트워크 인터페이스와 연결해야 한다.(3-6. 인스턴스 할당)- 탄력적 IP 주소는 리소스에서 연결 해제했다가 다른 리소스와 다시 연결할 수 있다. 예기치 않은 동작을 방지하려면 변경하기 전에 기존 연결에 이름이 지정된 리소스에 대한 모든 활성 연결이 닫혀 있는지 확인해야 한다. 탄력적 IP 주소를 다른 리소스에 연결한 후 새로 연결된 리소스에 대한 연결을 다시 열 수 있다.- 연결 해제한 Elastic IP 주소는 명시적으로 릴리스(삭제)할 때까지 계정에 할당되어 있기 때문에 실행 중인 인스턴스와 연결되지 않은 탄력적 IP 주소에 대해서는 소액의 시간당 요금이 부과된다 (2. 요금 항목 참고).- 탄력적 IP 주소를 이전에 퍼블릭 IPv4 주소가 있던 인스턴스와 연결하면 인스턴스의 퍼블릭 DNS 호스트 이름이 탄력적 IP 주소에 맞게 변경된다.- Amazon은 퍼블릭 DNS 호스트 이름을 인스턴스 네트워크 외부에서는 인스턴스의 퍼블릭 IPv4 주소 또는 탄력적 IP 주소로 변환하고, 인스턴스 네트워크 내부에서는 인스턴스의 프라이빗 IPv4 주소로 변환한다.- AWS 계정으로 가져온 IP 주소 풀에서 탄력적 IP 주소를 할당하는 경우 해당 IP 주소는 탄력적 IP 주소 한도에 포함되지 않는다.- 탄력적 IP 주소는 특정 네트워크 경계 그룹에서만 사용할 수 있다.퍼블릭(IPv4) 인터넷 주소는 흔치 않은 퍼블릭 리소스 이기 때문에 지역당 5개로 제한되며, 인스턴스 장애 시 주소를 다른 인스턴스로 다시 매핑하는 기능이 필요할때는 EIP를 주로 사용하고, 다른 모든 노드 간 통신은 DNS 호스트명을 사용하는 것을 권장한다. (사용개수 제한은 AWS에 별도 문의하여 최대 사용량을 증가시킬 수 있다.)## 3. 요금- 실행 중인 인스턴스와 연결된 각 추가 IP 주소에 대해 시간당 0.005 USD(비례 할당으로 계산)- 실행 중인 인스턴스와 연결되지 않은 각 탄력적 IP 주소에 대해 시간당 0.005 USD(비례 할당으로 계산)- 매달 처음 100개의 재매핑에 대해 탄력적 IP 주소 재 매핑당 0.00 USD- 매달 100개 이후의 재매핑에 대해 탄력적 IP 주소 재 매핑당 0.10 USD상세 요금은 다음 공식 링크에서 확인 가능하다.https://aws.amazon.com/ec2/pricing/on-demand/EC2 온디맨드 인스턴스 요금 – Amazon Web Servicesaws.amazon.com4. 적용#### 4-1. EC2 메뉴에서 Elastic IPs 선택![](/images/posts/18/스크린샷 2023-10-09 오후 2.00.56.png)#### 4-2. Allocate Elastic IP address 선택![](/images/posts/18/스크린샷 2023-10-09 오후 2.02.17.png)### 4-3. 네트워크 경계그룹, IP주소 풀 선택 후 “Allocate&#34;선택#### 4-3-1. 네트워크 경계 그룹AWS가 Public 주소를 알리는 가용영역, , Local Zone 또는 Wavelength Zone의 집합이다. Local Zone 및 Wavelength Zone은 AWS 네트워크와 해당 영역의 리소스에 액세스 하는 고객 간의 지연 시간 또는 물리적 거리를 최소화하기 위해 리전의 AZ와 다른 네트워크 경계 그룹을 가질 수 있다.주의 : EIP와 연결될 AWS 리소스는 동일한 네트워크 경계 그룹에 할당되어야 한다.#### 4-3-2. Public IPv4 address pool- [Amazon의 IP 주소 풀(Amazon’s pool of IPv4 addresses)] - 특별한 경우가 아니라면 해당 옵션을 선택하여 공인 IP를 할당받으면 된다. IPv4 주소를 Amazon의 IPv4 주소 풀에서 할당하려는 경우이다.- AWS 계정으로 가져오는 퍼블릭 IPv4 주소 - AWS 계정으로 가져온 IP 주소 풀에서 IPv4 주소를 할당하려는 경우. IP 주소 풀이 없는 경우에는 이 옵션을 사용할 수 없다.- [고객 소유 IPv4 주소 풀(Customer owned pool of IPv4 addresses)] - AWS Outpost를 통해 사용할 온프레미스 네트워크에서 생성된 풀에서 IPv4 주소를 할당하려는 경우. AWS Outposts가 없는 경우 이 옵션이 비활성화된다.![](/images/posts/18/스크린샷 2023-10-09 오후 2.03.46.png)### 4-4. EIP 생성이 완료되면 리스트에서 확인이 가능하며, 인스턴스 할당을 위해서 해당 항목을 클릭하여 상세 페이지로 들아간다.![](/images/posts/18/스크린샷 2023-10-09 오후 2.04.45.png)### 4-5. EIP 상세에서 우측 상단 “Associate Elastic IP address&#34;를 선택한다.### 4-6. AWS 인스턴스와 연결하고 싶다면 인스턴스를 선택, 특정 사설(private) ip와 연결하고 싶다면 IP주소를 입력하면 된다.“Allow this Elastic IP address to be reassociated” 옵션을 선택하면 해당 EIP를 할당 후 다른 인스턴스로 변경이 가능하다.참고https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html#AWS #eip #Elastic IPs
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [AWS] Elastic IP (탄력적 IP)의 개념 및 적용" href="http://localhost:1313/posts/18/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Elastic Search] Elastic Search란? Elastic Search의 개념 및 장단점
    </h2>
  </header>
  <div class="entry-content">
    <p>Apache Lucene에 구축되어 배포된 검색 및 분석 엔진이다. 현재 검색엔진을 넘어 보안, 로그분석, Full-text 분석 등 다양한 영역에서 사용되며, Kibana, Logstash, Beats들과 함께 사용된다. 오픈 소스 프로젝트로 활발히 개발되고 있으며, 유닉스, 자바의 기초지식 필요하다. Apache Lucene의 한계를 보완하기 위한 새로운 검색엔진 프로젝트로 시작되었고 Logstash, Kibana와 함께 사용되어 ELK Stack (ES, Logstash, Kibana)라고 불렸으나 2013년 Logstash, Kibana 프로젝트 정식 흡수되었다.## 2. Elastic Stack이란?ES, Logstash, Kibana를 묶은 ELK 서비스이다. 5.0.0 버전부터 Beats를 포함하며 Elastic Stack 이란 이름으로 서비스가 제공되고 있다. 서버로부터 모든 유형의 데이터를 가져와 실시간 검색, 분석, 시각화를 도와주는 Elastic 오픈 소스 서비스 제품이다.### 2-1. Elastic Search- 아파치 루씬(Apache Lucene) 기반의 Full Text로 검색이 가능한 오픈 소스 분석 엔진- 주로 Rest API로 처리- 대량 데이터를 거의 실시간으로 신속하게 저장, 검색, 분석 가능### 2-2. Logstash- 플러그인을 통해 데이터 집계와 보관, 서버 데이터 처리 담당- ES와 상관없이 독자적으로도 사용 가능- 파이프라인으로 데이터를 수집, 필터를 통해 변환 후 Elastic Search로 전송- 입력 - Beats, CloudWatch, Eventlog 등 다양한 입력 지원, 데이터 수집- 필터 - 형식, 복잡성에 상관없이 데이터를 동적으로 변환- 출력 - ES, Email, ECS, Kafka 등 원하는 저장소에 데이터 전송### 2-3. Kibana- 데이터 시각화 도구- 검색 및 aggregation 집계기능을 통해 ES로부터 문서, 집계 결과등을 가져와 웹도구로 시각화- DIscover, Visualize, Dashboard 3개의 기본 메뉴와 다양한 App 들로 구성- 플러그인을 통해 App 설치 가능### 2-4. Beats- 경량 에이전트로 설치- 데이터를 Logstash 또는 ES로 전송- Logstash 보다 경량화 된 서비스- Filebeat, Metricbeat, Packetbeat, Winlogbeat, Heartbeat 등- Libbeat을 통해 직접 구축 가능## 3. Elastic Search의 특징과 장단점### 3-1. 장점#### → 3-1. 실시간분석- 하둡 시스템과 달리 ES 클러스터가 실행되고 있는 동안에는 계속해서 데이터가 입력 (인덱싱) 되고, 동시에 실시간에 가까운 속도로 색인된 데이터의 집계, 검색이 가능#### → 3-2. Full Text 검색 엔진- Lucene은 기본적으로 역파일 색인 구조로 데이터를 저장하며 이를 사용하는 ES도 동일 방식&gt; 역색인 - 일반적인 색인의 목적은 문서의 위치에 대한 index를 생성하여 그 문서에 빠르게 접근하기 위함이지만, 역색인은 문서 내의 문자와 같은(혹은 유사한) 내용들에 대한 매핑 정보를 색인하는 것이다.- 내부적으로는 역파일 색인이라도 사용자 관점에서는 JSON 형식으로 전달- 쿼리문 또는 쿼리에 결과도 모두 JSON 형태로 반환- key-value 형식이 아닌 문서기반으로 되어있어 복잡한 정보를 포함해도 그대로 저장이 가능하여 직관적- 여러 계층 구조의 문서로 저장이 가능하며, 계층 구조로 된 문서도 한 번의 쿼리로 조회 가능#### → 3-3. RESTFul API- Rest API를 기본으로 지원하여 모든 데이터의 조회, 입력, 삭제를 HTTP 프로토콜을 통해 처리 가능#### → 3-4. multitenancy- ES의 데이터들은 index라는 논리 집합 단위로 구성되며 서로 다른 저장소에 분산-저장된다.- 서로 다른 인덱스들을 별도 커넥션 없이 하나의 쿼리로 묶어서 검색, 하나의 출력 결과를 도출한다. (서로 상이한 인덱스일지라도 검색할 필드명만 같으면 여러 인덱스를 동시에 조회 가능)#### → 3-5. 확장성- 분산 구성이 가능, 분산환경에서 데이터는 shard 단위로 분리- 플러그인을 사용한 기능 확장 가능- AWS, MS Azure 같은 클라우드 서비스, Hadoop 플랫폼들과도 연동 가능#### 3-6. 다양한 알고리즘 제공- 점수 기반의 다양한 정확도 알고리즘, 실시간 분석 등의 구현 가능### 3-2. 단점- 색인된 데이터는 내부 commit, flush 등의 프로세스를 거치기에 1초정도 뒤에 검색이 가능- 클러스터의 성능향상을 위해 비용소모가 큰 트랜잭션 롤백이 지원되지 않는다.- 업데이트 요청시 기존 문서를 삭제 후 신규 문서를 재생성하기에 업데이트 비용이 크다.## 4. Elastic Search 구성#### Index- 데이터 저장공간- 하나의 물리 노드에 여러 개의 논리 인덱스 생성- 하나의 인덱스가 여러 노드에 분산 저장#### Shard- 색인된 문서는 하나의 인덱스와 그 내부의 여러 개의 파티션(샤드)으로 나뉘어 구성#### Type- 인덱스의 논리적 구조- 6.1부터 인덱스당 하나의 타입만 설정 가능#### Document- 인덱스가 저장되는 최소단위- JSON 포멧으로 저장- RDBMS의 ROW와 동일#### Field- 문서를 구성하기 위한 속성- 하나의 필드는 다수의 데이터 타입 정의 가능- RDBMS의 컬럼과 동일#### Mapping- 문서의 필드, 필드 속성을 정의하고 색인 방법을 정의하는 프로세스## 5. Elastic Search와 RDBMS의 관계익숙한 관계형 데이터베이스와의 유사 기능 관계를 통해 이해해 보면참고https://jaemunbro.medium.com/elastic-search-%EA%B8%B0%EC%B4%88-%EC%8A%A4%ED%84%B0%EB%94%94-ff01870094f0https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.htmlhttps://velog.io/@hanblueblue/Elastic-Search-1#Elastic Stack #Elastic search
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Elastic Search] Elastic Search란? Elastic Search의 개념 및 장단점" href="http://localhost:1313/posts/50/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Linux] 심볼릭 링크 (Symbolic link) 설정하기
    </h2>
  </header>
  <div class="entry-content">
    <p>링크를 걸어 원본 파일을 직접 사용하는 것과 같은 효과를 낸다. 특정 폴더에 링크를 걸어 NAS, library 원본 파일을 사용하거나 톰캣 빌듯이 상위경로의 파일을 사용하고자 할 때 사용한다. 심볼릭 링크는 단순히 원본파일을 가리키도록 링크만 연결시켜둔 것으로 원본파일을 가리키기만 하고 있으므로 원본파일의 크기와 무관하며 원본파일이 삭제되어 존재하지 않을 경우에 빨간색으로 링크파일의 원본파일이 없다는 것을 알려준다.## 2. 심볼릭 링크 설정하기ln -s [대상 원본 파일] [새로 만들 파일 이름]-- 파일을 생성 후 링크를 거는 것이 아니라 새로 만들 파일/directory가 없는 채로 링크를 생성을 해야한다.### 2-1. ln 옵션- s : 심볼릭링크 생성한다.- b : 링크파일 생성 시에 대상파일이 이미 존재하면 백업파일을 만든 후에 링크파일을 생성한다.- d : 디렉토리에 대한 하드링크파일생성을 가능하게 한다.- f : 대상파일이 존재할 경우에 대상파일을 지우고 링크파일을 생성한다.- i : 대상파일이 존재할 경우에 대상파일을 지울건인가를 확인요청한다.- t : 링크파일을 생성할 디렉토리를 지정한다.### 2-2. 심볼릭 링크 생성(directory)![](/images/posts/16/스크린샷 2023-10-09 오전 11.35.53.png)### 2-3. 심볼릭 링크 생성(file)![](/images/posts/16/스크린샷 2023-10-09 오전 11.36.44.png)원본 파일을 못 찾을 경우 빨간색으로 알려준다.![](/images/posts/16/스크린샷 2023-10-09 오전 11.37.03.png)### 2-4. 심볼릭 링크 삭제rm [링크 파일]rm -r [링크 디렉토리]#Linux #ln #symbolic link #심볼릭 링크
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [Linux] 심볼릭 링크 (Symbolic link) 설정하기" href="http://localhost:1313/posts/16/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[LLM] Google Cloud Discovery Engine 데이터 스토어 업로드 포맷
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [LLM] Google Cloud Discovery Engine 데이터 스토어 업로드 포맷" href="http://localhost:1313/posts/121/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL]  인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법
    </h2>
  </header>
  <div class="entry-content">
    <p>1-1. 인덱스 조회SELECT * FROM pg_indexes WHERE tablename = &#39;{테이블명}&#39;; -- 테이블명에 &#39;&#39; 필요### 1-2. 인덱스 생성-- 단일 인덱스CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명});-- 결합 인덱스CREATE INDEX {인덱스명} ON {테이블명} USING btree({컬럼명1}, {컬럼명2});-- 유니크 인덱스CREATE UNIQUE INDEX {인덱스명} ON table_name ({컬럼명});### 1-3. 인덱스 삭제DROP INDEX {인덱스명};### 1-4. 인덱스 사용 빈도 확인SELECT schemaname, relname, indexrelname, idx_scan as idx_scan_cnt FROM pg_stat_user_indexes ORDER BY idx_scan;### 1-5. 인덱스 손상 시 재인덱싱REINDEX INDEX {인덱스명}REINDEX TABLE {테이블명}REINDEX DATABASE {데이터베이스명}## 2. 인덱스 란?데이터에 색인을 통해 데이터의 위치를 빠르게 찾아주는 역할을 한다. 인덱스 설정 없이는 Seq 스캔을 통해 테이블 전체를 조회하기에 검색 성능이 저하된다.### 2-1. 테이블 스캔 방식Postgresql은 seq scan, index scan, bitmap index scan, index only scan, tid scan 5가지 스캔 방식을 사용한다. 그중 2가지를 확인해 보면,#### ▪ 2-1-1. Seq Scan 방식&gt; - Seq Scan은 테이블을 Full Scan 하여 전체 데이터를 조회한다.- 인덱스가 존재하지 않거나, 인덱스가 존재하더라도 읽어야 할 범위가 넓은 경우에 선택된다.#### ▪ 2-1-2. Index Scan 방식&gt; - Index Scan은 인덱스 Leaf 블록에 저장된 키를 이용해서 테이블 레코드를 액세스 하는 방식이다.- 레코드 정렬 상태에 따라서 테이블 블록 액세스 횟수가 크게 차이 난다.다음과 같이, 인덱스를 사용할 경우 테이블 레코드에 효과적인 접근이 가능하다. 하지만 select 성능은 올라가지만, update, insert, delete시 index 색인정보 갱신을 하기에 시간이 더 소모된다.### 2-2. 인덱스가 적용되지 않는 경우▪ order by {인덱스칼럼 1}, {칼럼 2} : 복수 키에 대해 order by 하는 경우 (order by col1, col2 자체를 인덱스 설정하면 적용가능)▪ where {칼럼 1} = ‘x’ order by {인덱스칼럼 2} : 조건절에 의하여 연속적이지 않게 된 컬럼에 대한 order by▪ order by {인덱스컬럼1} desc, {인덱스컬럼2} asc : desc와 asc의 결합사용▪ group by {인덱스컬럼1} order by {인덱스컬럼2} : group by, order by 컬럼이 서로 다른 경우▪ order by abs({인덱스컬럼1}) : 형 변환 이후의 order by, group by 인 경우### 2-3. 인덱스 설계 방법▪ 명확한 이유를 가진 인덱스만 설계 (많을수록 좋은 게 아니다.)▪ 조회 쿼리들을 전체 확인 후 자주 사용하는 컬럼▪ 고유 값 위주의 설계▪ Cardinality가 높을수록 효율적 (=컬럼별 중복도가 낮을수록 좋다)▪ 인덱스 key의 크기는 되도록 작게 설계▪ PK, join의 대상이 되는 컬럼에 설계▪ 단일 인덱스 여러 개 ▪ Update, delete가 빈번하지 않은 컬럼▪ join의 대상이 자주 되는 컬럼▪ 인덱스를 생성할 때 가장 효율적인 자료형은 정수형 자료 (가변적 데이터는 비효율적)▪ 선택도가 낮을수록 효율적 (10~15%)* 선택도는 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표(특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 수치)= 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100= 컬럼의 값들의 평균 row 수 / 테이블의 총 row 수 * 100### 2-4. 다중 컬럼 인덱스다중 컬럼 인덱스는 두개 이상의 필드를 조합해서 생성한 인덱스이다. 다중 컬럼 인덱스는 단일 컬럼 인덱스 보다 더 비효율적으로 INDEX/UPDATE/DELETE를 수행하기 때문에 생성에 신중해야 한다. (가급적 UPDATE가 안되는 값을 선정해야 한다). 조건절에 여러개의 조건이 있을시, 선행되는 조건과 이를 만족하는 후행되는 조건들을 차례로 함께 INDEX해서 사용한다.#### 2-4-1. 다중 컬럼 인덱스 설계 방법▪ 다중 컬럼 인덱스 구성시 컬럼의 순서는, IO를 적게 발생시키는 순으로 구성하여야 한다.(선행 인덱스에서 더 많은 데이터가 필터링될수록 이후 인덱스의 I/O가 덜 소모된다.)▪ 인덱스 컬럼을 합쳐 색인하기에 선행 인덱스 컬럼이 조건에 있어야 한다.예를 들어CREATE INDEX idx_user_sample ON user USING btree(first_name, address );user 테이블에 first_name, address 두컬럼을 대상으로 다중 컬럼 인덱스를 부여한 후,SELECT * fromWHERE first_name = &#39;Jun&#39;AND address = &#39;Seoul&#39;으로 테이블을 조회할 경우 ‘JunSeoul’에 대한 인덱스를 찾고,B-Tree 인덱스의 left to right 특성대로, address 만으로는 인덱스를 사용할 수 없다. (선행되는 조건절인 first_name에 대한 조건에 부합하는 데이터를 기준으로 인덱싱이 되어있다.)또한CREATE INDEX idx_user_sample2 ON user USING btree(first_name, last_name, address );first name, last name, address로 다중 컬럼 인덱스를 설정할 경우 다음과 같이 인덱스가 사용된다.-- 인덱스 사용SELECT * fromWHERE first_name = &#39;Jun&#39;AND last_name = &#39;H&#39;AND address = &#39;Seoul&#39;-- 인덱스 미사용SELECT * fromWHERE first_name = &#39;Jun&#39;AND address = &#39;Seoul&#39;결론적으로 다중 컬럼 인덱스의 성능은 절대적인 것이 아닌, 어떤 데이터를 조회하는지, 쿼리를 어떻게 작성하는지에 따라 크게 달라질 수 있기에 확실한 쿼리 플랜 분석 및 설계가 필요하다.- [PostgreSQL] B-tree 인덱스의 원리 및 특징- [PostgreSQL] Hash 인덱스의 원리 및 특징- [PostgreSQL] GiST인덱스의 원리 및 특징- [PostgreSQL] SP-GiST인덱스의 원리 및 특징- [PostgreSQL] GIN인덱스의 원리 및 특징- [PostgreSQL] BRIN 인덱스의 원리 및 특징[PostgreSQL] B-tree 인덱스의 원리 및 특징PostgreSQL에는 6가지의 인덱스 종류가 있다. 각각의 인덱스는 다양한 데이터 탐색을 위해 다른 알고리즘을 사용한다. 그중 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘인 B-tree 인덱스에junhkang.tistory.com[PostgreSQL] Hash 인덱스의 원리 및 특징1. Hash 인덱스란? 해쉬 인덱스의 기본 아이디어는, hash function을 통해 작은 숫자를 데이터와 조합하여 integer 형태의 해쉬값 (최대 2^32 = 4B)을 생성하고 해쉬값을 테이블 행 정보(TID)가 저장될 배열junhkang.tistory.com[PostgreSQL] GiST인덱스의 원리 및 특징1. GiST 인덱스란? Generalized Search Tree의 약자이며 B-tree와 같은 balanced search tree의 형태이다. B-tree인덱스는 정렬된 채로 비교&amp;일치의 연산에 최적화된 채로 연결되어있다. 하지만 현대의 다양한 데이junhkang.tistory.com[PostgreSQL] SP-GiST인덱스의 원리 및 특징1. SP-GiST 인덱스란? Space-Partitioned Generalized Search Tree의 약자이다. GiST인덱스와 같이 지리, 좌표, ip주소 데이터 등 복잡한 유형의 데이터를 처리하는 인덱스 유형이다. GiST가 B-tree 인덱스를 통해 보junhkang.tistory.com[PostgreSQL] GIN인덱스의 원리 및 특징1. GIN 인덱스란? Generalized Inverted Index의 약자이다. 이전 포스트인 full text search에서 사용하는 인덱스의 유형. 기본 구조는 B-tree와 유사하지만, 저장 형태가 다르다. 저장된 요소 자제에 대한 검색junhkang.tistory.com[PostgreSQL] BRIN 인덱스의 원리 및 특징1. BRIN 인덱스란? ▪ Block range index의 약자 ▪ Page 검색에 도움 되는 메타 데이터를 뽑아서 인덱스를 구성 (ex, 특정컬럼의 최대/최솟값) ▪ 특정 컬럼이 물리 주소의 일정한 상관관계를 가지는 매우junhkang.tistory.com#인덱스 #Index #PostgreSQL</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL]  인덱스(INDEX)개념 및 생성, 삭제, 분석, 설계 방법" href="http://localhost:1313/posts/5/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] 2단계 커밋 프로토콜(Two-Phase Commit Protocol), Prepare transaction
    </h2>
  </header>
  <div class="entry-content">
    <p>PostgreSQL은 two-phase commit (2PC) 프로토콜을 지원한다. 다수의 분산 시스템 환경에서 모든 데이터베이스가 정상적으로 수정되었음을 보장하는 두 단계 커밋 프로토콜로 분산 트랜잭션에 참여한 모든 데이터베이스가 모두 함께 커밋되거나 롤백되는 것을 보장한다. PostgreSQL의 2단계 트랜잭션은 외부 트랜잭션 관리 시스템에서 사용하기 위해 존재하며 X/Open XA 표준에서 제안된 특징과 모델을 따른다. (사용빈도가 낮은 일부 기능은 구현되지 않았다.) 2단계 커밋은 다음 스탭에 따라 작동된다.Coordinator CohortQUERY TO COMMIT--------------------------------&gt;VOTE YES/NO prepare*/abort*&lt;-------------------------------commit*/abort* COMMIT/ROLLBACK--------------------------------&gt;ACKNOWLEDGMENT commit*/abort*&lt;--------------------------------end[커밋 요청단계]- PREPARE를 통해 Coordinator가 데이터베이스 각 노드에 커밋을 준비 요청- 각 데이터베이스는 필요 리소스에 LOCK 설정, 로그파일 저장 등 커밋 준비 작업 실행- 준비 과정의 실패/성공 여부 알림[커밋 단계]- 모든 데이터베이스 노드로부터 완료 메시지를 받을 때까지 대기- 한 데이터베이스라도 PREPARE OK를 받지 못하면, 모든 데이터베이스 노드에 롤백 메시지를 보내 해당 작업 롤백- 모든 데이터베이스에서 PREPARE OK를 받으면 모든 데이터베이스 노드에 커밋 메시지를 보내고 모든 작업 커밋짧은 기간의 PREPARED 트랜잭션은 공유 메모리와 WAL에 저장되며 체크포인트의 트랜잭션은 pg_twophase 디렉터리에 기록된다.## 2. PREPARE TRANSACTION### 2-1. PREPARE TRANSACTION란?PREPARE TRANSACTION &#39;foobar&#39;;PREPARED TRANSACTION 구문은 2단계 커밋을 위해 현재 트랜잭션을 준비 상태로 변경한다. 이 명령어 후에 해당 트랜잭션은 현재 세션과 완전히 분리되며, 해당 트랜잭션의 상태가 디스크에 완전히 저장된다. 그리고 해당 트랜잭션은 데이터베이스가 커밋요청 전에 충돌하더라도 성공적으로 커밋될 확률이 높다.PREPARED TRANSACTION이 성공하면 트랜잭션은 COMMIT PREPARED, ROLLBACK PREPARED로만 커밋/롤백된다. 해당 커맨드는 PREPARED를 실행한 세션 외에 어떤 세션에서도 실행 가능하다.구문을 실행한 세션의 시점에서 봤을 때 PREPARED TRANSACTION과 ROLLBACK 명령어는 큰 차이가 없다. 현재 진행 중인 트랜잭션은 없어지고, PREPARE TRANSACTION의 실제 결과는 보이지 않기 때문이다. (PREPARED COMMIT 후에나 차이를 알 수 있다.) PREPARE TRANSACTION 명령어가 실패한다면, 현재 트랜잭션이 취소되며 ROLLBACK과 동일한 결과를 나타낸다.지금 실행 중인 prepared 트랜잭션은 pg_prepared_xacts에서 확인 가능하다.[pg_prepared_xacts]- TransactionId - 트랜잭션 ID- GID - 유저가 정의한 트랜잭션 이름- Prepared Date - 트랜잭션 생성일, timestamp with timezone- Owner - 트랜잭션 생성자- Database - 해당 데이터베이스 명### 2-2. 주의사항- PREPARE TRANSACTION은 애플리케이션, 혹은 상호 통신하는 세션을 위한 기능이 아니다. 외부 트랜잭션 관리자가 다양한 트랜잭션이나 기타 트랜잭션 리소스에 걸쳐 원자단위의 글로벌 트랜잭션을 수행할 수 있도록 하는 것이 목적이기에, 만약 transaction manager를 쓰는 것이 아니라면 PREPARE TRANSACTION의 사용을 중단해야 한다.- 트랜잭션 내부에서만 사용해야 한다.- 임시 테이블이나 세션의 임시 네임스페이스를 포함한 명령어나 WITH HOLD, LITEN, UNLISTEN, NOTIFY를 PREPARE에 사용하는 것은 불가능하다. 해당 기능들은 현재세션과 너무 타이트하기 연결되어 있어 트랜잭션 사용에 유용하지 않다.- 런타임 파라미터를 변경한다면, PREPARE TRANSACTION 이후에도 적용되며 COMMIT PREPARED, ROLLBACK PREPARED의 영향을 받지 않는다. 이러한 측면에서 PREPARED TRANSACTION은 롤백보다는 커밋에 더 가깝다.- 클라이언트가 사라지면 종료되지 않은 채로 트랜잭션이 남을 수 있고, PREPARE 스탭만 백업이 복구되면서 트랜잭션을 닫는 스탭이 없어 계속 유지될 수도 있다. PREPARE 구문을 사용한다면, 트랜잭션 매니저를 통해 해당 트랜잭션들을 주기적으로 관리해주어야 한다.- PREPARE 구문이 계속 열려있을 경우 Lock 같은 주요 시스템 자원을 계속 잡고 있을 수 있고, 트랜잭션 ID를 계속 유지하고 있기에 vacuum 시에 사용되지 않는 dead tuple 임에도 정리되지 않을 수 있다.## 3. COMMIT/ROLLBACK PREPAREROLLBACK PREPARED transaction_id;COMMIT PREPARED &#39;foobar&#39;;- PREPARE 상태의 트랜잭션을 커밋/롤백시킨다.- 커밋/롤백을 위해서는 해당 트랜잭션을 실행시킨 유저와 동일하거나, superuser권한이 있어야 한다.- 트랜잭션이 실행된 세션과 동일한 세션에 있을 필요는 없다.- 트랜잭션 블록 안에서 사용이 불가능하다. (PREPARED TRANSACTION이 즉시 커밋/롤백된다.)PostgreSQL Extension 기능이며, 외부 트랜잭션 관리 시스템에서 사용하기 위해 만들어졌으며, 트랜잭션 매니저와 함께 사용하는 것을 권장한다.https://www.postgresql.org/docs/9.6/sql-rollback-prepared.htmlhttps://www.postgresql.org/docs/9.6/sql-prepare-transaction.htmlhttps://www.postgresql.org/docs/9.6/sql-commit-prepared.htmlhttps://www.highgo.ca/2020/01/28/understanding-prepared-transactions-and-handling-the-orphans/#PostgreSQL #2pc #prepared
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] 2단계 커밋 프로토콜(Two-Phase Commit Protocol), Prepare transaction" href="http://localhost:1313/posts/68/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] Hash 인덱스의 원리 및 특징
    </h2>
  </header>
  <div class="entry-content">
    <p>해쉬 인덱스의 기본 아이디어는, hash function을 통해 작은 숫자를 데이터와 조합하여 integer 형태의 해쉬값 (최대 2^32 = 4B)을 생성하고 해쉬값을 테이블 행 정보(TID)가 저장될 배열의 인덱스 값으로 사용하는 것이다. 이 배열의 각 요소를 해시 테이블 버킷(hash table bucket)이라고 한다. 데이터 조회 시, hash function을 통해 생성된 key가 포함된 bucket을 찾고, 그 bucket만 확인하면 실제 데이터의 위치를 바로 확인할 수 있다. 데이터의 크기에 상관없이 인덱스의 크기가 작고 검색이 빠르다. 1개의 데이터를 조회하는 시간은 O(1)로 빠르지만 해쉬 테이블 내의 값들은 정렬이 되어있지 않기 때문에 범위 비교나 부정형 비교가 포함된 조건에서는 인덱스를 사용할 수 없다. Hash function이 버킷 단위로 소스 값을 더 균일하게 분배할수록 효율이 좋다.### ▪ 1-1. Collision그러나 아무리 좋은 해시 함수라도 다른 키 값에 대해 동일한 해쉬값을 리턴하는 경우가 있고 이런 경우를 “충돌(collision)“이라고 한다. 하나의 버킷은 서로 다른 TID를 저장할 수 있으므로 인덱스에서 얻은 실제 값을 재확인하여야 한다. 예를들어, 256개의 버킷이 있다면, 모든 문자열의 첫 글자로 해쉬값을 생성할 수 있다. 이 경우 동일한 문자로 시작하는 모든 문자열이 동일한 해쉬값을 가진 채로 한 버킷으로 들어갈 것이고, 실제 버킷에서 값이 찾아진 후에도 TID의 검증이 계속 필요할 것이며, 해싱의 의미가 없어질 것이다.이를 방지하기위해 Hash function은 hashcode - TID 쌍을 순차적으로 저장하여 효율적으로 bucket 내 동일 hash codes들 중에 정확히 일치하는 TID만을 찾는다.## 2. Hash 인덱스 구조- Meta page - Root, 첫 번째 page, 인덱스 정보 포함- Bucket pages - 인덱스의 메인 page, “hash code - TID” 쌍으로 데이터를 저장- Overflow pages - bucket pages와 동일한 구성, 한 page가 버킷에 부족할 때 사용됨- Bitmap pages - overflow pages를 계속해서 추적하며 clear 한 지, 다른 버킷에서 재사용 가능한지 확인한다해쉬 인덱스의 크기는 줄어들지 않는다. 인덱스 열을 삭제하여도 한번 할당된 bucket은 os로 반환되지 않는다. Vacuuming, reindexing을 통해 전체 삭제 후 처음부터 다시 인덱싱은 가능하다.#### ▪ 결론- Hash 인덱스는 단일 값 검색에서는 효율적인 성능을 보인다. (B-Tree에 비해 작은 인덱스 size, O(1))- 범위, 부정형 조건에 대한 검색에서는 사용 불가하다.- 한번 생성된 버킷은 인덱스를 제거하여도 초기화 전에는 메모리에 반환되지 않는다.참고 : https://postgrespro.com/blog/pgsql/4161321#Index #PostgreSQL #Hash Index
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] Hash 인덱스의 원리 및 특징" href="http://localhost:1313/posts/7/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] MVCC (Multi-Version Concurrency Control)
    </h2>
  </header>
  <div class="entry-content">
    <p>동시성 제어를 위해 lock을 사용하는 대부분의 다른 데이터베이스 시스템과 달리 Postgres는 다중 버전 모델(multiversion model)을 사용하여 데이터 일관성을 유지한다. 각 트랜잭션이 데이터베이스를 쿼리 하는 동안 데이터의 현재 상태에 관계없이 얼마 전의 데이터 스냅샷을 볼 수 있음을 의미한다. 데이터를 쿼리 하기 위해 트랜잭션을 만들었다면 해당 Transaction은 데이터의 스냅샷을 보고 있는 것이다.동일한 행에 서로 다른 트랜잭션이 동시에 업데이트를 시도할 때, 일관성 없는 데이터가 조회되지 않도록 트랜잭션을 보호하여 각 데이터베이스 세션에 대한 트랜잭션 격리를 제공한다. Multiversion과 Lock model의 주요 차이점은 MVCC에서 데이터 read를 위해 획득한 lock과 데이터 쓰기를 위해 획득한 lock이 충돌하지 않는다는 것이다. (따라서 read와 write는 서로 block 하지 않는다.) 이러한 방식을 통해서 Reading 하는 작업에 대해서 Lock을 걸지 않기에 높은 성능을 얻을 수 있게 된다.### 1-1. Postgresql Lock에 대한 상세 설명2023.09.11 - [Postgresql] - Postgresql Lock이란? (조회 및 kill, Dead lock)Postgresql Lock이란? (조회 및 kill, Dead lock)1. Lock 확인방법 SELECT PSAT.RELNAME, PL.LOCKTYPE, PL.PID, PL.MODE, PL.GRANTED FROM PG_LOCKS PL, PG_STAT_ALL_TABLES PSAT WHERE PL.RELATION = PSAT.RELID 2. Lock Kill 방법 SELECT PG_CANCEL_BACKEND([PID]) SELECT PG_TERMINATE_BACKEND([PID]) Lock 리스junhkang.tistory.com## 2. PostgreSQL의 MVCCPostgreSQL에서는 record를 tuple이라고 한다. PostgreSQL에서는 멀티버전에 대한 정보를 하나의 Page ( Table )에서 관리하고 있다. 모든 테이블에는 System Columns을 가지고 있고 이들은 미리 정의된 컬럼들로 내부 동작에 사용된다. 이 컬럼 중 mvcc를 구현하게 해주는 것이 xmin, xmax 컬럼이다.&gt; xmin – Tuple을 insert 하거나 update 하는 시점의 Transaction ID를 갖는 메타데이터xmax – Tuple을 delete 하거나 update 하는 시점의 Transaction ID를 갖는 메타데이터신규 insert, update시 xmin에 현재 transaction id를 넣고 xmax에는 null 값을 넣는다. delete, update시 이전 tuple의 xmax에는 작업을 수행한 transaction id 값을 넣는다. 이를 통해 트랜잭션이 시작된 시점의 Transaction ID와 같거나 작은 Transacion ID를 가지는 데이터를 읽는다. (xmin과 xmax의 범위를 통해 해당 트랜잭션이 조회할 수 있는 데이터인지를 판단한다.)xmin | xmax | value-------&#43;-------&#43;-----100 | 120 | A102 | 120 | B110 | 134 | C115 | 0 | D115 | 120 | E&gt; [Transaction ID 별 조회 가능한 데이터]Transaction 101에서는 ATransaction 109에서는 A, BTransaction 112에서는 A, B, CTransaction 117에서는 A, B, C, D, E하나의 page에 이전 tuple들이 그대로 존재하기 때문에, row가 삭제되어도 용량은 그대로 차지하는 경우가 있다. 쿼리 성능 또한 지속적으로 떨어지게 된다. 따라서 PostgreSQL에서는 Vacuum 작업을 진행해주어야 한다.Vacuum에 대한 상세 개념은 해당 포스트에서 확인할 수 있다.2023.10.09 - [Postgresql] - [PostgreSQL] Vacuum 개념 및 적절한 사용[PostgreSQL] Vacuum 개념 및 적절한 사용1. Vacuum 이란? Vacuum은 postgresql에서 dead tuple이 차지하는 저장공간을 회수한다. 일반적으로 Postgresql에서 update, delete tuple 은 물리적으로 삭제되지 않으며 vacuum이 완료될 때까지 계속 존재한다. (updatjunhkang.tistory.com[참고]https://techblog.woowahan.com/9478/https://www.postgresql.org/docs/9.1/ddl-system-columns.htmlhttps://www.postgresql.org/docs/7.1/mvcc.html#Lock #Vacuum #PostgreSQL #MVCC
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] MVCC (Multi-Version Concurrency Control)" href="http://localhost:1313/posts/15/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] SP-GiST인덱스의 원리 및 특징
    </h2>
  </header>
  <div class="entry-content">
    <p>Space-Partitioned Generalized Search Tree의 약자이다. GiST인덱스와 같이 지리, 좌표, ip주소 데이터 등 복잡한 유형의 데이터를 처리하는 인덱스 유형이다. GiST가 B-tree 인덱스를 통해 보관 데이터를 세분화할 때, 위계적 순서를 따라야 하기에, 이를 보완하기 위해 만들어진 유형으로, GiST로 분리된 공간을 다시 한번 공간 단위로 나누어 관리하는 개념이다. SP-GiST는 겹치지 않는 영역으로 재귀적 분할을 할 수 있는 구조에 적합하다. 기본적으로 SP-GiST는 다양한 데이터 유형, 복잡한 쿼리를 지원하도록 설계되었다.### 1-1. SP-GiST 인덱스 생성CREATE INDEX idx_spgist_example ON example_table USING spgist (column1);### 1-2. 장점&gt; 다양한 종류의 데이터 타입에 사용 가능 : 기하학, IP, 다른 복잡한 데이터 타입복잡한 쿼리에 사용 가능 : 복잡한 데이터구조, 쿼리에 사용 적합하도록 설계빠른 검색 효율### 1-3. 단점&gt; 복잡한 구현 방법 : btree/hash 에 비해 구현이 복잡하다.느린 업데이트 : SP-GiST index는 업데이트가 느리다, 복잡한 알고리즘인 만큼 특정 데이터 변경시 인덱스의 업데이트가 느리다.한정된 쿼리 유형 : 복잡한 유형의 쿼리에 특화 되어있다보니 =, &lt;등 간단한 타입의 비교에는 고려되지 않을 수 있다.### 1-4. 그렇다면 SP-GiST는 GiST인덱스와 어떻게 다를까?#### ▪ 1-4-1. Operator&gt; ▪ GiST에 비해 SP-GiST를 지원하는 operator가 적다. (SP-GiST 지원 Operator는 아래에서 확인가능)(GiST는 (k) NN searches를 포함한 모든 operator 지원을 받는다.)#### ▪ 1-4-2. 인덱스 생성 시간&gt; ▪ GiST 인덱스의 생성시간은 데이터 증가에 따라 비선형적이지만 안정적으로 증가한다.▪ SP-GiST 인덱스는 적은 데이터일 경우 빠르지만, 몇 억 건이 넘어갈 경우 GiST에 비해 현저히 떨어지는 속도를 보인다.#### ▪ 1-4-3. 데이터 밀집도에 따른 효율성&gt; ▪ GIST는 기하학적 구조의 공간 분포와 토폴로지에 크게 민감하지 않다.▪ SP_GIST는 공간 분할(Spatial Partitioning)로 인해 중첩되지 않는 지오메트리에 가장 효과적이며 공간적으로 균일한 분포에 대한 검색에 효율적이다.데이터 사이즈, 구조, 사용하는 쿼리 등에 따라 인덱스의 효율성이 달라질 수 있어, 실제 데이터로 GiST, SP-GiST의 성능테스트가 꼭 필요하다.## 2. 지도 / 좌표 형태의 데이터 인덱싱다음과 같이 위도/경도 데이터로 조회를 시도할 시 효율적이다SELECT city_nameFROM locationsWHERE ST_DWithin(ST_MakePoint(:longitude, :latitude), ST_MakePoint(longitude, latitude), :distance);지도의4분 할로 지속적으로 나눈다. 각각의 사각형이 index page 역할을 한다나눠진 부분을 좀 더 상세히 보면다음 좌표에서 (2,7) 위에 존재하는 좌표들을 찾고 싶다면select * from points where p &gt;^ point &#39;(2,7)&#39;(4,4)를 (2,7)과 비교하여 더 큰 좌표가 존재할 수 있는 영역을 확인한다.1 사분면의 중심좌표인 (6,6)으로 다시 비교하여 더 큰 좌표가 존재할 수 있는 영역을 확인한 후 다음과 같은 인덱스 구조를 생성한다.## 3. Built-in Operator ClassNameIndexable OperatorsOrdering Operatorsbox_ops(box,point)&amp;&amp;&gt; (box,box)» (box,box)@&gt; (box,box)= (box,box)&amp;&amp; (box,box)&amp;|&amp;&gt; (box,box)|» (box,box)inet_ops» (inet,inet)»= (inet,inet)= (inet,inet)&lt;&gt; (inet,inet)&gt; (inet,inet)&gt;= (inet,inet)&amp;&amp; (inet,inet)kd_point_ops|» (point,point)(point,point)» (point,point)= (point,point)poly_ops(polygon,point)&amp;&amp;&gt; (polygon,polygon)» (polygon,polygon)@&gt; (polygon,polygon)= (polygon,polygon)&amp;&amp; (polygon,polygon)&amp;|» (polygon,polygon)|&amp;&gt; (polygon,polygon)quad_point_ops|» (point,point)(point,point)» (point,point)= (point,point)range_ops= (anyrange,anyrange)&amp;&amp; (anyrange,anyrange)@&gt; (anyrange,anyelement)@&gt; (anyrange,anyrange)» (anyrange,anyrange)&amp;&amp;&gt; (anyrange,anyrange)-|- (anyrange,anyrange)text_ops= (text,text)&gt; (text,text)&gt;= (text,text)~~~&gt;=~ (text,text)&gt; (text,text)^@ (text,text)참고https://www.postgresql.org/docs/current/spgist-builtin-opclasses.htmlhttps://gis.stackexchange.com/questions/374091/when-to-use-gist-and-when-to-use-sp-gist-index#Index #PostgreSQL #SP-GIST
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] SP-GiST인덱스의 원리 및 특징" href="http://localhost:1313/posts/9/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">[PostgreSQL] Trigger, Procedure, Function (history 관리하기)
    </h2>
  </header>
  <div class="entry-content">
    <p>특정 테이블에 insert, update가 수행될 경우 무조건 내역에 “insert&#34;를 하는 간단한 트리거 생성 예제이다.#### 1-1. 함수를 실행할 트리거 생성create trigger trigger_save_historyafter insert or update on Afor each rowexecute procedure trigger_insert();#### 1-2. 실제 insert문이 실행되는 함수CREATE OR REPLACE FUNCTION trigger_insert()returns triggerAS $$DECLAREBEGINinsert into B(id, values, date)values(new.id, new.values, current_timestamp());return NULL;END; $$LANGUAGE &#39;plpgsql&#39;;하지만 특정 table에 insert, delete, update에 따라 서로 다른 테이블에 이력을 보관하거나, 기존 이력을 업데이트하는 등서로 다른 행위에 대한 트리거가 필요한 경우가 있다.그럴경우 다음 예제처럼 TG_OP을 통해 데이터베이스에 UPDATE, INSERT, DELETE를 분기하는 것이 가능하다. 또한 old, new를 통해 delete의 삭제 전 값, update의 업데이트 전, 후 값을 각각 사용할 수 있다.## * 수행되는 SQL에 따라 별도 history 저장 트리거 생성 예제CREATE OR REPLACE FUNCTION TRIGGER_INSERT()RETURNS TRIGGERLANGUAGE PLPGSQLAS$function$BEGINIF (TG_OP = &#39;UPDATE&#39;) THENinsert into update_history(id, values, date)values(new.id, new.values, current_timestamp());return NULL;ELSIF (TG_OP = &#39;INSERT&#39;) THENinsert into insert_history(id, values, date)values(new.id, new.values, current_timestamp());return NULL;ELSIF (TG_OP = &#39;DELETE&#39;) THENinsert into delete_history(id, values, date)values(new.id, old.values, current_timestamp());return NULL;END IF;RETURN NULL;END$function$;## 1. 트리거(Trigger) 란 무엇일까?특정 SQL이 실행될 때 자동으로 실행되는 객체이다. 테이블의 변경 감지 및 로깅에 많이 사용되며, 데이터만 전달 후 연산 자체를 DB에 넘기기에 부하 및 확장성을 고려하여 적용하여야한다. 단일 함수를 생각할 경우 서버 로직보다 트리거 함수가 빠르고 쉽게 적용되는 경우가 있지만, 트리거가 너무 많은 경우 문제발생 원인파악과 유지보수가 힘들다. 또한 코드가 복잡하여 작성자 외 트리거 내용을 분석하기 힘들다. 또한, 트리거 함수가 동작할 때, 트리거의 영향을 받는 모든 개체들은 트랜잭션이 열린 상태로 유지된다. 즉, 트리거 연산 시간만큼 트랜잭션 lock 타임도 길어진다. 부적합한 트리거는 성능을 크게 저하시킬 수 있다. 그래서 복잡한 로직을 처리하기보다는, 간단한 실행에 사용하고, 트리거 작성 시 정확한 목적과 동작방식을 문서화하는 것이 중요하다.&gt; - 특정 SQL이 실행될 때 자동으로 실행되는 객체이다- 트리거 내에서 COMMIT / ROLLBACK 사용불가하다.- 쿼리문장별, ROW별로 실행가능하다.- OLD / NEW 를 통해 실행된 쿼리의 이전, 이후값 접근 가능하다.- 특정 PROCEDURE / FUNCTION을 실행시킬 수 있다.## 2. 프로시저(Procedure)와 함수(Function)는 무엇일까?자주 사용되는 특정기능을 모듈화 시켜놓은 것을 함수(function) 또는 프로시저(procedure)라고 하는 것을 알고 있다. PostgreSQL에서 정확히 어떻게 사용되며 차이점은 무엇일까?### 2-1. FUNCTION- 주로 클라이언트에서 실행 (어플리케이션에서 호출)- 리턴값 필수- 저장해서 쓰는 프로시져 ( 인자만 변경하여 자유롭게 재사용 가능 )- 반복작업을 줄여주며 여러개의 쿼리문을 묶어서 실행 가능- 특정 계산을 수행### 2-2. PROCEDURE- 리턴값은 필요에 따라 반환- DB서버에서 실행(처리속도 빠름)- 미리 컴파일된 SQL 명령어의 집합- 특정 작업을 수행### 2-3. 차이점 비교함수(Function)프로시저(Procedure)특정 계산 수행특정 작업 수행리턴값 필수 O리턴값 필수 X리턴값이 1개여야만 함리턴값이 여러개일 수 있음Client에서 실행 (어플리케이션에서 호출)Server에서 실행(DB)단독 문장 구성 불가단독 문장 구성 가능수식내에서만 사용 가능수식 내에서 사용 불가#function #Trigger #PostgreSQL #Procedure
...</p>
  </div>
  <footer class="entry-footer">Jun Kang</footer>
  <a class="entry-link" aria-label="post link to [PostgreSQL] Trigger, Procedure, Function (history 관리하기)" href="http://localhost:1313/posts/3/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/tags/0/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Jun Kang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
